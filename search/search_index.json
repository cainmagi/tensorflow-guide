{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"扉页 ¶ 摘要 Tensorflow总纲，写给初学者们。本页面将简述Tensorflow的基本原理，结构设计以及版本更新。读者亦可在本页找到本教程将提供给读者对Tensorflow怎样的认识。 注意 由于技术限制，现在中文搜索功能无法完善，请注意当搜索关键词的时候自行分词，例如： 开放源代码软件库 无法搜到任何内容。但可以搜索 开放 源代码 软件 库 即可确保索引到上述内容。 Tensorflow总说 ¶ Tensorflow官网 TensorFlow™ 是一个开放源代码软件库，用于进行高性能数值计算。借助其灵活的架构，用户可以轻松地将计算工作部署到多种平台（CPU、GPU、TPU）和设备（桌面设备、服务器集群、移动设备、边缘设备等）。TensorFlow™ 最初是由 Google Brain 团队（隶属于 Google 的 AI 部门）中的研究人员和工程师开发的，可为机器学习和深度学习提供强力支持，并且其灵活的数值计算核心广泛应用于许多其他科学领域。 Tensorflow治学 ¶ 写在所有内容之前，读者不得不看以下几个页面，本教程所述内容大略来自于对这些资料的研读。 Tensorflow官网(中/英文) : https://www.tensorflow.org/ Keras中文文档 : https://keras-zh.readthedocs.io/ Tensorflow 2.0前瞻(英文) : https://medium.com/tensorflow/effective-tensorflow-2-0-best-practices-and-whats-changed-a0ca48767aff Tensorflow 2.0前瞻(中文) : https://zhuanlan.zhihu.com/p/50049041 提示 特别值得注意的是，现在官方文档至少在教程部分， 已经支持中英双语 。相比官方文档，我们的教程更侧重于以搭建工程为导向的设计。然而现在官方文档的翔实可读程度，确实不可错过。另一方面，Keras的 官方中文文档 似乎已不再更新，上面提供的原官方中文文档译者现在正在更新、维护的版本。 大略来说，学习Tensorflow主要应当依赖于官方文档的介绍。敝人自r1.4版开始入门Tensorflow，即是通过学习官方文档的教程来快速上手。相比四处蒐集资料，官方文档能提供一个完整、系统、完全贴合时下最新API的例子，帮助用户建立一个与Tensorflow各个功能合宜的使用习惯。若是通过在Github上检索他人的project，固然是一个很好的上手办法，但是往往就会遗漏某些重要的功能而不学。例如，Tensorflow自带的网络存取和Tensorboard API，在时兴的一些project中，经常会因方便之故，以numpy的IO来代替。笔者以为，如此培养起来的使用习惯，可谓走入偏门。当然，从这一点来说，本教程也亦复如是，即使笔者写下这些内容的时候，参照的乃是时下最新的API，时间一久，难免会过时。倘若笔者懒惰一些，不再时时更新本教程，那么本教程也就入不足取之流了。 虽然如此，教程也有并不合宜的地方。最大的问题莫过于Tensorflow本身，它有着日新月异的变化，此时能圆转如意地使用的API，到了彼时也许就成了废案。这就导致Tensorflow的官方教程也不断更新。r1.4时，教程还主要集中在如何使用“底层”API上，到了r1.9.0，就已经变成基本围绕着 tf.keras 设计的思路了。最新消息显示，即将上线的Tensorflow 2.0，将会彻底抛弃过去的“中层”API以下的全部方法， tf.layers , tf.contrib 都将被移除，倘若长期墨守成规，局限在入门时候的一套技术上，迟早会被官方库如此迅速的更新所弃。这也是无可奈何之事。毕竟Tensorflow仍然处于不断改进之中。倘若希望追求一个更加稳定、长期可用的库，keras或许是一个不错的选择。 故而，本教程将基本基于Tensorflow现在的版本(r1.12)展开介绍。本教程既可以看作一个入门教程，也可以看作是本人重新自学新版Tensorflow规范化API的一个手记，故而命名本教程为“手札”。读者不妨跟着笔者的思路，有如与笔者共学一般读下来本教程。 Tensorflow原理 ¶ 一个标准的Tensorflow工作流可以表示成这样： graph TD st(开始) --> Sess[启动Session] Sess --> ConNet[构建网络] subgraph 构造流程 ioNet>读取网络参数] --> ConNet end subgraph 执行流程 ioDat>导入数据] --> Run ConNet --> Run[执行网络] Run --> ioNetS>保存网络参数] Run --> ioRes>导出结果] end ioRes --> SessCl[关闭Session] SessCl --> ed(结束) classDef styStart fill:#FAE6A9,stroke:#BA9132; classDef styIO fill:#cde498,stroke:#13540c; class st,ed styStart class ioNet,ioNetS,ioDat,ioRes styIO 与一般的计算库不同，Tensorflow的执行流程大体可以分为两步： 构造流程 : 在这一步，Tensorflow根据用户代码构造一个 数据流图(dataflow graph) 。所谓数据流图，指的是由一系列 张量(Tensor) 构成的符号运算集合。就如同一张流程图一样，在这一阶段，尽管用户定义了每一步的运算（从简单的加减乘除到复杂的网络单元），但是没有任何运算被执行。就像一个程序员撰写代码一样，Tensorflow在这一步，将用户的代码转换成它的“机器语言”，但是网络还没有进入被使用的阶段。 执行流程 : 在这一步，Tensorflow将计算用户指定的某个 Tensor 的输出结果。要得到一个Tensor的输出，则必须得计算它一系列的依赖变量。例如，我们已知 y = x_1 + x_2 y = x_1 + x_2 , x_2 = z_1 \\times z_2 x_2 = z_1 \\times z_2 。那么，如果Tensorflow要得到 y y 的结果，它就必须先计算 x_2 x_2 。这个过程被完全地封装起来，从用户看来，我们只需要调用 y y 的输出即可，不需要关心Tensorflow是怎样按照流图完成计算的。 因此，典型的Tensorflow式的语言风格也可以这样划分： 构造流程 : 用户定义整个网络的符号运算，指定网络各个节点的属性、输入和输出。这些代码往往被写成一个函数（例如 def construct (): ） 执行流程 : 创建一个Session，在Session内调用构造函数，然后输入数据，得到并保存输出结果。必要情况下，还需要导入导出网络参数。 这里提到 会话(Session) 。Session如同一个Tensorflow虚拟机，在一个Session打开的时候，设备的计算资源（GPU, CPU, 带宽等）才被加载。Session又如同一个工人，用户撰写的网络构造代码如同车间，输入的数据如同商品，“工人（Session）”利用预定义好的“车间（流图）”将可以快速、批量地生产这些“商品（数据）”。这样地设计保证了一些外围的代码，例如指定网络参数的名称、函数的属性等操作，不需要重复进行，从而确保处理数据的时候，总是执行必要的代码，加快运算速度。 另一方面，构造-执行的结构还封装了许多提高运算效率的特性，例如多线程。尽管用户定义网络构造的时候，所写的代码是按照逻辑顺序的、线性的。但实际运行的时候，Tensorflow可以自行发现网络的哪些部分可以被同时运行，从而利用多核系统的计算资源。这些过程也是被完全封装起来的，用户并不需要花费心思去专门进行这些调整。 须知 在Tensorflow已经转变为Keras导向的现在，Session的调用被Keras API封装了起来，从用户的角度来看，现在已经不再需要手动调用Session。 Tensorflow API架构 ¶ 下图显示了当前Tensorflow-API的组织形式 Tensorflow在多个平台上均有部署，包括Python, C++, Java, Javascript, Go等，未来还可能支持更多的语言。然而，不同平台上，API的使用方式和代码风格是大不相同的。例如，Python的语言风格目前已经朝向Keras转变，而Javascript仍倾向于使用中层API；C++和Java偏向于使用底层API编写程序。本教程只针对时兴Python的API编写，除非涉及到特定的专题，不会讨论其他语言上Tensorflow的用法。 一般而言，Tensorflow将API面向划分为三个层次： 高层API (High level) : 包括Estimators和Keras； 中层API (Mid level) : 包括layers, datasets, loss和metrics等具有功能性的函数，例如网络层的定义，Loss Function，对结果的测量函数等； 底层API (Low level) : 包括具体的加减乘除、具有解析式的数学函数、卷积、对Tensor属性的测量等。 从r1.4入门的用户，所接受的训练往往是从底层API开始，使用自己的代码风格构建对应中层API的函数，然后再用自己定义好的中层API构建网络。在这种代码风格的驱使下，用户除了需要定义各个网络层具体的表达式，还需要设计输入输出的接口，用来调用 优化器(optimizer) 的接口等操作。 另一种使用方式，是从中层API开始，直接使用预定义好的网络层构建网络，这样的代码风格会节省一部分时间，相当于几乎不再需要接触底层API，但是在输入输出、网络训练和测试等更高层的模块设计上，和底层API用户的代码风格相似。 Estimators是从r1.4就已经存在的API了，它可以被看成是已经集成在Tensorflow里的完整的网络。因此，Estimators往往适合分发、需求不高的应用，但是并不适合使用Tensorflow的研究者。尽管至今为止，Tensorflow仍然对Estimators倍加推崇，但本教程将完全不涉及这方面的内容。 另一个高层API是 Eager Execution ，从r1.9起，Tensorflow就加入了这种新的使用模式，并且在Tensorflow 2.0中，它仍然将会被保留。Eager摈弃了上述的构造-执行流程，任何对Tensor的定义会被立时计算、并可得到结果。对于需要进行小规模的调试、检查API功能的用户而言更加方便。但是，据一些用户的反响，现在Eager还没有做到和之前API的完全兼容，本教程将基本不涉及Eager的用法。 因此，Keras API将是本教程的重中之重。使用本教程的用户，可以对照目前的官方文档，跟进本教程的思路，自己逐步实现各个project的设计。使用Keras风格的设计，代码量会明显少于前面提到的各种风格（Estimators除外）。事实上， tf.keras 和底层API之间具有一定的兼容，这样的编写风格能让我们在满足自己设计的派生功能的基础上，尽可能使用规范化、预定义的API单元，从而减少代码出错的可能性。通过对本教程TF 1.x版的学习，对未来2.0版的上手也会带来莫大帮助。 金宇琛( @cainmagi )，2019年3月2日 Yuchen Jin( @cainmagi ), Mar. 2, 2019 教程导读 ¶ 接下来，本教程将会涉及 从线性问题入门 : 如何使用Tensorflow完成一个简单的线性分类设计，我们将从Hello World开始，逐步过渡到一个具有核函数的非线性问题project。 Hello world: 第一个Tensorflow程序。 线性分类: 一个简单的二分类问题。 线性回归: 一个同样简单的，线性拟合问题。 非线性回归: 拟合一个简单的，可以表达出解析式的非线性函数。 非线性分类: 使用线性分类器对非线性分布的数据进行分类。 训练与测试分立 : 从这一章开始，并试图解决几个更加复杂的实际问题。这里涉及到的project相对更大、更完整，训练往往需要一定时间才能完成。因此，在本章，所有项目的训练、测试环节都会分开，我们将从这里开始，使用TensorBoard跟踪我们的训练情况，并介绍如何存取神经网络。 Super Resolution: 使用神经网络进行图像像素插值。 Sparse Coding: 使用线性的词典学习(dictionary learning)来进行图像像素插值。 Generitive Model: 使用时兴的生成模型(Generitive Model)来完成图像风格的转换。 原生的数据管理 : 从这一章开始，我们将纳入Tensorflow自带的数据管理API。实际上，很多用户并不习惯使用这些API，往往倾向于自己完成数据的导入导出。虽然这并非一个复杂的工作，但据Tensorflow的文档，原生的数据管理内部实现了多线程，本身更适合用于提高数据IO的效率。读者可以酌情选择是否需要阅读本章。 使用MINIST数据集: 使用原生的数据管理来IO一个现成的MINIST数据集，这一节改自 官方文档教程 。 使用RNN处理文章: 通过LSTM模型来进行文本分类，并使用原生的数据管理来IO一个现成的IMDB数据集，这一节改自 官方文档教程 。 使用RBM生成音频: 通过限制玻尔兹曼机(RBM)来编写一个简单的音乐生成器，这一节改自 llSourcell/Music_Generator_Demo 。 其他的高级技巧 : 本章将介绍一些特殊的、利用底层API技巧，使得用户能更灵活地定制Tensorflow-keras，从而实现一些仅依靠原生库不能实现的功能。","text_tokens":["机","看","怎样","让","加减乘除","迟早会","虽然","不错","创建","完全","标准","做到","不妨","检查","大体","神经网","生产","单元","无可奈何","eager","/","即使","总是","对应","可","官方","ionets","值得","50049041","灵活","足取","人","结构","教程","自","团队","world","工程","隶属","领域","fill","所","3","generitive","原","提供","而言","自行","地","贴合","来说","并","手动","9","导读","生成器","处理","分布","但据","边缘","培养","当然","已","iodat","来看","执行","事实","借助","简述","12","除外","medium","规范化","layers","故而","重中之重","版本","使得","大略","（","不合","过于","cde498","rnn","换成","仅","不得不","存在","义好","写","情况","变量","迅速","这方","跟着","相比","手","全部","导出","测试","会因","治学","它","不","一方面","保证","不断","相同","人员","分立","时兴","参数","sesscl","更新","均","也许","翔实","稳定","事实上","规模","whats","内容","搜索","导向","sess","注意","2019","研究","阶段","撰写","可能性","技术","stroke","去","跟踪","属于","他人","看成","times","解决","拟合","java","a0ca48767aff","optimizer","内部","和","python","实现","我们","jin","才","多个","性能","自学","至少","经常","关键词","学者","一般而言","涉及","利用","长期","各种","ai","流图","™","基于","www","英文","环节","并不需要","与","#","三个","ba9132","即","每","之故","外围","典型","纳入","预定","文章","一点","文本","代码","玻尔","追求","模块","不合宜","要","fae6a9","关键","集中","看作","正在","完整","开发","设备","固然","输入输出","隶属于","\\","局限","桌面","各个","共","功能性","似乎","由","表达式",";","依赖于","服务","需要","节点","如意","带来","resolution","围绕","很","分发","对照","这","tensorflow","先",",","管理","9.0","插值","=","深度","此时","最初","中层","尽管","一系","加减","llsourcell","；","依靠","年","技巧","集成","构建","彼时","一般","加入","用于","demo","快速","架构","了","展开","系列","再用","很多","重新","摘要","来","下图","当","那么","iores","兹曼","如果","分类","总说","另一方面","索引","tensorboard","心思","contrib","当前","明显","用法","model","按照","不再","针对","毕竟","项目","一章","语言","部门","帮助","不足取","会话","指定","形式","com","音乐","以","回归","敝","方法","best","分为","神经网络","未来","super","特殊","dataflow","project","都","节省",")","属性","一套","本页","符号","转换","对本","应当","服务器","计算","导致","接触","给","部分","功能","成器","轻松","yuchen","派生","本章","值得注意","这里","提到","必要","并非","https","并且","effective","将","习惯","从而","底层","高性","[","问题","集群","p","仍","同样","变化","张量","除了","侧重","建立","过时","ionet","二","google","接下","zhihu","检索","内","一部","org","莫过","]","相当于","function","定制","是否","1","有着","estimators","所有","low","亦复如是","源代码","音频","改进","保存","如是","readthedocs","从这一点","是从","只","更","最大","然后","提示","奈何","可用","带宽","适合","得到","loss","不足","编写程序","一定","转变","数据","进行","部署","td","接口","一个","选择","classdef","mid","彻底","subgraph","分类器","完成","转换成","务器","遗漏","运行","之中","由于","义","封装","关闭","介绍","乘除","新版","也","朝向","起","风格","javascript","包括","库","本原","高级","网络单元","多","官网","蒐集","初学者",">","成规","命名","网络","r1","即将","在","难免","以及","搜","以为","流程","表达","会","中文","日新月异","keras","思路","操作","扉页","如何","多核","被","调试","不会","月","通过","构造函数","存取","api","对于","所谓","训练","and","下来","达式","run","减少","强力","一系列","新","高性能","尽可","stystart","其他","一张","时时","支持","可能","coding","x","基本","st","go","网络层","ed","需求","最新消息",".","”","满足","入门教程","加载","直接","模式","尽可能","集合","废案","参照","高层","程序员","分开","changed"," ","当于","开放","跟进","原理","中文搜索","¶","划分","效率","于","地方","如同","改","无可","读者","2.0","则","线性","更大","手札","）","为止","但本","工作","session","brain","专题","日","成","上","迟早","特定","、","许多","这个","关心","研究者","进入","顺序","仍然","时间","模型","dictionary","2","能圆转","结果","一方","用户","lstm","构设","器","gpu","须知","时","上述","移动","广泛应用","译者","金宇琛","完善","end","运算","本人","搭建","显示","保留","generator","流","是","但","乃是","有如","看来","13540c","组织","表示","专门","execution","范化","像","imdb","好","某些","之前","工程师","来自","优化","一节","根据","小规模","结束","图","已知","然而","开始","倾向","原生","事","基本原理","总纲","hello","0","偏门","倘若","起来","上面","得","重于","前面","逐步","_","消息","着","就","变成","集","cainmagi","例如","像素","，","资源","之间","走入","系统","实际","相当","依赖","合宜","如此","数据管理","一样","但是","确实","设计","线程","错过","多线","亦可","抛弃","初学","没有","立时","车间","graph","词典","自带","level","可谓","(","第一","文档","往往","调用","维护","机器语言","数据流","@","具体","两步","必须","若","z","有","c++","调整","入","mar","广泛","重复","y","偏向","非线性","推崇","现在","核","不学","提高","high","相似","或许","不断更新","接下来","可以","指","不得","一种","除非","特别","github","流程图","读取","限制","确保","方面","接受","出错","以下","所写","发现","赖于","本","tensor","cpu","过程","卷积","侧重于","神经","实际上","处于","解析","zh","最新","+","将会","懒惰","打开","角度","而","大不相同","摈弃","为","核心","加快","使用","多种","这方面","试图","花费","目前","机器","对","倍加","4","还","科学","面向","minist","-","不同","相对","代替","整个","虚拟机","一","计算资源","资料","写下","又","工人","基础","出","过去","具有","新月","多线程","办法","移除","方便","至今","等","商品","之流","中","希望","metrics","无法","玻尔兹曼","墨守成规","practices","程序","输出","learning","才能","styio","名称","从","任何","莫大","输入","同时","第一个",":","connet","一些","页面","找到","另","层次","：","请","music","datasets","简单","双语","的","读","特性","例子","量会","class","def","既","这种","numpy","速度","本身","不断改进","即可","更加","应用","启动","学习","。","过渡","讨论","少于","编写","逻辑","测量","用来","其","tpu","sparse","反响","版","酌情","墨守成","手记","定义","平台","据","一步","另一方","tf","构造","复杂","之","某个","虚拟","几个","四处","哪些","阅读","批量","rbm","式","莫过于","学","久","墨守","zhuanlan","难免会","写给","研读","们","这样","认识","因此","兼容","已经","现成","软件","所弃","驱使","不可","数学","前瞻","io","主要","导入","construct","生成","写成","守成","这些","所述","数值","结构设计","能","时候","重要","下","不能","构成","到","分词","不高","自己","英双语","图像","笔者","规范","上线","入门","函数","一部分","里","几乎","程度","方式","“"],"title":"扉页","title_tokens":["扉页"]},{"location":"#_1","text":"摘要 Tensorflow总纲，写给初学者们。本页面将简述Tensorflow的基本原理，结构设计以及版本更新。读者亦可在本页找到本教程将提供给读者对Tensorflow怎样的认识。 注意 由于技术限制，现在中文搜索功能无法完善，请注意当搜索关键词的时候自行分词，例如： 开放源代码软件库 无法搜到任何内容。但可以搜索 开放 源代码 软件 库 即可确保索引到上述内容。","text_tokens":["上述","现在","更新","怎样","的","完善","例如","代码","内容","搜索","，"," ","写给","注意","们","关键","认识","原理","提供","中文搜索","简述","本页","开放","软件","但","由于","技术","读者","给","限制","设计","中文","摘要","即可","确保","当","版本","。","亦可","结构设计","初学","功能","时候","本","关键词","学者","库","本原","无法","源代码","索引","到","分词","基本原理","初学者","总纲","结构","教程","基本","任何","在","以及","搜","可以","将","tensorflow","页面","对","找到","构设","自行","：","请"],"title":"扉页","title_tokens":["扉页"]},{"location":"#tensorflow","text":"Tensorflow官网 TensorFlow™ 是一个开放源代码软件库，用于进行高性能数值计算。借助其灵活的架构，用户可以轻松地将计算工作部署到多种平台（CPU、GPU、TPU）和设备（桌面设备、服务器集群、移动设备、边缘设备等）。TensorFlow™ 最初是由 Google Brain 团队（隶属于 Google 的 AI 部门）中的研究人员和工程师开发的，可为机器学习和深度学习提供强力支持，并且其灵活的数值计算核心广泛应用于许多其他科学领域。","text_tokens":["深度","最初","可以","用于","架构","强力","高性能","cpu","可","其他","灵活","为","支持","核心","团队","多种","部门","工程","隶属","领域","机器","提供","地","科学","边缘"," ","开放","借助","于","服务器","计算","）","等","（","工作","brain","轻松","中","、","许多","并且","将","用户","高性","人员","gpu","集群","移动","广泛应用","的","google","研究","是","属于","应用","学习","工程师","。","和","性能","源代码","其","tpu","ai","™","平台","进行","部署","一个","代码","，","务器","开发","软件","设备","隶属于","桌面","数值","由","库","服务","到","官网","tensorflow","广泛"],"title":"Tensorflow总说","title_tokens":["tensorflow","总说"]},{"location":"#tensorflow_1","text":"写在所有内容之前，读者不得不看以下几个页面，本教程所述内容大略来自于对这些资料的研读。 Tensorflow官网(中/英文) : https://www.tensorflow.org/ Keras中文文档 : https://keras-zh.readthedocs.io/ Tensorflow 2.0前瞻(英文) : https://medium.com/tensorflow/effective-tensorflow-2-0-best-practices-and-whats-changed-a0ca48767aff Tensorflow 2.0前瞻(中文) : https://zhuanlan.zhihu.com/p/50049041 提示 特别值得注意的是，现在官方文档至少在教程部分， 已经支持中英双语 。相比官方文档，我们的教程更侧重于以搭建工程为导向的设计。然而现在官方文档的翔实可读程度，确实不可错过。另一方面，Keras的 官方中文文档 似乎已不再更新，上面提供的原官方中文文档译者现在正在更新、维护的版本。 大略来说，学习Tensorflow主要应当依赖于官方文档的介绍。敝人自r1.4版开始入门Tensorflow，即是通过学习官方文档的教程来快速上手。相比四处蒐集资料，官方文档能提供一个完整、系统、完全贴合时下最新API的例子，帮助用户建立一个与Tensorflow各个功能合宜的使用习惯。若是通过在Github上检索他人的project，固然是一个很好的上手办法，但是往往就会遗漏某些重要的功能而不学。例如，Tensorflow自带的网络存取和Tensorboard API，在时兴的一些project中，经常会因方便之故，以numpy的IO来代替。笔者以为，如此培养起来的使用习惯，可谓走入偏门。当然，从这一点来说，本教程也亦复如是，即使笔者写下这些内容的时候，参照的乃是时下最新的API，时间一久，难免会过时。倘若笔者懒惰一些，不再时时更新本教程，那么本教程也就入不足取之流了。 虽然如此，教程也有并不合宜的地方。最大的问题莫过于Tensorflow本身，它有着日新月异的变化，此时能圆转如意地使用的API，到了彼时也许就成了废案。这就导致Tensorflow的官方教程也不断更新。r1.4时，教程还主要集中在如何使用“底层”API上，到了r1.9.0，就已经变成基本围绕着 tf.keras 设计的思路了。最新消息显示，即将上线的Tensorflow 2.0，将会彻底抛弃过去的“中层”API以下的全部方法， tf.layers , tf.contrib 都将被移除，倘若长期墨守成规，局限在入门时候的一套技术上，迟早会被官方库如此迅速的更新所弃。这也是无可奈何之事。毕竟Tensorflow仍然处于不断改进之中。倘若希望追求一个更加稳定、长期可用的库，keras或许是一个不错的选择。 故而，本教程将基本基于Tensorflow现在的版本(r1.12)展开介绍。本教程既可以看作一个入门教程，也可以看作是本人重新自学新版Tensorflow规范化API的一个手记，故而命名本教程为“手札”。读者不妨跟着笔者的思路，有如与笔者共学一般读下来本教程。","text_tokens":["看","迟早会","虽然","不错","完全","不妨","无可奈何","/","即使","可","官方","值得","50049041","足取","人","教程","自","工程","原","提供","地","贴合","来说","并","培养","当然","已","12","medium","规范化","layers","故而","版本","大略","过于","不合","不得不","写","迅速","跟着","相比","手","全部","会因","它","一方面","不断","时兴","更新","也许","翔实","稳定","whats","内容","导向","注意","技术","他人","a0ca48767aff","和","我们","自学","至少","经常","长期","基于","www","英文","与","即","之故","一点","追求","不合宜","集中","看作","正在","完整","固然","局限","各个","共","似乎","依赖于","如意","围绕","很","这","tensorflow",",","9.0","此时","中层","彼时","一般","快速","了","展开","重新","来","那么","另一方面","tensorboard","contrib","不再","毕竟","帮助","不足取","com","以","敝","方法","best","project","都",")","一套","应当","导致","部分","功能","值得注意","https","effective","将","习惯","底层","问题","p","变化","侧重","建立","过时","zhihu","检索","org","莫过","有着","所有","亦复如是","改进","如是","readthedocs","从这一点","更","最大","提示","奈何","可用","不足","一个","选择","彻底","遗漏","之中","介绍","新版","也","库","官网","蒐集","成规","命名","网络","r1","即将","在","难免","以为","会","中文","思路","日新月异","keras","如何","被","通过","存取","api","and","下来","时时","支持","基本","最新消息",".","”","入门教程","废案","参照","changed"," ","于","地方","无可","读者","2.0","手札","成","上","迟早","、","仍然","时间","2","能圆转","一方","用户","时","译者","本人","搭建","显示","是","乃是","有如","范化","好","某些","之前","来自","然而","开始","事","0","偏门","倘若","起来","上面","重于","消息","着","就","变成","例如","，","走入","系统","依赖","合宜","如此","但是","确实","设计","错过","抛弃","自带","可谓","(","文档","往往","维护","若","有","入","现在","不学","或许","不断更新","可以","不得","特别","github","方面","以下","赖于","本","侧重于","处于","zh","最新","将会","懒惰","而","为","使用","对","4","还","-","代替","一","资料","写下","过去","新月","办法","移除","方便","之流","中","希望","墨守成规","practices",":","一些","页面","双语","的","读","例子","既","numpy","本身","不断改进","更加","学习","。","版","墨守成","手记","另一方","tf","之","几个","四处","莫过于","学","久","墨守","zhuanlan","难免会","研读","已经","所弃","不可","前瞻","io","主要","守成","这些","所述","能","时候","重要","下","到","英双语","笔者","规范","上线","入门","程度","“"],"title":"Tensorflow治学","title_tokens":["tensorflow","治学"]},{"location":"#tensorflow_2","text":"一个标准的Tensorflow工作流可以表示成这样： graph TD st(开始) --> Sess[启动Session] Sess --> ConNet[构建网络] subgraph 构造流程 ioNet>读取网络参数] --> ConNet end subgraph 执行流程 ioDat>导入数据] --> Run ConNet --> Run[执行网络] Run --> ioNetS>保存网络参数] Run --> ioRes>导出结果] end ioRes --> SessCl[关闭Session] SessCl --> ed(结束) classDef styStart fill:#FAE6A9,stroke:#BA9132; classDef styIO fill:#cde498,stroke:#13540c; class st,ed styStart class ioNet,ioNetS,ioDat,ioRes styIO 与一般的计算库不同，Tensorflow的执行流程大体可以分为两步： 构造流程 : 在这一步，Tensorflow根据用户代码构造一个 数据流图(dataflow graph) 。所谓数据流图，指的是由一系列 张量(Tensor) 构成的符号运算集合。就如同一张流程图一样，在这一阶段，尽管用户定义了每一步的运算（从简单的加减乘除到复杂的网络单元），但是没有任何运算被执行。就像一个程序员撰写代码一样，Tensorflow在这一步，将用户的代码转换成它的“机器语言”，但是网络还没有进入被使用的阶段。 执行流程 : 在这一步，Tensorflow将计算用户指定的某个 Tensor 的输出结果。要得到一个Tensor的输出，则必须得计算它一系列的依赖变量。例如，我们已知 y = x_1 + x_2 y = x_1 + x_2 , x_2 = z_1 \\times z_2 x_2 = z_1 \\times z_2 。那么，如果Tensorflow要得到 y y 的结果，它就必须先计算 x_2 x_2 。这个过程被完全地封装起来，从用户看来，我们只需要调用 y y 的输出即可，不需要关心Tensorflow是怎样按照流图完成计算的。 因此，典型的Tensorflow式的语言风格也可以这样划分： 构造流程 : 用户定义整个网络的符号运算，指定网络各个节点的属性、输入和输出。这些代码往往被写成一个函数（例如 def construct (): ） 执行流程 : 创建一个Session，在Session内调用构造函数，然后输入数据，得到并保存输出结果。必要情况下，还需要导入导出网络参数。 这里提到 会话(Session) 。Session如同一个Tensorflow虚拟机，在一个Session打开的时候，设备的计算资源（GPU, CPU, 带宽等）才被加载。Session又如同一个工人，用户撰写的网络构造代码如同车间，输入的数据如同商品，“工人（Session）”利用预定义好的“车间（流图）”将可以快速、批量地生产这些“商品（数据）”。这样地设计保证了一些外围的代码，例如指定网络参数的名称、函数的属性等操作，不需要重复进行，从而确保处理数据的时候，总是执行必要的代码，加快运算速度。 另一方面，构造-执行的结构还封装了许多提高运算效率的特性，例如多线程。尽管用户定义网络构造的时候，所写的代码是按照逻辑顺序的、线性的。但实际运行的时候，Tensorflow可以自行发现网络的哪些部分可以被同时运行，从而利用多核系统的计算资源。这些过程也是被完全封装起来的，用户并不需要花费心思去专门进行这些调整。 须知 在Tensorflow已经转变为Keras导向的现在，Session的调用被Keras API封装了起来，从用户的角度来看，现在已经不再需要手动调用Session。","text_tokens":["y","=","多核","现在","被","尽管","加减乘除","怎样","提高","一系","加减","创建","可以","完全","构造函数","标准","api","构建","所谓","一般","指","系列","大体","流程图","了","快速","读取","生产","单元","方面","run","确保","那么","所写","iores","一系列","发现","如果","tensor","过程","总是","cpu","另一方面","stystart","ionets","心思","一张","+","角度","打开","为","结构","按照","x","st","加快","不再","使用","语言","花费","fill","ed","会话","指定","机器","”","地","自行","分为","并","许多","手动","还","加载","集合","dataflow","处理","程序员","来看","-","iodat"," ",")","不同","执行","属性","划分","符号","整个","一","如同","转换","虚拟机","计算资源","又","工人","计算","则","线性","多线程","）","cde498","（","工作","session","等","商品","部分","换成","成","程序","、","这里","这个","必要","关心","提到","义好","进入","变量","情况","输出","顺序","styio","名称","从","2","任何","输入","结果","导出","同时",":","connet","一方","将","它","不","一些","保证","用户","从而","一方面","[","：","gpu","须知","效率","参数","sesscl","张量","简单","end","的","特性","运算","sess","导向","ionet","class","def","流","阶段","内","撰写","是","看来","速度","]","但","13540c","stroke","表示","去","专门","像","1","即可","times","启动","。","和","我们","根据","才","结束","图","已知","开始","逻辑","利用","保存","流图","定义","只","然后","一步","构造","另一方","复杂","带宽","某个","虚拟","并不需要","与","得到","#","起来","哪些","ba9132","得","转变","数据","批量","每","_","式","外围","典型","td","就","进行","预定","例如","一个","classdef","代码","，","fae6a9","这样","要","subgraph","因此","完成","转换成","资源","系统","已经","设备","实际","运行","依赖","一样","但是","封装","\\","导入","关闭","construct","设计","线程","写成","这些","各个","乘除","多线","也","由","没有","时候","风格","车间","graph",";","下","库","构成","需要","网络单元","到","节点","(","调用","往往",">","机器语言","数据流","网络","两步","在","必须","这","z","函数","流程","tensorflow","先",",","调整","keras","“","操作","重复"],"title":"Tensorflow原理","title_tokens":["tensorflow","原理"]},{"location":"#tensorflow-api","text":"下图显示了当前Tensorflow-API的组织形式 Tensorflow在多个平台上均有部署，包括Python, C++, Java, Javascript, Go等，未来还可能支持更多的语言。然而，不同平台上，API的使用方式和代码风格是大不相同的。例如，Python的语言风格目前已经朝向Keras转变，而Javascript仍倾向于使用中层API；C++和Java偏向于使用底层API编写程序。本教程只针对时兴Python的API编写，除非涉及到特定的专题，不会讨论其他语言上Tensorflow的用法。 一般而言，Tensorflow将API面向划分为三个层次： 高层API (High level) : 包括Estimators和Keras； 中层API (Mid level) : 包括layers, datasets, loss和metrics等具有功能性的函数，例如网络层的定义，Loss Function，对结果的测量函数等； 底层API (Low level) : 包括具体的加减乘除、具有解析式的数学函数、卷积、对Tensor属性的测量等。 从r1.4入门的用户，所接受的训练往往是从底层API开始，使用自己的代码风格构建对应中层API的函数，然后再用自己定义好的中层API构建网络。在这种代码风格的驱使下，用户除了需要定义各个网络层具体的表达式，还需要设计输入输出的接口，用来调用 优化器(optimizer) 的接口等操作。 另一种使用方式，是从中层API开始，直接使用预定义好的网络层构建网络，这样的代码风格会节省一部分时间，相当于几乎不再需要接触底层API，但是在输入输出、网络训练和测试等更高层的模块设计上，和底层API用户的代码风格相似。 Estimators是从r1.4就已经存在的API了，它可以被看成是已经集成在Tensorflow里的完整的网络。因此，Estimators往往适合分发、需求不高的应用，但是并不适合使用Tensorflow的研究者。尽管至今为止，Tensorflow仍然对Estimators倍加推崇，但本教程将完全不涉及这方面的内容。 另一个高层API是 Eager Execution ，从r1.9起，Tensorflow就加入了这种新的使用模式，并且在Tensorflow 2.0中，它仍然将会被保留。Eager摈弃了上述的构造-执行流程，任何对Tensor的定义会被立时计算、并可得到结果。对于需要进行小规模的调试、检查API功能的用户而言更加方便。但是，据一些用户的反响，现在Eager还没有做到和之前API的完全兼容，本教程将基本不涉及Eager的用法。 因此，Keras API将是本教程的重中之重。使用本教程的用户，可以对照目前的官方文档，跟进本教程的思路，自己逐步实现各个project的设计。使用Keras风格的设计，代码量会明显少于前面提到的各种风格（Estimators除外）。事实上， tf.keras 和底层API之间具有一定的兼容，这样的编写风格能让我们在满足自己设计的派生功能的基础上，尽可能使用规范化、预定义的API单元，从而减少代码出错的可能性。通过对本教程TF 1.x版的学习，对未来2.0版的上手也会带来莫大帮助。 金宇琛( @cainmagi )，2019年3月2日 Yuchen Jin( @cainmagi ), Mar. 2, 2019","text_tokens":["让","加减乘除","完全","做到","检查","单元","eager","对应","可","官方","教程","3","所","而言","并","9","执行","事实","除外","规范化","layers","重中之重","（","存在","义好","这方","手","测试","它","不","相同","时兴","均","事实上","规模","内容","2019","研究","可能性","看成","java","optimizer","python","和","实现","我们","jin","一般而言","多个","节省","涉及","各种","三个","预定","代码","模块","完整","输入输出","各个","功能性","表达式","需要","带来","分发","对照","tensorflow",",","中层","尽管","加减","；","年","集成","构建","加入","一般","了","再用","下图","当前","明显","用法","针对","不再","语言","帮助","形式","未来","project",")","属性","对本","接触","计算","部分","功能","yuchen","派生","提到","并且","将","从而","底层","仍","除了","一部","相当于","function","1","estimators","low","是从","只","更","然后","适合","得到","loss","编写程序","一定","转变","进行","部署","接口","一个","mid","义","乘除","也","朝向","起","风格","javascript","包括","多","网络","r1","在","表达","流程","会","思路","keras","操作","被","调试","不会","月","通过","api","对于","训练","达式","减少","新","尽可","其他","支持","可能","x","基本","go","网络层","需求",".","满足","直接","模式","尽可能","高层"," ","当于","跟进","划分","于","2.0","）","为止","但本","专题","日","上","特定","、","研究者","仍然","时间","2","结果","用户","器","金宇琛","上述","显示","保留","是","组织","execution","范化","好","之前","优化","小规模","然而","倾向","开始","前面","逐步","就","cainmagi","例如","，","之间","相当","但是","设计","没有","立时","level","(","往往","调用","文档","@","具体","有","c++","mar","偏向","推崇","现在","high","相似","可以","一种","除非","接受","方面","出错","tensor","本","卷积","解析","将会","摈弃","大不相同","而","为","使用","这方面","目前","倍加","对","4","还","面向","-","不同","基础","具有","方便","至今","等","中","metrics","程序","输出","从","任何","莫大","输入",":","一些","另","层次","：","datasets","的","量会","这种","更加","应用","学习","。","讨论","少于","编写","测量","用来","反响","版","定义","平台","据","构造","tf","式","这样","因此","兼容","已经","驱使","数学","能","下","到","不高","自己","规范","入门","函数","一部分","里","几乎","方式"],"title":"Tensorflow API架构","title_tokens":["tensorflow","架构"," ","api"]},{"location":"#_2","text":"接下来，本教程将会涉及 从线性问题入门 : 如何使用Tensorflow完成一个简单的线性分类设计，我们将从Hello World开始，逐步过渡到一个具有核函数的非线性问题project。 Hello world: 第一个Tensorflow程序。 线性分类: 一个简单的二分类问题。 线性回归: 一个同样简单的，线性拟合问题。 非线性回归: 拟合一个简单的，可以表达出解析式的非线性函数。 非线性分类: 使用线性分类器对非线性分布的数据进行分类。 训练与测试分立 : 从这一章开始，并试图解决几个更加复杂的实际问题。这里涉及到的project相对更大、更完整，训练往往需要一定时间才能完成。因此，在本章，所有项目的训练、测试环节都会分开，我们将从这里开始，使用TensorBoard跟踪我们的训练情况，并介绍如何存取神经网络。 Super Resolution: 使用神经网络进行图像像素插值。 Sparse Coding: 使用线性的词典学习(dictionary learning)来进行图像像素插值。 Generitive Model: 使用时兴的生成模型(Generitive Model)来完成图像风格的转换。 原生的数据管理 : 从这一章开始，我们将纳入Tensorflow自带的数据管理API。实际上，很多用户并不习惯使用这些API，往往倾向于自己完成数据的导入导出。虽然这并非一个复杂的工作，但据Tensorflow的文档，原生的数据管理内部实现了多线程，本身更适合用于提高数据IO的效率。读者可以酌情选择是否需要阅读本章。 使用MINIST数据集: 使用原生的数据管理来IO一个现成的MINIST数据集，这一节改自 官方文档教程 。 使用RNN处理文章: 通过LSTM模型来进行文本分类，并使用原生的数据管理来IO一个现成的IMDB数据集，这一节改自 官方文档教程 。 使用RBM生成音频: 通过限制玻尔兹曼机(RBM)来编写一个简单的音乐生成器，这一节改自 llSourcell/Music_Generator_Demo 。 其他的高级技巧 : 本章将介绍一些特殊的、利用底层API技巧，使得用户能更灵活地定制Tensorflow-keras，从而实现一些仅依靠原生库不能实现的功能。","text_tokens":["非线性","如何","机","核","提高","虽然","接下来","通过","llsourcell","可以","依靠","存取","技巧","api","训练","用于","demo","了","神经网","下来","很多","限制","来","/","兹曼","本","分类","神经","实际上","tensorboard","官方","其他","解析","将会","灵活","model","coding","教程","自","使用","一章","试图","项目","world","对","generitive","地","音乐","回归","神经网络","并","super","特殊","minist","生成器","处理","分布","但据","project","分开","都","-"," ",")","相对","改","效率","于","转换","出","具有","线性","读者","多线程","更大","使得","工作","成器","功能","rnn","仅","玻尔兹曼","本章","程序","这里","、","情况","learning","才能","时间","模型","并非","从","dictionary","第一个","导出",":","测试","将","一些","不","习惯","分立","用户","lstm","底层","从而","问题","同样","music","时兴","简单","的","二","接下","generator","imdb","本身","定制","跟踪","是否","更加","解决","内部","拟合","学习","。","过渡","实现","我们","所有","一节","酌情","编写","涉及","开始","原生","倾向","音频","sparse","利用","更","复杂","环节","hello","适合","与","几个","阅读","一定","数据","逐步","rbm","式","_","进行","纳入","集","文章","一个","像素","选择","文本","玻尔","，","因此","分类器","完成","完整","现成","实际","数据管理","io","导入","设计","生成","线程","这些","介绍","多线","能","风格","词典","不能","自带","库","高级","需要","到","resolution","(","第一","自己","往往","文档","图像","网络","入门","在","这","函数","表达","tensorflow","会","管理","keras","插值"],"title":"教程导读","title_tokens":["教程","导读"]},{"location":"licenses/","text":"协议 (Licenses) ¶ 本站协议 (中文版) ¶ MIT 开源许可协议 版权所有 © 2019, 金宇琛 (cainmagi) 特此向任何得到本软件副本或相关文档的人授权：被授权人有权使用、复制、修改、 合并、出版、发布、散布、再授权和/或贩售软件及软件的副本，及授予被供应人 同等权利，只需服从以下义务： 在软件和软件的所有副本中都必须包含以上版权声明和本许可声明。 该软件是\"按原样\"提供的，没有任何形式的明示或暗示，包括但不限于为特定目的和 不侵权的适销性和适用性的保证担保。在任何情况下，作者或版权持有人，都无权要求 任何索赔，或有关损害赔偿的其他责任。无论在本软件的使用上或其他买卖交易中， 是否涉及合同，侵权或其他行为。 License of this website (English version) ¶ MIT License Copyright © 2019 Yuchen Jin (cainmagi) Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 本站相关项目的协议 ¶ 下面介绍的诸多协议，原则上并无必要列在本条目中（例如MIT License）。列在下侧，主要是为了向诸位支持本文档的开发者致以真诚的谢意。亦将荣耀与在下的感谢致以高天之上的上帝，愿你保守这份文档，成为众人的帮助。 License of Material ¶ MIT License Copyright © 2016 - 2019 Martin Donath Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. License of MkDocs ¶ BSD 2-Clause \"Simplified\" License Copyright © 2014, Tom Christie. All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. License of Jieba3K ¶ The MIT License (MIT) Copyright © 2013 Sun Junyi Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. License of Simple Lightbox ¶ The MIT License (MIT) Copyright © 2018 Damir Brekalo Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. License of MathJax ¶ Apache License 2.0 See the full license here: MathJax license License of mermaid ¶ The MIT License (MIT) Copyright © 2014 - 2018 Knut Sveidqvist Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","text_tokens":["data","开源","permitted","junyi","下面","christie","/","noninfringement","distribution","人","要求","提供","a","有关","并","谢意","性","for","你","see","（","notice","合并","无","mathjax","情况","strict","作者","散布","authors","shall","不","otherwise","保证","向","from","license","2019","荣耀","incidental","和","jin","all","2018","按","if","为了","涉及","无权","上帝","众人","free","particular","met","与","profits","2016","有权","合同","原样","code","indirect","in","开发","implied","列在",";","possibility","materials","复制","negligence",",","许可","business","损害赔偿","reproduce","lightbox","that","fitness","成为","charge","rights","保守","contributors","portions","redistributions","subject","mkdocs","mermaid","copies","to","项目","帮助","the","damage","愿","形式","even","都",")","再","provided","感谢","action","disclaimer","出版","授权","适销","yuchen","修改","必要","be","将","however","knut","liable","whom","原则上","损害","是否","merchantability","do","所有","without","event","副本","granted","an","诸多","只","english","damir","之上","下侧","\"","得到","or","loss","高天","sun","tom","侵权","授予","dealings","限于","binary","by","software","介绍","whether","包括","2013","following","advised","在","infringement","apache","goods","中文","适用性","of","deal","被","on","exemplary","and","这份","sveidqvist","copy","其他","not","致以","及","支持","permit","brekalo",".","warranties","modify","需","liability","arising"," ","services","so","¶","no","2.0","version","connection","协议","）","material","donath","上","tort","特定","、","included","person","2","interruption","substantial","交易","版权所有","金宇琛","retain","full","warranty","文版","同等","sublicense","是","但","obtaining","特此","原则","with","form","this","适用","目的","holders","modification","way","cainmagi","持有人","limited","例如","©","jieba3k","，","use","here","such","赔偿","website","持有","direct","special","没有","redistribution","clause","(","文档","索赔","版权","copyright","必须","express","restriction","暗示","as","本站","mit","licenses","purpose","或","该软件","以上","买卖","documentation","hereby","列","供应","以下","merge","权利","substitute","本","服从","limitation","义务","martin","为","persons","中文版","使用","包含","holder","担保","行为","sell","reserved","damages","2014","-","贩售","相关","发布","other","consequential","including","above","caused","procurement","claim","声明","中","distribute","明示","must","conditions","list","任何","真诚",":","is","：","disclaimed","的","责任","条目","are","simple","。","开发者","kind","non","source","any","furnished","contract","associated","simplified","诸位","out","permission","无论","publish","theory","软件","主要","授权人","下","亦","有人","bsd","files","but","forms"],"title":"协议","title_tokens":["协议"]},{"location":"licenses/#licenses","text":"","text_tokens":[],"title":"协议 (Licenses)","title_tokens":["licenses","(",")"," ","协议"]},{"location":"licenses/#_1","text":"MIT 开源许可协议 版权所有 © 2019, 金宇琛 (cainmagi) 特此向任何得到本软件副本或相关文档的人授权：被授权人有权使用、复制、修改、 合并、出版、发布、散布、再授权和/或贩售软件及软件的副本，及授予被供应人 同等权利，只需服从以下义务： 在软件和软件的所有副本中都必须包含以上版权声明和本许可声明。 该软件是\"按原样\"提供的，没有任何形式的明示或暗示，包括但不限于为特定目的和 不侵权的适销性和适用性的保证担保。在任何情况下，作者或版权持有人，都无权要求 任何索赔，或有关损害赔偿的其他责任。无论在本软件的使用上或其他买卖交易中， 是否涉及合同，侵权或其他行为。","text_tokens":["开源","mit","损害赔偿","被","或","该软件","以上","买卖","供应","以下","/","权利","本","服从","义务","其他","及","为","人","使用","包含","担保","要求","形式","提供","行为","需","有关","贩售","相关"," ",")","都","发布","性","再","协议","出版","合并","授权","适销","声明","中","上","明示","、","特定","修改","情况","作者","任何","散布","不","保证","向","：","交易","版权所有","金宇琛","的","责任","2019","同等","损害","是","但","是否","特此","。","和","所有","按","副本","涉及","无权","只","适用","目的","\"","得到","有权","合同","原样","cainmagi","持有人","侵权","©","授予","，","无论","软件","限于","赔偿","持有","没有","授权人","包括","下","(","有人","文档","索赔","版权","复制","在","必须",",","许可","暗示","适用性"],"title":"本站协议 (中文版)","title_tokens":["中文版","本站","文版","("," ","中文","协议",")"]},{"location":"licenses/#license-of-this-website-english-version","text":"MIT License Copyright © 2019 Yuchen Jin (cainmagi) Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","text_tokens":["of","deal","as","mit","purpose","fitness","documentation","hereby","and","charge","/","rights","merge","noninfringement","portions","subject","limitation","copy","not","copies","to","permit","persons","the",".","warranties","a","modify","sell","damages","liability","arising"," ",")","so","for","no","other","provided","action","including","connection","above","notice","claim","yuchen","distribute","tort","included","conditions","person","be","substantial",":","is","authors","shall","otherwise","liable","from","whom","license","warranty","2019","sublicense","obtaining","merchantability","jin","without","do","all","with","event","kind","granted","this","an","any","furnished","contract","free","particular","associated","\"","or","holders","out","permission","cainmagi","limited","©","use","in","publish","dealings","software","implied","whether","(","following","copyright","express","restriction","files","but",","],"title":"License of this website (English version)","title_tokens":["of","english","website","this","license","version","("," ",")"]},{"location":"licenses/#_2","text":"下面介绍的诸多协议，原则上并无必要列在本条目中（例如MIT License）。列在下侧，主要是为了向诸位支持本文档的开发者致以真诚的谢意。亦将荣耀与在下的感谢致以高天之上的上帝，愿你保守这份文档，成为众人的帮助。","text_tokens":["并","原则上","mit","的","例如","license","，"," ","谢意","条目","荣耀","开发","是","主要","感谢","成为","这份","列","你","下面","协议","介绍","。","）","开发者","列在","（","保守","原则","本","为了","无","中","下","致以","亦","必要","文档","诸多","支持","上帝","众人","在","之上","下侧","真诚","帮助","将","与","愿","高天","向","诸位"],"title":"本站相关项目的协议","title_tokens":["项目","本站","的","相关","协议"]},{"location":"licenses/#license-of-material","text":"MIT License Copyright © 2016 - 2019 Martin Donath Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","text_tokens":["of","deal","as","mit","purpose","fitness","documentation","hereby","and","charge","/","rights","merge","portions","subject","limitation","copy","not","martin","copies","to","permit","persons","the",".","warranties","a","modify","sell","damages","liability","-","arising"," ",")","so","for","no","other","provided","action","including","connection","above","notice","claim","donath","distribute","tort","included","conditions","person","be","substantial",":","is","authors","shall","otherwise","liable","from","whom","license","warranty","2019","sublicense","obtaining","merchantability","do","without","all","with","event","kind","granted","non","this","an","any","furnished","contract","free","particular","associated","\"","or","2016","holders","out","permission","limited","©","use","in","publish","dealings","software","implied","whether","(","following","copyright","express","infringement","restriction","files","but",","],"title":"License of Material","title_tokens":["material","of"," ","license"]},{"location":"licenses/#license-of-mkdocs","text":"BSD 2-Clause \"Simplified\" License Copyright © 2014, Tom Christie. All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","text_tokens":["data","of","as","purpose","on","reproduce","permitted","exemplary","that","fitness","documentation","and","christie","/","rights","contributors","redistributions","substitute","distribution","not","to","holder","the","damage",".","warranties","a","reserved","damages","2014","liability","even","-","arising"," ","services",")","for","no","other","consequential","provided","including","disclaimer","above","caused","notice","procurement","tort","must","conditions","strict","list","2","be","interruption",":","is","shall","otherwise","however","disclaimed","liable","retain","license","are","incidental","merchantability","without","all","if","with","event","form","this","source","any","contract","particular","met","\"","simplified","or","loss","profits","holders","modification","out","way","tom","limited","©","code","indirect","use","in","theory","such","binary","by","software","direct","implied","special","whether",";","redistribution","possibility","clause","materials","(","following","advised","copyright","negligence","express","bsd","but",",","goods","business","forms"],"title":"License of MkDocs","title_tokens":["of","mkdocs"," ","license"]},{"location":"licenses/#license-of-jieba3k","text":"The MIT License (MIT) Copyright © 2013 Sun Junyi Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","text_tokens":["of","deal","as","mit","purpose","junyi","fitness","documentation","hereby","and","charge","/","rights","merge","noninfringement","portions","subject","limitation","copy","not","copies","to","permit","persons","the",".","warranties","a","modify","sell","damages","liability","arising"," ",")","so","for","no","other","provided","action","including","connection","above","notice","claim","distribute","tort","included","conditions","person","be","substantial",":","is","authors","shall","otherwise","liable","from","whom","license","warranty","sublicense","obtaining","merchantability","do","without","all","with","event","kind","granted","this","an","any","furnished","contract","free","particular","associated","\"","or","sun","holders","out","permission","limited","©","use","in","publish","dealings","software","implied","whether","(","2013","following","copyright","express","restriction","files","but",","],"title":"License of Jieba3K","title_tokens":["of"," ","jieba3k","license"]},{"location":"licenses/#license-of-simple-lightbox","text":"The MIT License (MIT) Copyright © 2018 Damir Brekalo Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","text_tokens":["of","deal","as","mit","purpose","fitness","documentation","hereby","and","charge","/","rights","merge","noninfringement","portions","subject","limitation","copy","not","copies","to","permit","brekalo","persons","the",".","warranties","a","modify","sell","damages","liability","arising"," ",")","so","for","no","other","provided","action","including","connection","above","notice","claim","distribute","tort","included","conditions","person","be","substantial",":","is","authors","shall","otherwise","liable","from","whom","license","warranty","sublicense","obtaining","merchantability","do","without","2018","all","with","event","kind","granted","this","an","any","damir","furnished","contract","free","particular","associated","\"","or","holders","out","permission","limited","©","use","in","publish","dealings","software","implied","whether","(","following","copyright","express","restriction","files","but",","],"title":"License of Simple Lightbox","title_tokens":["of","license"," ","lightbox","simple"]},{"location":"licenses/#license-of-mathjax","text":"Apache License 2.0 See the full license here: MathJax license","text_tokens":["apache","full","license",":","2.0","the"," ","here","mathjax","see"],"title":"License of MathJax","title_tokens":["of"," ","license","mathjax"]},{"location":"licenses/#license-of-mermaid","text":"The MIT License (MIT) Copyright © 2014 - 2018 Knut Sveidqvist Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","text_tokens":["of","deal","as","mit","purpose","fitness","documentation","hereby","and","charge","/","rights","merge","noninfringement","sveidqvist","portions","subject","limitation","copy","not","copies","to","permit","persons","the",".","warranties","a","modify","sell","damages","2014","liability","-","arising"," ",")","so","for","no","other","provided","action","including","connection","above","notice","claim","distribute","tort","included","conditions","person","be","substantial",":","is","authors","shall","otherwise","knut","liable","from","whom","license","warranty","sublicense","obtaining","merchantability","do","without","2018","all","with","event","kind","granted","this","an","any","furnished","contract","free","particular","associated","\"","or","holders","out","permission","limited","©","use","in","publish","dealings","software","implied","whether","(","following","copyright","express","restriction","files","but",","],"title":"License of mermaid","title_tokens":["of","mermaid"," ","license"]},{"location":"release-notes/","text":"更新记录 ¶ 大版本更新 ¶ 在此记录本文档的主要更新，读者可以在此确认经过更新后，本文档添加了哪些主要的内容、话题。 0.1 @ February 25, 2019 ¶ 正式立项，开始本文档的撰写工作。目前尚处于未完成状态，计划包括： Tensorflow 1.12 入门教程 从线性问题入门 40% 训练与测试分立 0% 原生的数据管理 0% 其他的高级技巧 0% Tensorflow 2.0 入门教程 0% Tensorflow 第三方扩展库 入门教程 0% 局部更新记录 ¶ 0.17 @ March 5, 2019 ¶ 完成“从线性问题入门”专题下的 线性分类 ； 修正前文的一些笔误。 0.15 @ March 4, 2019 ¶ 完成“从线性问题入门”专题下的 本章总说 和 Hello world! ； 微调图片链接， MathJax 的显示特性。 0.12 @ March 3, 2019 ¶ 补完扉页。未来可能会调整 教程导读 ； 修复 Arithmatex 对 MathJax 的引入； 引入 mermaid 库，用于绘制示意图。 0.11 @ February 25, 2019 ¶ 提交 Google Analytics 和 Google Search Console 的账户关联资料； 提交 Disqus 关联资料。 0.10 @ February 25, 2019 ¶ 正式立项，并撰写扉页的一部分。","text_tokens":["未","可以","立项","；","技巧","示意","search","训练","用于","了","0.15","意图","本","分类","记录本","总说","微调","mermaid","处于","其他","前文","关联","第三","可能","教程","笔误","world","目前","3","记录","5","”","对","0.11","入门教程","链接","4","未来","并","导读","确认","修正"," ","修复","¶","资料","读者","线性","2.0","账户","此","版本","analytics","引入","工作","专题","march","部分","本章","、","mathjax","从","40","测试","一些","分立","：","三方","问题","更新","特性","console","的","绘制","内容","正式","2019","google","显示","february","一部","撰写","计划","后","示意图","。","和","0.10","图片链接","开始","原生","0.17","大","0.1","补完","状态","添加","arithmatex","25","hello","0","与","哪些","数据","话题","第三方","提交","disqus","，","完成","数据管理","主要","经过","1.12","%","包括","下","库","高级","尚","文档","!","扩展","@","入门","在","一部分","图片","tensorflow",",","0.12","会","调整","管理","局部","“","扉页"],"title":"更新记录","title_tokens":["记录","更新"]},{"location":"release-notes/#_1","text":"","text_tokens":[],"title":"更新记录","title_tokens":["记录","更新"]},{"location":"release-notes/#_2","text":"在此记录本文档的主要更新，读者可以在此确认经过更新后，本文档添加了哪些主要的内容、话题。","text_tokens":["更新","话题","的","确认","内容","，","可以","了","后","主要","读者","经过","此","。","本","记录本","、","文档","添加","在","记录","哪些"],"title":"大版本更新","title_tokens":["版本","更新","大"]},{"location":"release-notes/#01-february-25-2019","text":"正式立项，开始本文档的撰写工作。目前尚处于未完成状态，计划包括： Tensorflow 1.12 入门教程 从线性问题入门 40% 训练与测试分立 0% 原生的数据管理 0% 其他的高级技巧 0% Tensorflow 2.0 入门教程 0% Tensorflow 第三方扩展库 入门教程 0%","text_tokens":["第三方","的","未","正式","，"," ","立项","完成","技巧","训练","撰写","计划","数据管理","三方","线性","2.0","1.12","。","工作","%","本","包括","数据","库","开始","处于","原生","其他","高级","尚","文档","第三","教程","状态","从","40","扩展","入门","测试","0","目前","tensorflow","与","分立","管理","：","问题","入门教程"],"title":"0.1 @ February 25, 2019","title_tokens":["@","25",","," ","2019","0.1","february"]},{"location":"release-notes/#_3","text":"","text_tokens":[],"title":"局部更新记录","title_tokens":["局部","记录","更新"]},{"location":"release-notes/#017-march-5-2019","text":"完成“从线性问题入门”专题下的 线性分类 ； 修正前文的一些笔误。","text_tokens":["专题","从","分类","笔误","“","入门","下","的","修正","前文","线性","一些","”"," ","；","。","完成","问题"],"title":"0.17 @ March 5, 2019","title_tokens":["march","@","5",",","0.17"," ","2019"]},{"location":"release-notes/#015-march-4-2019","text":"完成“从线性问题入门”专题下的 本章总说 和 Hello world! ； 微调图片链接， MathJax 的显示特性。","text_tokens":["链接","特性","的","，"," ","；","完成","显示","线性","。","和","专题","总说","下","图片链接","微调","本章","mathjax","!","从","入门","world","图片","hello","”","“","问题"],"title":"0.15 @ March 4, 2019","title_tokens":["march","@","4","0.15",","," ","2019"]},{"location":"release-notes/#012-march-3-2019","text":"补完扉页。未来可能会调整 教程导读 ； 修复 Arithmatex 对 MathJax 的引入； 引入 mermaid 库，用于绘制示意图。","text_tokens":["未来","导读","的","绘制","，"," ","；","修复","示意","用于","意图","示意图","。","引入","库","mermaid","mathjax","补完","可能","教程","arithmatex","会","调整","对","扉页"],"title":"0.12 @ March 3, 2019","title_tokens":["march","@","3","0.12",","," ","2019"]},{"location":"release-notes/#011-february-25-2019","text":"提交 Google Analytics 和 Google Search Console 的账户关联资料； 提交 Disqus 关联资料。","text_tokens":["资料","console","的","关联","提交","账户","disqus","。"," ","analytics","；","google","和","search"],"title":"0.11 @ February 25, 2019","title_tokens":["@","25",","," ","2019","0.11","february"]},{"location":"release-notes/#010-february-25-2019","text":"正式立项，并撰写扉页的一部分。","text_tokens":["一部","并","撰写","的","一部分","正式","，","立项","。","扉页","部分"],"title":"0.10 @ February 25, 2019","title_tokens":["0.10","@","25",","," ","2019","february"]},{"location":"book-1-x/chapter-1/","text":"从线性问题入门 ¶ 摘要 本章将从线性问题入手，讨论最简单的分类与回归问题。我们将随机生成指定分布的数据，通过理论值，检查实验效果。这些简单的、解析的问题，可以提供读者一个直观的感受，并帮助读者快速上手Tensorflow的基本概念与运用。本章中，我们不会涉及任何数据存取、跟踪测度方面的概念，也不会将训练和测试分开，旨在使读者能集中心思到代码规范和Tensorflow的基本功能上。 漫谈线性问题 ¶ 在机器学习领域，线性问题既简单也不简单。目前神经网络主要是指多层、非凸的网络结构，常常用来解复杂的、难以推导的问题。但这并不意味着线性问题容易解决。相反，在很多情况下，线性问题是解不唯一的(undetermined)，解不稳定的(ill-posed/ill-conditioned)，条件的(constrained)。同时，为了得到一个快速收敛的、高质量的解，即使对线性问题，人们也在不断提出、改进解法。例如ISTA, AMP, PGD, LISTA, vAMP等算法，都用来解线性问题。在此不作详细展开。 我们已经知道，一个线性函数具有可加性，和一次齐次性，亦即 \\begin{align} f(x_1 + x_2) &= f(x_1) + f(x_2), \\\\ f(\\alpha x) &= \\alpha f(x). \\end{align} 因此，求解一个线性问题，我们需要将问题纯粹以 线性函数 进行描述。例如， \\begin{align} \\mathbf{y} \\sim \\mathbf{A}\\mathbf{x}. \\end{align} 具体而言， \\mathbf{x} \\mathbf{x} 是我们的已知数据， \\mathbf{y} \\mathbf{y} 是我们的未知量，我们需要找到一个合适的 \\mathbf{A} \\mathbf{A} 来确保 \\mathbf{x} \\mathbf{x} 能拟合到 \\mathbf{y} \\mathbf{y} 。如果此处 \\mathbf{y} \\in \\{0,~1\\}^p \\mathbf{y} \\in \\{0,~1\\}^p 是一个代表p类-分类的向量，那么这就是一个线性分类问题；相反，如果此处 \\mathbf{y} \\in \\mathbb{R}^p \\mathbf{y} \\in \\mathbb{R}^p 在连续p维空间取值，那么这就是一个线性回归问题。 线性问题与凸问题 ¶ 请注意，虽然我们在此处提到“ 线性问题 (Linear problem) ”，但我们指的并非“ 线性规划 (Linear programming) ”。虽然严格意义上，线性规划才是真正的线性问题，但我们在此处尚不讨论线性规划相关的内容，而是着眼于机器学习应用最普遍的两个领域， 分类 和 回归 上。实际上，这两种问题虽然求解的是线性函数，但本质上是凸问题。 例如，如果我们要求解回归问题，通常可以表述成 \\begin{equation} \\begin{aligned} \\arg \\min_{\\mathbf{A}}~& \\sum_{i=1}^N \\mathcal{L}(\\mathbf{A},~\\mathbf{x}_i,~\\mathbf{y}_i), \\\\ \\mathcal{L}(\\mathbf{A},~\\mathbf{x},~\\mathbf{y}) &= \\lVert \\mathbf{y} - \\mathbf{A}\\mathbf{x} \\rVert^2_2. \\end{aligned} \\end{equation} 虽然我们求解的模型 \\mathbf{A} \\mathbf{A} 是线性的，但我们优化的函数对象 \\mathcal{L} \\mathcal{L} 是一个 凸函数 (convex function) 。在此，我们可以将这个标量函数(同时也是凸函数)表述为 \\begin{align} \\forall~\\alpha,~\\beta,~\\mathbf{x}_1,~\\mathbf{x}_2,~\\mathcal{L}(\\alpha\\mathbf{x}_1 + \\beta\\mathbf{x}_2) \\leqslant \\alpha\\mathcal{L}(\\mathbf{x}_1) + \\beta\\mathcal{L}(\\mathbf{x}_2). \\end{align} 我们将这个问题表述为 最小二乘问题(Least-square problem) 。正是由于 \\mathbf{A} \\mathbf{A} 是线性的， \\mathcal{L} \\mathcal{L} 才能被确保为一个凸函数，进而，我们才能确保上述问题能得到精确的全局最小值解。 知悉Tensorflow ¶ 在本章接下来的内容里，我们将探讨Tensorflow如何求解一些简单的问题。对于初次上手的读者而言，在安装Tensorflow，亲自开始写一些project之前，笔者推荐你到这个游乐场“抢鲜体验”一番， Tensorflow Playground 在这个在线页面里，用户不需要有任何编程知识，可以通过直观的操作界面，建立一个简单的 多层感知机网络(有时也叫做Artificial Neural Network, ANN) ，并且实时观测网络的性能和测度。它提供了几个简单的二维数据集，供用户体验不同的数据集下，各种分类、回归问题的合宜解法。如果读者已经对神经网络的基本原理有所了解，相信能通过这个小小的实验场达到心有灵犀。我们在本章所做的project和demo，大体不跳出这个试验场的范畴，只是会略微复杂一点而已。 本章要点 ¶ 下图展示了通过本章学习，能了解到的概念： graph LR st(Hello world!) --> linclas(线性分类) linclas --> linreg(线性回归) linreg --> nonlinreg(非线性回归) nonlinreg --> ed(非线性分类) lp[感知机] --> linclas sigma[Logsitc回归] --> linclas ce[交叉熵] --> linclas opt[优化器] --> linreg argpar[项目选项] --> linreg para[参数回归] --> nonlinreg kernel[核函数] --> ed classDef styStart fill:#FAE6A9,stroke:#BA9132; class st,linclas,linreg,nonlinreg,ed styStart Hello world : 首先，在本节，读者将了解Tensorflow的安装方法，并编写通过第一个简单的Tensorflow程序。 线性分类 : 本节通过解一个简单的二分类问题，我们将引入单层感知机、Logistic回归和交叉熵的概念，并且实验结果进行可视化。 线性回归 : 本节通过解一个与上一节难度相仿的，简单的回归问题，另读者能对比不同优化器的性能、特点，并介绍如何在项目中进行arugument parsing(引入项目的可选项)。 非线性回归 : 本节将修改上一节回归问题的激活函数，将线性的回归问题推广到解析函数参数回归的范畴。 非线性分类 : 本节将通过上一节的参数回归，引入核函数的概念，将线性分类问题推广到非线性空间里。","text_tokens":["可视化","vamp","虽然","向量","亲自","通常","检查","抢鲜","神经网","大体","lr","/","即使","难以","结构","{","ista","两个","world","fill","领域","条件","所","要求","提供","而言","a","使","并","叫做","感知机","两种","分布","节","入手","性","linear","^","你","试验","amp","真正","详细","体验","达到","arg","写","情况","求解","posed","测试","它","不","不断","略微","logsitc","维空间","beta","参数","稳定","内容","精确","mathbb","注意","描述","equation","标量","唯一","stroke","跟踪","解决","拟合","纯粹","和","我们","&","才","为了","性能","界面","涉及","特点","了解","各种","begin","未知","有时","与","#","ba9132","即","做","align","argpar","一点","代码","opt","fae6a9","集中","in","首先","齐次","知悉","\\","随机",";","需要","l","这","tensorflow",",","=","neural","mathcal","；","pgd","demo","快速","了","展开","灵犀","很多","摘要","来","下图","那么","推广","如果","leqslant","对比","分类","network","心思","最小值","意味","项目","普遍","帮助","指定","感受","回归","意味着","以","方法","神经网络","project","都","漫谈",")","收敛","正是","此处","mathbf","功能","本章","多层","提到","修改","网络结构","并非","相仿","推荐","并且","将","[","问题","p","高质量","着眼于","最","基本功能","f","相反","二","建立","接下","]","function","1","min","心有灵犀","ill","进而","logistic","改进","函数参数","凸函数","得到","数据","选项","进行","nonlinreg","一个","classdef","交叉","由于","介绍","也","本原","熵","尚",">","!","aligned","网络","在","会","严格","操作","如何","被","不会","线性规划","跳出","通过","lp","存取","对于","undetermined","训练","对象","展示","可选","凸","下来","就是","编程","常常","stystart","linclas","x","基本","st","最小","操作界面","ed","”",".","代表","算法","概念","游乐场","基本功","可加","分开"," ","而是","原理","¶","线性","读者","二乘","引入","空间","成","类","上","、","这个","着眼","一番","观测","模型","直观","2","理论","合适","不作","小小的","结果","用户","artificial","器","上述","范畴","end","programming","lvert","相信","推导","least","是","但","ce","可视","之前","试验场","优化","一节","已知","开始","sigma","基本原理","~","上手","而已","供","convex","hello","0","知道","ann","_","constrained","n","人们","集","例如","连续","，","实验场","可加性","实际","合宜","在线","r","graph","实验","激活","(","第一","取值","}","初次","具体","有","forall","y","只是","非线性","核","接下来","playground","可以","未知量","指","全局","方面","确保","kernel","sum","本","神经","实际上","解析","+","意义","为","高质","小小","效果","sim","目前","i","机器","对","感知","可选项","提出","实时","解不","-","相关","alpha","不同","旨在","本节","难度","具有","此","等","非凸","测度","知机","中","程序","才能","二维","从","problem","任何","同时","第一个",":","游乐","一些","linreg","页面","找到","另","：","单层","请","简单","要点","的","class","既","解","一次","应用","本质","学习","。","讨论","编写","lista","用来","集下","parsing","基本概念","探讨","知识","conditioned","复杂","几个","square","arugument","因此","有所","已经","主要","生成","这些","质量","能","理论值","下","亦","到","规划","解法","容易","规范","笔者","入门","函数","里","para","安装","rvert","“","运用","表述"],"title":"本章总说","title_tokens":["总说","本章"]},{"location":"book-1-x/chapter-1/#_1","text":"摘要 本章将从线性问题入手，讨论最简单的分类与回归问题。我们将随机生成指定分布的数据，通过理论值，检查实验效果。这些简单的、解析的问题，可以提供读者一个直观的感受，并帮助读者快速上手Tensorflow的基本概念与运用。本章中，我们不会涉及任何数据存取、跟踪测度方面的概念，也不会将训练和测试分开，旨在使读者能集中心思到代码规范和Tensorflow的基本功能上。","text_tokens":["并","概念","简单","基本功","最","的","一个","不会","代码","分布","基本功能","分开","，"," ","通过","集中","可以","入手","旨在","存取","训练","检查","快速","跟踪","线性","读者","运用","方面","生成","摘要","这些","。","和","也","我们","能","功能","讨论","分类","随机","理论值","测度","中","数据","实验","涉及","本章","解析","心思","、","上","到","基本概念","上手","从","直观","基本","规范","任何","理论","测试","效果","帮助","将","与","tensorflow","指定","提供","感受","回归","问题","使"],"title":"从线性问题入门","title_tokens":["从","入门","问题","线性"]},{"location":"book-1-x/chapter-1/#_2","text":"在机器学习领域，线性问题既简单也不简单。目前神经网络主要是指多层、非凸的网络结构，常常用来解复杂的、难以推导的问题。但这并不意味着线性问题容易解决。相反，在很多情况下，线性问题是解不唯一的(undetermined)，解不稳定的(ill-posed/ill-conditioned)，条件的(constrained)。同时，为了得到一个快速收敛的、高质量的解，即使对线性问题，人们也在不断提出、改进解法。例如ISTA, AMP, PGD, LISTA, vAMP等算法，都用来解线性问题。在此不作详细展开。 我们已经知道，一个线性函数具有可加性，和一次齐次性，亦即 \\begin{align} f(x_1 + x_2) &= f(x_1) + f(x_2), \\\\ f(\\alpha x) &= \\alpha f(x). \\end{align} 因此，求解一个线性问题，我们需要将问题纯粹以 线性函数 进行描述。例如， \\begin{align} \\mathbf{y} \\sim \\mathbf{A}\\mathbf{x}. \\end{align} 具体而言， \\mathbf{x} \\mathbf{x} 是我们的已知数据， \\mathbf{y} \\mathbf{y} 是我们的未知量，我们需要找到一个合适的 \\mathbf{A} \\mathbf{A} 来确保 \\mathbf{x} \\mathbf{x} 能拟合到 \\mathbf{y} \\mathbf{y} 。如果此处 \\mathbf{y} \\in \\{0,~1\\}^p \\mathbf{y} \\in \\{0,~1\\}^p 是一个代表p类-分类的向量，那么这就是一个线性分类问题；相反，如果此处 \\mathbf{y} \\in \\mathbb{R}^p \\mathbf{y} \\in \\mathbb{R}^p 在连续p维空间取值，那么这就是一个线性回归问题。","text_tokens":["y","=","vamp","向量","；","未知量","undetermined","pgd","指","快速","神经网","展开","很多","确保","就是","来","那么","/","如果","即使","分类","神经","常常","+","意味","难以","结构","{","高质","x","ista","sim","领域","目前","条件","机器","对",".","代表","而言","以","意味着","算法","a","回归","神经网络","并","提出","可加","解不","-","都",")"," ","alpha","性","收敛","具有","线性","^","此处","此","amp","mathbf","等","非凸","详细","空间","类","、","多层","情况","网络结构","求解","posed","2","合适","同时","不作","将","不","不断","找到","问题","p","维空间","高质量","简单","稳定","的","end","f","相反","mathbb","既","推导","描述","唯一","是","但","解","一次","1","解决","拟合","学习","。","ill","和","纯粹","我们","&","为了","lista","已知","改进","用来","~","begin","conditioned","未知","复杂","0","得到","知道","即","数据","_","constrained","align","人们","进行","例如","一个","连续","，","因此","in","已经","齐次","可加性","主要","\\","质量","r","也","能","下","亦","需要","到","(","取值","}","解法","容易","网络","具体","在","这","函数",","],"title":"漫谈线性问题","title_tokens":["问题","漫谈","线性"]},{"location":"book-1-x/chapter-1/#_3","text":"请注意，虽然我们在此处提到“ 线性问题 (Linear problem) ”，但我们指的并非“ 线性规划 (Linear programming) ”。虽然严格意义上，线性规划才是真正的线性问题，但我们在此处尚不讨论线性规划相关的内容，而是着眼于机器学习应用最普遍的两个领域， 分类 和 回归 上。实际上，这两种问题虽然求解的是线性函数，但本质上是凸问题。 例如，如果我们要求解回归问题，通常可以表述成 \\begin{equation} \\begin{aligned} \\arg \\min_{\\mathbf{A}}~& \\sum_{i=1}^N \\mathcal{L}(\\mathbf{A},~\\mathbf{x}_i,~\\mathbf{y}_i), \\\\ \\mathcal{L}(\\mathbf{A},~\\mathbf{x},~\\mathbf{y}) &= \\lVert \\mathbf{y} - \\mathbf{A}\\mathbf{x} \\rVert^2_2. \\end{aligned} \\end{equation} 虽然我们求解的模型 \\mathbf{A} \\mathbf{A} 是线性的，但我们优化的函数对象 \\mathcal{L} \\mathcal{L} 是一个 凸函数 (convex function) 。在此，我们可以将这个标量函数(同时也是凸函数)表述为 \\begin{align} \\forall~\\alpha,~\\beta,~\\mathbf{x}_1,~\\mathbf{x}_2,~\\mathcal{L}(\\alpha\\mathbf{x}_1 + \\beta\\mathbf{x}_2) \\leqslant \\alpha\\mathcal{L}(\\mathbf{x}_1) + \\beta\\mathcal{L}(\\mathbf{x}_2). \\end{align} 我们将这个问题表述为 最小二乘问题(Least-square problem) 。正是由于 \\mathbf{A} \\mathbf{A} 是线性的， \\mathcal{L} \\mathcal{L} 才能被确保为一个凸函数，进而，我们才能确保上述问题能得到精确的全局最小值解。","text_tokens":["y","=","被","线性规划","mathcal","虽然","可以","对象","通常","指","“","全局","凸","确保","sum","如果","leqslant","分类","实际上","+","意义","最小值","为","{","x","两个","最小","普遍","领域","i","机器","”","要求",".","回归","a","两种","-","相关"," ",")","alpha","而是","linear","正是","线性","^","二乘","此处","此","真正","mathbf","成","上","arg","提到","这个","着眼","并非","求解","模型","才能","2","problem","同时","将","不","问题","请","beta","上述","着眼于","end","的","最","programming","内容","精确","lvert","注意","equation","标量","least","是","但","解","function","min","1","应用","本质","学习","。","和","优化","我们","&","才","讨论","进而","~","begin","凸函数","convex","得到","square","_","align","n","例如","一个","，","实际","由于","\\","也","能","尚","(","l","规划","}","aligned","在","这","函数",",","rvert","严格","forall","表述"],"title":"线性问题与凸问题","title_tokens":["与","凸","问题","线性"]},{"location":"book-1-x/chapter-1/#tensorflow","text":"在本章接下来的内容里，我们将探讨Tensorflow如何求解一些简单的问题。对于初次上手的读者而言，在安装Tensorflow，亲自开始写一些project之前，笔者推荐你到这个游乐场“抢鲜体验”一番， Tensorflow Playground 在这个在线页面里，用户不需要有任何编程知识，可以通过直观的操作界面，建立一个简单的 多层感知机网络(有时也叫做Artificial Neural Network, ANN) ，并且实时观测网络的性能和测度。它提供了几个简单的二维数据集，供用户体验不同的数据集下，各种分类、回归问题的合宜解法。如果读者已经对神经网络的基本原理有所了解，相信能通过这个小小的实验场达到心有灵犀。我们在本章所做的project和demo，大体不跳出这个试验场的范畴，只是会略微复杂一点而已。","text_tokens":["只是","如何","neural","跳出","接下来","通过","playground","亲自","可以","对于","demo","了","抢鲜","神经网","大体","灵犀","下来","编程","如果","分类","神经","network","基本","操作界面","小小","所","感知","”","对","提供","而言","回归","神经网络","叫做","游乐场","实时","感知机","project"," ",")","不同","原理","读者","你","试验","测度","体验","知机","达到","本章","、","多层","这个","写","一番","求解","观测","二维","直观","任何","推荐","并且","小小的","将","游乐","一些","不","它","页面","用户","略微","artificial","问题","简单","范畴","的","内容","建立","接下","相信","心有灵犀","之前","试验场","。","和","我们","性能","界面","开始","集下","了解","各种","探讨","知识","基本原理","上手","而已","供","有时","复杂","几个","ann","数据","做","集","一个","一点","，","实验场","有所","已经","合宜","在线","也","能","本原","实验","需要","到","(","初次","解法","笔者","网络","在","里","有","安装","tensorflow",",","会","“","操作"],"title":"知悉Tensorflow","title_tokens":["tensorflow","知悉"]},{"location":"book-1-x/chapter-1/#_4","text":"下图展示了通过本章学习，能了解到的概念： graph LR st(Hello world!) --> linclas(线性分类) linclas --> linreg(线性回归) linreg --> nonlinreg(非线性回归) nonlinreg --> ed(非线性分类) lp[感知机] --> linclas sigma[Logsitc回归] --> linclas ce[交叉熵] --> linclas opt[优化器] --> linreg argpar[项目选项] --> linreg para[参数回归] --> nonlinreg kernel[核函数] --> ed classDef styStart fill:#FAE6A9,stroke:#BA9132; class st,linclas,linreg,nonlinreg,ed styStart Hello world : 首先，在本节，读者将了解Tensorflow的安装方法，并编写通过第一个简单的Tensorflow程序。 线性分类 : 本节通过解一个简单的二分类问题，我们将引入单层感知机、Logistic回归和交叉熵的概念，并且实验结果进行可视化。 线性回归 : 本节通过解一个与上一节难度相仿的，简单的回归问题，另读者能对比不同优化器的性能、特点，并介绍如何在项目中进行arugument parsing(引入项目的可选项)。 非线性回归 : 本节将修改上一节回归问题的激活函数，将线性的回归问题推广到解析函数参数回归的范畴。 非线性分类 : 本节将通过上一节的参数回归，引入核函数的概念，将线性分类问题推广到非线性空间里。","text_tokens":["非线性","如何","核","可视化","通过","lp","展示","了","可选","推广","下图","lr","kernel","对比","分类","本","stystart","解析","linclas","st","项目","world","fill","ed","感知","可选项","回归","方法","并","概念","感知机","-"," ",")","不同","节","本节","难度","线性","读者","引入","空间","知机","中","本章","上","程序","、","修改","相仿","结果","第一个",":","并且","将","linreg","另","器","logsitc","[","：","问题","单层","参数","简单","范畴","的","二","class","解","]","stroke","ce","可视","学习","。","和","优化","我们","一节","编写","性能","logistic","特点","了解","sigma","parsing","函数参数","hello","与","#","ba9132","选项","进行","nonlinreg","arugument","argpar","一个","classdef","opt","交叉","，","fae6a9","首先","介绍","能","graph",";","实验","熵","到","激活","(","第一",">","!","在","函数","里","para","安装","tensorflow",","],"title":"本章要点","title_tokens":["要点","本章"]},{"location":"book-1-x/chapter-1/hello-world/","text":"Hello world! ¶ 摘要 本节包含一个简易的安装指导，主要提供给Windows上的GPU用户。之后，用户可以按照本节指导编写第一个测试程序。 安装Tensorflow ¶ 本节针对Windows使用GPU的用户，提供一个安装最新版Tensorflow的方法。大致的步骤符合以下两个教程： 通过pip安装Tensorflow Tensorflow的GPU支持 但是，需要指出的是，官方教程里有些部分已经不符合当前用户的实际情况，笔者经过摸索，总结以下的安装过程。 总体而言，安装Tensorflow需要用户确保以下条件 NVIDIA驱动已经达到411.31及以上 CUDA 10.0 (10.1不确定能否正常使用) CUDNN已经达到7.3.1及以上 CUPTI版本与CUDA相配（不需要专门安装，在安装CUDA的同时已经自动集成） 除此之外，涉及多GPU支持的库(NCCL和TensorRT)，这里不考虑。因此，我们主要需要确保前三条正常安装。 提示 Tensorflow官方提供的安装包是基于CUDA 9.0，CUDNN >= 7.2的基础上编译的。然而现在NVIDIA已经不再提供CUDA 9.0了。Windows用户可以安装的版本包括过时的8.1和最新的10.1。在这种情况下，官方还提供一个令用户自行从源码编译Tensorflow库的方案，但是对于Windows用户而言过于繁琐，容易出错，这里不建议按照官方教程。 更新NVIDIA驱动 ¶ 首先，我们可以开始更新我们的NVIDIA驱动。任何载有NVIDIA-GPU显卡的电脑，都应当在系统里已经预装好了 GeForce Experience 。点击如下图标开启GeForce Experience（如果是低版本的GeForce Experience，图标可能会不同）， 如左图，在主界面上，可以观察到，当驱动版本不够高时，会自动出现更新提示，依照提示更新即可。建议在更新驱动时，关闭其他所有程序，以免造成干扰。 更新NVIDIA driver 检查更新结果 如果更新完成，如右图，可以在设置界面检查到当前的版本已经达到最新。在安装过程中，由于驱动更新，屏幕可能会闪烁数次。在看到更新提示完成后建议重启。 提示 如果GeForce Experience提示无法更新驱动，可以考虑将机器恢复出厂设置，可能可以解决这一问题。 安装CUDA ¶ 驱动更新并重启后，需要安装最新版的Visual Studio(VS)，这是因为CUDA库本身对VS具有一定的支持，如果先安装CUDA，则这部分支持无法安装到位。这对我们使用Tensorflow并不造成妨害，但是对CUDA的用户并不是一个推荐的做法，所以无论如何，建议在第一步，安装VS，下面提供VS社区版（免费）的链接： Visual Studio官网 接下来，可以开始安装CUDA。进入CUDA安装包的下载链接 下载最新版CUDA CUDA官方指南 提示 须知，并非最新版就是最适合的版本。实际能使用的CUDA版本取决于后续步骤中预编译包的支持版本。就笔者写到这里时，最新的CUDA 10.1已然不匹配最新版预编译包支持的CUDA 10.0，由于版本差距很小，不确定是否会由此引发问题，但读者可以自行尝试。 现在的安装包已经支持在线安装包和离线安装包两种模式，读者可以根据自己的实际情况选择对应的版本。注意，安装CUDA的时候，CUDA可能要求我们翻新驱动版本，但通过GeForce Experience安装的驱动一般应已达到最新，新于CUDA内部提供的驱动。因此，我们需要选择定制安装模式，根据我们需要对比版本号，将驱动更新的选项取消，如下图所示 安装CUDA后，建议重启。 危险 特别需要注意的是，如果你的机器无法通过GeForce Experience更新驱动，那么在这里选择安装驱动也是枉然。并且，这种强制更新驱动的行为很可能导致系统崩溃。因此特别建议在安装CUDA之前一定要解决驱动更新的问题，哪怕是通过恢复出厂设置。 安装CUDNN ¶ 安装CUDA的同时，已经自带安装上了CUPTI。但是CUDNN并没有包含在CUDA中，因此，我们需要到以下链接下载CUDNN并查看安装说明 下载最新版CUDNN CUDNN官方指南 不同的是，CUDNN没有安装包，是以压缩包的形式下载到本地。解压后，其中应当包含如下目录及文件 . └─ cuda/ ├─ bin/ # Binary library │ └─ cudnn64_7.dll ├─ include/ # C++ Include file │ └─ cudnn.h ├─ lib/ # C++ Lib file │ └─ x64/ │ └─ cudnn.lib └─ NVIDIA_SLA_cuDNN_Support.txt # Readme file 假设我们CUDA的安装目录在 C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v10.0 ，将上述解压的 bin , include 和 lib 三个文件夹，直接拷贝覆盖到该安装目录下，即可完成CUDNN的安装。 进行完上述步骤后，我们还需要确保几个环境变量正确设置： 存在 CUDA_PATH=C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v10.0 ，是我们的安装目录。理论上在CUDA安装后，该目录已经自动设置好。 环境变量 PATH 中，存在 C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v10.0/bin , C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v10.0/extras/CUPTI/libx64 两个路径，由于CUDNN已经配置在CUDA安装目录下，我们不需要像官方文档那样，添加第三个CUDNN的安装路径。 安装Anaconda ¶ Windows用户建议使用Anaconda管理python环境。作为一个开源的项目，Anaconda发行版已经集成了我们所需要的大多数python包，其中有些包是我们自己难以安装上的，例如支持python3的PIL。我们选用python3版的Anaconda，下载路径如下： Anaconda 最新版下载链接 注意选择x64版的安装包。安装结束后，我们已经有python3.7的环境了。鉴于有些情况下我们可能需要使用更早的python版本，接下来我们可以安装python3.6的虚环境。 Anaconda可以安装在用户或系统目录下。注意，如果安装在系统目录下，如果不在虚环境下，安装任何包都需要管理员模式。不过这不影响本教程的示例，因为我们将安装虚环境。直接打开 Anaconda Prompt ，并键入以下命令： conda create -n py36 python = 3 .6 anaconda 按照引导流程安装，经过一段时间后，我们将得到python3.6版的Anaconda。以后我们可以直接从开始菜单 Anaconda Prompt (py36) 进入该虚环境，也可以在基环境中键入 activate py36 转换到虚环境中。 提示 如果用户愿意，还可以通过 conda install -c conda-forge opencv 安装 opencv 。opencv是一个强大的图像处理库，这里python版的opencv比C++版更容易上手。一般该命令安装的是conda库中最新版的opencv（截至笔者写到这里时是opencv3.4.4）。然而，这样安装的并非是支持GPU的版本。尽管conda还提供一个GPU的opencv版本，可以通过 conda install -c patricksnape opencv-gpu 安装 opencv2 ，但它的版本还停留在2.4.9，和opencv3的用法殊有不同，请读者注意这一点。 安装预编译好的Tensorflow ¶ 我们可以查看如下项目： fo40225/tensorflow-windows-wheel 该项目的维护者在不断根据Tensorflow的更新，预编译出适合不同版本的Tensorflow安装包。截至笔者写到这里为止，最新支持到r1.12版。我们选择对应的GPU版Tensorflow，并在虚环境下执行以下命令： pip install https://github.com/fo40225/tensorflow-windows-wheel/blob/master/1.12.0/py36/GPU/cuda100cudnn73sse2/tensorflow_gpu-1.12.0-cp36-cp36m-win_amd64.whl 等待一段时间后，安装将会结束。 Hello world! 测试 ¶ 撰写如下代码，保存到 hello-world.py 文件， Python 1 2 3 4 5 6 7 8 9 if __name__ == '__main__' : import tensorflow as tf test_str = tf . constant ( 'Hello, world!' ) test_cal = tf . reduce_sum ( tf . random_normal ([ 1000 , 1000 ])) with tf . Session () as sess : print ( 'Current Tensorflow version is:' , tf . __version__ ) print ( 'Test string: ' , sess . run ( test_str )) print ( 'Test calculation:' , sess . run ( test_cal )) Output Current Tensorflow version is: 1 .12.0 Test string: b 'Hello, world!' Test calculation: -1948.6578 在保存目录下，执行 python hello-world.py 第一次运行可能需要等待较长的初始化时间（硬件配置）。如果能正常运行，我们将看到如下结果： 其中，显示结果之前的记录信息反映了GPU已经可以正常工作。而“Test calculation”显示的结果是 10^6 10^6 个服从 \\mathcal{N}(0,1) \\mathcal{N}(0,1) 分布的随机数之和。根据相互独立的随机正态分布互不相关的特性，我们可以推算出，该结果服从 \\mathcal{N}(0,10^3) \\mathcal{N}(0,10^3) 的正态分布。","text_tokens":["开源","到位","normal","做法","配置","左图","假设","检查","强大","算出","无论如何","conda","下面","/","恢复","对应","符合","官方","难以","教程","{","两个","world","print","条件","3","所","文件","要求","提供","而言","自行","包是","说明","开始菜单","并","9","较长","program","两种","处理","分布","节","执行","pil","12","^","你","是因为","版本","（","过于","枉然","崩溃","社区","达到","存在","反映","写","情况","变量","library","手","patricksnape","visual","测试","它","不","vs","不断","更新","管理员","sess","注意","很小","一段","依照","高时","撰写","取消","后","fo40225","解决","内部","殊有","包都","和","python","我们","环境变","libx64","if","显卡","v10","sla","界面","涉及","屏幕","正态分布","bin","blob","support","添加","基于","总体","cudnn","tensorrt","不是","pip","与","信息","#","三个","7","取决","string","强制","一点","随机数","代码","要","首先","1000","driver","互不","12.0","opencv2","\\","1.12","win","所示","随机","cp36m","需要","文件夹","很","这","7.2","tensorflow","先",",","管理","9.0","=","低版","环境变量","import","尽管","版本号","驱动","危险","mathcal","集成","因为","一般","了","安装包","test","摘要","总结","当","那么","第一次","如果","对比","发行版","当前","鉴于","最新版","用法","按照","针对","不再","项目","差距","10.0","载有","预装","新于","形式","com","以","方法","下载","应已","411.31","本地","比","file","都",")","转换","应当","导致","给","不过","离线","部分","大多数","令","这里","所以","并非","lib","https","推荐","编译","并且","将","[","问题","命令","最","过时","接下","]","2.4","定制","是否","1","引导","所有","python3","翻新","初始化","方案","保存","指南","多数","更","提示","适合","amd64","得到","master","一定","cuda","目录","这部","选项","prompt","进行","b","一个","选择","压缩包","发行","完成","图标","其中","运行","由于","binary","1948.6578","关闭","新版","也","闪烁","低版本","截至","确定","包括","库","多","官网",">","10","!","指出","妨害","虚","影响","r1","在","流程","会","示例","硬件","如何","那样","之外","查看","菜单","通过","current","nvidia","对于","停留","作为","能否","相互","下来","run","就是","重启","繁琐","其他","建议","cal","推算","指导","及","段时间","第三","支持","可能","预","取决于","5","记录",".","”","哪怕","─","py36","直接","数次","模式","extras","维护者","name"," ","总体而言","自动","h","¶","random","该","则","读者","路径","version","正常","造成","步骤","'","）","为止","初始","session","工作","py","上","computing","进入","时间","以后","2","相配","结果","理论","activate","导致系统","用户","等待","设置","include","gpu","须知","摸索","时","测试程序","上述","基","calculation","8","显示","前","studio","件夹","cp36","是","但","专门","覆盖","像","好","主","anaconda","之前","__","constant","环境","根据","with","结束","图","大多","然而","开始","之后","压缩","个","hello","目的","0","三条","机数","path","_","n","不够","就","例如","开启","，","6","拷贝","系统","实际","早","但是","在线","经过","opencv3","install","库中","没有","│","由此","自带","geforce","(","第一","wheel","文档","10.1","维护","}","图像处理","├","点击","以免","如下","有","experience","c++","简易","main","as","现在","4.4","独立","或","接下来","可以","正确","以上","“","特别","github","确保","出错","以下","sum","本","过程","服从","第一步","最新","7.3","打开","将会","系统目录","而","x64","readme","使用","已然","str","包含","电脑","引发","机器","对","这一","行为","链接","4","还","考虑","dll","txt","-","如","相关","不同","cuda100cudnn73sse2","包","基础","出","中预","forge","具有","中","toolkit","第三个","无法","程序","reduce","从","匹配","任何","第一个","cupti","同时",":","有些","除此","is","output","：","请","愿意","观察","特性","的","c","源码","除此之外","完","这种","一次","本身","create","nccl","即可","。","出现","后续","opencv","编写","干扰","一段时间","版","cudnn64","推算出","一步","tf","8.1","之","尝试","该项","几个","因此","这样","无论","解压","已经","windows","这部分","键入","主要","whl","选用","能","大致","时候","下","到","右图","自己","图像","└","看到","容易","笔者","出厂","里","安装","files","免费"],"title":"Hello world!","title_tokens":["world","!","hello"," "]},{"location":"book-1-x/chapter-1/hello-world/#hello-world","text":"摘要 本节包含一个简易的安装指导，主要提供给Windows上的GPU用户。之后，用户可以按照本节指导编写第一个测试程序。","text_tokens":["简易","测试程序","的","一个","，"," ","节","可以","windows","主要","给","摘要","。","本","编写","上","程序","指导","第一","按照","之后","包含","第一个","测试","安装","用户","提供","gpu"],"title":"Hello world!","title_tokens":["world","!","hello"," "]},{"location":"book-1-x/chapter-1/hello-world/#tensorflow","text":"本节针对Windows使用GPU的用户，提供一个安装最新版Tensorflow的方法。大致的步骤符合以下两个教程： 通过pip安装Tensorflow Tensorflow的GPU支持 但是，需要指出的是，官方教程里有些部分已经不符合当前用户的实际情况，笔者经过摸索，总结以下的安装过程。 总体而言，安装Tensorflow需要用户确保以下条件 NVIDIA驱动已经达到411.31及以上 CUDA 10.0 (10.1不确定能否正常使用) CUDNN已经达到7.3.1及以上 CUPTI版本与CUDA相配（不需要专门安装，在安装CUDA的同时已经自动集成） 除此之外，涉及多GPU支持的库(NCCL和TensorRT)，这里不考虑。因此，我们主要需要确保前三条正常安装。 提示 Tensorflow官方提供的安装包是基于CUDA 9.0，CUDNN >= 7.2的基础上编译的。然而现在NVIDIA已经不再提供CUDA 9.0了。Windows用户可以安装的版本包括过时的8.1和最新的10.1。在这种情况下，官方还提供一个令用户自行从源码编译Tensorflow库的方案，但是对于Windows用户而言过于繁琐，容易出错，这里不建议按照官方教程。","text_tokens":["=","现在","驱动","之外","通过","可以","nvidia","集成","对于","以上","能否","了","安装包","确保","出错","总结","以下","本","过程","繁琐","符合","官方","建议","最新","当前","7.3","最新版","及","支持","按照","针对","教程","不再","使用","两个","10.0","条件",".","提供","而言","自行","方法","411.31","还","考虑"," ","总体而言",")","节","自动","基础","正常","步骤","版本","）","（","部分","过于","令","达到","上","这里","情况","从","相配","同时","cupti","编译","有些","除此","不","用户","：","gpu","摸索","的","源码","除此之外","过时","前","这种","是","专门","1","nccl","。","和","我们","涉及","然而","方案","提示","基于","总体","cudnn","tensorrt","8.1","pip","三条","与","cuda","一个","，","因此","已经","实际","windows","但是","主要","经过","新版","大致","确定","包括","下","库","需要","(","多",">","10.1","指出","容易","笔者","在","里","安装","tensorflow","7.2","9.0"],"title":"安装Tensorflow","title_tokens":["安装","tensorflow"]},{"location":"book-1-x/chapter-1/hello-world/#nvidia","text":"首先，我们可以开始更新我们的NVIDIA驱动。任何载有NVIDIA-GPU显卡的电脑，都应当在系统里已经预装好了 GeForce Experience 。点击如下图标开启GeForce Experience（如果是低版本的GeForce Experience，图标可能会不同）， 如左图，在主界面上，可以观察到，当驱动版本不够高时，会自动出现更新提示，依照提示更新即可。建议在更新驱动时，关闭其他所有程序，以免造成干扰。 更新NVIDIA driver 检查更新结果 如果更新完成，如右图，可以在设置界面检查到当前的版本已经达到最新。在安装过程中，由于驱动更新，屏幕可能会闪烁数次。在看到更新提示完成后建议重启。 提示 如果GeForce Experience提示无法更新驱动，可以考虑将机器恢复出厂设置，可能可以解决这一问题。","text_tokens":["低版","驱动","可以","nvidia","左图","检查","了","当","重启","恢复","如果","过程","其他","建议","最新","当前","可能","电脑","载有","预装","机器","这一","数次","考虑","-","都","如"," ","不同","自动","应当","造成","版本","）","（","中","无法","达到","上","程序","任何","结果","将","设置","gpu","问题","观察","时","更新","的","依照","高时","是","后","即可","好","主","解决","。","出现","我们","所有","显卡","界面","开始","干扰","屏幕","提示","不够","开启","，","完成","首先","图标","driver","系统","已经","由于","关闭","闪烁","低版本","geforce","到","右图","看到","点击","在","以免","出厂","如下","里","experience","安装","会"],"title":"更新NVIDIA驱动","title_tokens":["nvidia","驱动","更新"]},{"location":"book-1-x/chapter-1/hello-world/#cuda","text":"驱动更新并重启后，需要安装最新版的Visual Studio(VS)，这是因为CUDA库本身对VS具有一定的支持，如果先安装CUDA，则这部分支持无法安装到位。这对我们使用Tensorflow并不造成妨害，但是对CUDA的用户并不是一个推荐的做法，所以无论如何，建议在第一步，安装VS，下面提供VS社区版（免费）的链接： Visual Studio官网 接下来，可以开始安装CUDA。进入CUDA安装包的下载链接 下载最新版CUDA CUDA官方指南 提示 须知，并非最新版就是最适合的版本。实际能使用的CUDA版本取决于后续步骤中预编译包的支持版本。就笔者写到这里时，最新的CUDA 10.1已然不匹配最新版预编译包支持的CUDA 10.0，由于版本差距很小，不确定是否会由此引发问题，但读者可以自行尝试。 现在的安装包已经支持在线安装包和离线安装包两种模式，读者可以根据自己的实际情况选择对应的版本。注意，安装CUDA的时候，CUDA可能要求我们翻新驱动版本，但通过GeForce Experience安装的驱动一般应已达到最新，新于CUDA内部提供的驱动。因此，我们需要选择定制安装模式，根据我们需要对比版本号，将驱动更新的选项取消，如下图所示 安装CUDA后，建议重启。 危险 特别需要注意的是，如果你的机器无法通过GeForce Experience更新驱动，那么在这里选择安装驱动也是枉然。并且，这种强制更新驱动的行为很可能导致系统崩溃。因此特别建议在安装CUDA之前一定要解决驱动更新的问题，哪怕是通过恢复出厂设置。","text_tokens":["如何","现在","版本号","驱动","危险","到位","接下来","通过","做法","可以","因为","一般","特别","安装包","下来","无论如何","就是","下面","那么","重启","恢复","如果","对比","对应","第一步","官方","建议","最新","最新版","支持","可能","使用","已然","预","差距","10.0","取决于","引发","要求","对","新于","提供","机器","自行","行为","哪怕","应已","下载","并","链接","模式","两种"," ",")","包","中预","导致","具有","则","读者","你","造成","是因为","版本","步骤","）","离线","（","部分","枉然","崩溃","社区","无法","达到","这里","所以","写","进入","情况","并非","匹配","推荐","visual","编译","并且","将","不","vs","导致系统","用户","设置","：","须知","问题","时","更新","的","最","注意","很小","接下","studio","这种","是","但","取消","本身","后","定制","是否","解决","内部","之前","。","后续","和","我们","根据","图","翻新","开始","指南","版","提示","一步","不是","尝试","适合","一定","cuda","取决","这部","选项","就","强制","一个","选择","，","要","因此","无论","已经","系统","实际","由于","这部分","但是","在线","新版","也","能","所示","时候","确定","由此","库","需要","geforce","到","(","第一","自己","官网","10.1","很","妨害","笔者","在","出厂","这","如下","experience","安装","tensorflow","先","会","免费"],"title":"安装CUDA","title_tokens":["安装","cuda"]},{"location":"book-1-x/chapter-1/hello-world/#cudnn","text":"安装CUDA的同时，已经自带安装上了CUPTI。但是CUDNN并没有包含在CUDA中，因此，我们需要到以下链接下载CUDNN并查看安装说明 下载最新版CUDNN CUDNN官方指南 不同的是，CUDNN没有安装包，是以压缩包的形式下载到本地。解压后，其中应当包含如下目录及文件 . └─ cuda/ ├─ bin/ # Binary library │ └─ cudnn64_7.dll ├─ include/ # C++ Include file │ └─ cudnn.h ├─ lib/ # C++ Lib file │ └─ x64/ │ └─ cudnn.lib └─ NVIDIA_SLA_cuDNN_Support.txt # Readme file 假设我们CUDA的安装目录在 C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v10.0 ，将上述解压的 bin , include 和 lib 三个文件夹，直接拷贝覆盖到该安装目录下，即可完成CUDNN的安装。 进行完上述步骤后，我们还需要确保几个环境变量正确设置： 存在 CUDA_PATH=C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v10.0 ，是我们的安装目录。理论上在CUDA安装后，该目录已经自动设置好。 环境变量 PATH 中，存在 C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v10.0/bin , C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v10.0/extras/CUPTI/libx64 两个路径，由于CUDNN已经配置在CUDA安装目录下，我们不需要像官方文档那样，添加第三个CUDNN的安装路径。","text_tokens":["=","环境变量","那样","查看","nvidia","配置","正确","假设","了","安装包","确保","以下","/","官方","最新","最新版","及","第三","x64","readme","两个","包含","文件",".","形式","─","以","说明","下载","本地","并","链接","还","直接","extras","program","dll","file","txt"," ","不同","自动","h","应当","该","路径","步骤","中","toolkit","第三个","上","computing","存在","变量","lib","library","理论","同时","cupti",":","将","不","设置","include","：","gpu","上述","的","c","完","件夹","是","后","覆盖","像","即可","好","。","和","我们","环境","环境变","libx64","v10","sla","指南","cudnn64","bin","support","添加","cudnn","压缩","0","几个","#","三个","7","path","cuda","_","目录","进行","压缩包","，","因此","解压","拷贝","完成","已经","其中","由于","binary","但是","新版","没有","│","下","自带","需要","到","文档","文件夹","└","├","在","如下","安装","files","c++",","],"title":"安装CUDNN","title_tokens":["安装","cudnn"]},{"location":"book-1-x/chapter-1/hello-world/#anaconda","text":"Windows用户建议使用Anaconda管理python环境。作为一个开源的项目，Anaconda发行版已经集成了我们所需要的大多数python包，其中有些包是我们自己难以安装上的，例如支持python3的PIL。我们选用python3版的Anaconda，下载路径如下： Anaconda 最新版下载链接 注意选择x64版的安装包。安装结束后，我们已经有python3.7的环境了。鉴于有些情况下我们可能需要使用更早的python版本，接下来我们可以安装python3.6的虚环境。 Anaconda可以安装在用户或系统目录下。注意，如果安装在系统目录下，如果不在虚环境下，安装任何包都需要管理员模式。不过这不影响本教程的示例，因为我们将安装虚环境。直接打开 Anaconda Prompt ，并键入以下命令： conda create -n py36 python = 3 .6 anaconda 按照引导流程安装，经过一段时间后，我们将得到python3.6版的Anaconda。以后我们可以直接从开始菜单 Anaconda Prompt (py36) 进入该虚环境，也可以在基环境中键入 activate py36 转换到虚环境中。 提示 如果用户愿意，还可以通过 conda install -c conda-forge opencv 安装 opencv 。opencv是一个强大的图像处理库，这里python版的opencv比C++版更容易上手。一般该命令安装的是conda库中最新版的opencv（截至笔者写到这里时是opencv3.4.4）。然而，这样安装的并非是支持GPU的版本。尽管conda还提供一个GPU的opencv版本，可以通过 conda install -c patricksnape opencv-gpu 安装 opencv2 ，但它的版本还停留在2.4.9，和opencv3的用法殊有不同，请读者注意这一点。","text_tokens":["开源","=","尽管","4.4","菜单","或","接下来","通过","可以","集成","因为","一般","停留","作为","强大","了","安装包","下来","conda","以下","如果","本","建议","发行版","最新","鉴于","最新版","打开","段时间","系统目录","难以","支持","可能","x64","按照","教程","用法","使用","项目","3","所",".","提供","包是","开始菜单","下载","链接","并","py36","还","直接","模式","比","9","处理","-"," ",")","不同","pil","包","转换","forge","该","路径","读者","版本","不过","）","（","大多数","中","上","这里","写","情况","进入","并非","时间","从","以后","任何","手","patricksnape","有些","将","activate","不","它","用户","：","gpu","请","愿意","时","命令","基","的","c","管理员","注意","一段","接下","是","但","2.4","后","create","anaconda","殊有","引导","。","包都","python","和","环境","我们","python3","opencv","结束","大多","开始","然而","一段时间","版","多数","更","提示","得到","7","目录","prompt","n","例如","一个","选择","一点","发行","6","，","这样","已经","系统","其中","windows","键入","opencv2","经过","opencv3","install","库中","选用","新版","也","截至","下","库","需要","到","(","自己","图像","虚","容易","影响","图像处理","笔者","在","这","如下","有","流程","安装","c++","示例","管理","早"],"title":"安装Anaconda","title_tokens":["安装","anaconda"]},{"location":"book-1-x/chapter-1/hello-world/#tensorflow_1","text":"我们可以查看如下项目： fo40225/tensorflow-windows-wheel 该项目的维护者在不断根据Tensorflow的更新，预编译出适合不同版本的Tensorflow安装包。截至笔者写到这里为止，最新支持到r1.12版。我们选择对应的GPU版Tensorflow，并在虚环境下执行以下命令： pip install https://github.com/fo40225/tensorflow-windows-wheel/blob/master/1.12.0/py36/GPU/cuda100cudnn73sse2/tensorflow_gpu-1.12.0-cp36-cp36m-win_amd64.whl 等待一段时间后，安装将会结束。","text_tokens":["查看","可以","安装包","github","以下","/","对应","最新","将会","段时间","支持","项目","预",".","com","并","py36","维护者","-"," ","不同","执行","cuda100cudnn73sse2","12","出","版本","为止","这里","写","时间","https","编译",":","等待","不断","：","gpu","命令","更新","的","一段","cp36","后","fo40225","。","我们","环境","根据","结束","一段时间","版","blob","目的","pip","适合","0","master","该项","amd64","_","选择","，","windows","whl","install","1.12","win","截至","下","cp36m","到","wheel","维护","虚","笔者","r1","在","如下","安装","tensorflow"],"title":"安装预编译好的Tensorflow","title_tokens":["预","的","编译","安装","tensorflow","好"]},{"location":"book-1-x/chapter-1/hello-world/#hello-world_1","text":"撰写如下代码，保存到 hello-world.py 文件， Python 1 2 3 4 5 6 7 8 9 if __name__ == '__main__' : import tensorflow as tf test_str = tf . constant ( 'Hello, world!' ) test_cal = tf . reduce_sum ( tf . random_normal ([ 1000 , 1000 ])) with tf . Session () as sess : print ( 'Current Tensorflow version is:' , tf . __version__ ) print ( 'Test string: ' , sess . run ( test_str )) print ( 'Test calculation:' , sess . run ( test_cal )) Output Current Tensorflow version is: 1 .12.0 Test string: b 'Hello, world!' Test calculation: -1948.6578 在保存目录下，执行 python hello-world.py 第一次运行可能需要等待较长的初始化时间（硬件配置）。如果能正常运行，我们将看到如下结果： 其中，显示结果之前的记录信息反映了GPU已经可以正常工作。而“Test calculation”显示的结果是 10^6 10^6 个服从 \\mathcal{N}(0,1) \\mathcal{N}(0,1) 分布的随机数之和。根据相互独立的随机正态分布互不相关的特性，我们可以推算出，该结果服从 \\mathcal{N}(0,10^3) \\mathcal{N}(0,10^3) 的正态分布。","text_tokens":["main","=","as","import","独立","mathcal","normal","current","可以","配置","算出","了","相互","test","run","第一次","sum","如果","服从","cal","推算","而","可能","{","str","world","print","3","文件","5","记录",".","”","4","9","较长","分布","-","name","相关"," ",")","执行","random","该","version","^","初始","'","正常","）","（","session","工作","py","反映","reduce","时间","2","结果",":","is","output","将","等待","[","：","gpu","calculation","特性","的","sess","8","显示","撰写","是","]","一次","1","__","constant","之前","。","python","和","我们","根据","if","with","初始化","保存","正态分布","推算出","tf","个","之","hello","0","信息","7","机数","目录","_","string","n","b","随机数","代码","6","，","1000","已经","其中","运行","互不","12.0","1948.6578","\\","能","随机","下","需要","到","(","第一","10","!","看到","}","在","如下","tensorflow",",","硬件","“"],"title":"Hello world! 测试","title_tokens":["world","测试","hello"," ","!"]},{"location":"book-1-x/chapter-1/linear-classification/","text":"线性分类 ¶ 摘要 本节介绍如何使用顺序模型(sequential model)来编写一个线性分类器，使用sigmoid函数激活，并验证其效果。 理论 ¶ 问题描述 ¶ 考虑我们有如下的二分类数据集 (\\mathbf{x},~y_i) \\in \\mathbb{D}_i (\\mathbf{x},~y_i) \\in \\mathbb{D}_i ，并且有一个未知的常数向量 \\mathbf{a}_i \\mathbf{a}_i 和未知的常数标量 c_i c_i ，使得： \\begin{equation} y_i = \\left\\{ \\begin{aligned} 0, && \\mathbf{a}_i^T \\mathbf{x} + c_i \\leqslant 0, \\\\ 1, && \\mathbf{a}_i^T \\mathbf{x} + c_i > 0. \\end{aligned} \\right. \\end{equation} 其中， \\mathbf{a} \\mathbf{a} 可以看成是某超平面的（未标准化的）法向量，那么 \\mathbf{a}^T \\mathbf{x} + c = 0 \\mathbf{a}^T \\mathbf{x} + c = 0 是该超平面的截距式定义，亦即该平面与 x_i x_i 轴的交点可以显式表述为 x_i^{(0)} = - \\frac{c}{a_i} x_i^{(0)} = - \\frac{c}{a_i} 。由此可知，式 (1) (1) 显式定义了一个点在超平面的哪一侧。特别地，若 \\mathbf{x} \\mathbf{x} 是一个二维向量，则该超平面退化为一维平面；若 \\mathbf{x} \\mathbf{x} 是一个标量，则该超平面退化为一条直线。 若我们定义 (\\mathbf{x},~\\mathbf{y}) \\in \\mathbb{D} (\\mathbf{x},~\\mathbf{y}) \\in \\mathbb{D} ，有 \\begin{equation} \\mathbf{y} = \\begin{bmatrix} y_1 \\\\ y_2 \\\\ \\vdots \\\\ y_n \\end{bmatrix}, ~~ \\mathbf{A} = \\begin{bmatrix} \\mathbf{a}^T_1 \\\\ \\mathbf{a}^T_2 \\\\ \\vdots \\\\ \\mathbf{a}^T_n \\end{bmatrix}, ~~ \\mathbf{c} = \\begin{bmatrix} c_1 \\\\ c_2 \\\\ \\vdots \\\\ c_n \\end{bmatrix}. \\end{equation} 则我们可以认为 \\begin{align} \\mathbf{y} = \\left\\{ \\begin{bmatrix}\\hat{y}_1 > 0 & \\hat{y}_2 > 0 & \\cdots & \\hat{y}_n > 0\\end{bmatrix}^T, ~ \\left| ~ \\hat{\\mathbf{y}} = \\mathbf{A} \\mathbf{x} + \\mathbf{c} + \\boldsymbol{\\varepsilon} \\right. \\right\\}, \\end{align} 其中 \\boldsymbol{\\varepsilon} \\boldsymbol{\\varepsilon} 是一个定义噪声的向量。 我们可以把向量 \\mathbf{y} \\mathbf{y} 的元素看成是互不相关的多个超平面对向量 \\mathbf{x} \\mathbf{x} 各自独立的分类结果。即 y_i = \\{ \\hat{y}_i>0 ~ | ~ \\hat{y}_i = \\mathbf{a}_i^T \\mathbf{x} + c_i + \\varepsilon_i \\} y_i = \\{ \\hat{y}_i>0 ~ | ~ \\hat{y}_i = \\mathbf{a}_i^T \\mathbf{x} + c_i + \\varepsilon_i \\} 。由于每个超平面构成一个二分类，如果把每个二分类看作是向量是否属于这个类的测度，那么 \\mathbf{y} \\mathbf{y} 可以被看作是一个多分类的结果，尽管向量 \\mathbf{x} \\mathbf{x} 可能被同时分入多个类中。 假设我们的数据集 (\\mathbf{x},~\\mathbf{y}) \\in \\mathbb{D} (\\mathbf{x},~\\mathbf{y}) \\in \\mathbb{D} 符合 (3) (3) 定义的数据分布特征。我们的基本要求是，在我们不知道 \\mathbf{A},~\\mathbf{c} \\mathbf{A},~\\mathbf{c} 的情况下，使用大量 (\\mathbf{x}^{(k)},~\\mathbf{y}^{(k)}) \\in \\mathbb{D} (\\mathbf{x}^{(k)},~\\mathbf{y}^{(k)}) \\in \\mathbb{D} 样本训练一个线性分类器，使得当我们给定任意一个新样本 \\mathbf{x} \\mathbf{x} 的时候，分类器能推断出其对应的 \\mathbf{y} \\mathbf{y} 来（亦即是否属于该分类）。 在这个问题里，我们虽然不知道 \\mathbf{A},~\\mathbf{c} \\mathbf{A},~\\mathbf{c} ，但我们知道由 (3) (3) 确定的线性关系，因此，我们可以随机生成一组 \\mathbf{W},~\\mathbf{b} \\mathbf{W},~\\mathbf{b} ，构建线性模型： \\begin{align} \\tilde{\\mathbf{y}} = \\sigma ( \\mathbf{W} \\mathbf{x} + \\mathbf{b} ). \\end{align} 其中，可微函数 \\sigma \\sigma 是一个将实数空间 \\mathbb{R}^n \\mathbb{R}^n 映射到有限范围的实数空间 [0,~1]^n [0,~1]^n 内的函数。特别地， \\sigma(-\\infty)=0,~\\sigma(0)=0.5,~\\sigma(+\\infty)=1 \\sigma(-\\infty)=0,~\\sigma(0)=0.5,~\\sigma(+\\infty)=1 。因此，可以将 \\sigma \\sigma 看作是二分类布尔函数的插值函数。理论上，只要我们找到 \\mathbf{W}=\\mathbf{A} \\mathbf{W}=\\mathbf{A} ， \\mathbf{b}=\\mathbf{c} \\mathbf{b}=\\mathbf{c} ，则该线性分类器可以直接拟合出原分布来。 感知机 ¶ 我们将 (4) (4) 定义的线性模型称为 单层感知机 (Single-layer perceptron) 模型。它包含一个权重矩阵 \\mathbf{W} \\mathbf{W} 和一个偏置矩阵 \\mathbf{b} \\mathbf{b} 。事实上，可以将 (4) (4) 改写成如下形式 \\begin{align} \\tilde{\\mathbf{y}} = \\sigma \\left( \\begin{bmatrix} \\mathbf{W} & \\mathbf{b} \\end{bmatrix} \\begin{bmatrix} \\mathbf{x} \\\\ 1 \\end{bmatrix} \\right). \\end{align} 可见偏置本身可以看成是输入向量多了一个常数元素的等价模型。 感知机是最早的神经网络形式，它非常孱弱，只能解线性问题，但却为神经网络后来的发展开了先河。在单层感知机里，我们视输入向量 \\mathbf{x} \\mathbf{x} 的每个元素为一个“神经元”，矩阵 \\mathbf{W} \\mathbf{W} 和偏置 \\mathbf{b} \\mathbf{b} 将我们的输入映射到输出层 \\mathbf{y} \\mathbf{y} ，输出层的每个元素也视为一个神经元。在这个过程中， W_{ij} W_{ij} 作为 i i 行 j j 列的元素，代表了连接两个神经元的权重。我们用红线代表正值，蓝线代表负值，感知机可以被图示为 线性感知机的输出也是输入的线性组合，但我们可以添加激活函数，即 \\sigma(\\cdot) \\sigma(\\cdot) 将其映射到非线性空间。这要求我们添加的激活函数是一个非线性函数。 事实上，将单层感知机层叠，前一层的输出作为后一层的输入，就构建出早期的神经网络。这种网络每一层都是全连接的（两个神经元之间总是有权重，尽管值可能为0），每一层都有激活函数。理论上，任意一个两层堆叠的感知机，只要神经元数目足够多，就可以拟合出任意一个非线性函数。然而，实际测试中，这一理论的效果并不尽如人意，因此又有陆续地改进，才有了后来的深度学习。饮水思源，鉴往知来，我们也将从这个简简单单的单层模型开始，走上学习“深度学习”之旅。 Sigmoid函数 ¶ 在上述介绍中，我们没有解决的两个问题是， 如何定义插值函数 \\sigma \\sigma ？ 如何找到合适的 \\mathbf{W},~\\mathbf{b} \\mathbf{W},~\\mathbf{b} ？ 我们首先讨论第一个问题。一般地，多分类问题中，如果各个分类彼此并非相斥，且不一定要将结果分入任一类的话，我们可以用 Sigmoid 函数来定义 \\sigma \\sigma ，亦即 \\begin{align} \\sigma(\\mathbf{x}) = \\frac{1}{ 1 + e^{-\\mathbf{x}}}. \\end{align} 它同时满足 \\sigma(-\\infty)=0,~\\sigma(0)=0.5,~\\sigma(+\\infty)=1 \\sigma(-\\infty)=0,~\\sigma(0)=0.5,~\\sigma(+\\infty)=1 ，且是一个单调函数。以下代码向我们展示了这种函数的特性： Python 1 2 3 4 5 6 7 8 9 10 11 12 import numpy as np import matplotlib.pyplot as plt def test_sigmoid (): x = np . linspace ( - 5 , 5 , 100 ) y = 1 / ( 1 + np . exp ( - x ) ) plt . plot ( x , y ) plt . xlabel ( 'x' ), plt . ylabel ( 'y' ) plt . gcf () . set_size_inches ( 5 , 5 ), plt . show () if __name__ == '__main__' : test_sigmoid () Output 使用sigmoid函数的一大好处是，它的导数求解非常简单，很适合用来做神经网络这样一个复杂模型的激活函数。注意虽然 \\sigma(\\mathbf{x}) \\sigma(\\mathbf{x}) 和 \\mathbf{x} \\mathbf{x} 都是向量，这意味着导数是Jacobian矩阵，但由于 \\sigma \\sigma 是一个对 \\mathbf{x} \\mathbf{x} 各元素独立的解析函数，这个Jacobian矩阵实际上是一个对角矩阵，对角线上第j个元素的值为 \\begin{align} \\left. \\frac{ \\partial \\sigma(x) }{ \\partial x } \\right|_{x=x_j} = \\left. - e^{-x} \\left( - \\frac{1}{\\left( 1+e^{-x} \\right)^2} \\right) \\right|_{x=x_j} = - \\sigma(x_j) \\sigma(1 - x_j). \\end{align} 可见，该函数的导数和计算函数本身的复杂度相若，可以做到快速求导。 求解问题 ¶ 接下来，我们需要解决第二个问题，亦即找到 \\mathbf{W},~\\mathbf{b} \\mathbf{W},~\\mathbf{b} 。这一问题通常可以写成反问题的形式： \\begin{align} \\arg \\min_\\limits{\\mathbf{W},~\\mathbf{b}} \\sum_{k=1}^N \\mathcal{L} \\left( \\mathbf{y}^{(k)},~ \\sigma ( \\mathbf{W} \\mathbf{x}^{(k)} + \\mathbf{b} ) \\right). \\end{align} 最简单的情况下，我们可以把 损失函数(loss function) 定义为 \\begin{align} \\mathcal{L} \\left( \\mathbf{y},~ \\tilde{\\mathbf{y}} \\right) = \\lVert \\mathbf{y} - \\tilde{\\mathbf{y}} \\rVert_2^2. \\end{align} 我们称 (8) (8) 为 逻辑斯蒂回归(logistic regression) 。有趣的是，虽然这个术语叫“回归”，但它解的其实是个分类问题。但是，既然这是一个分类问题，我们可以不使用这个损失函数，而是从概率论的角度看待这个问题。由此，我们引出一个新的损失函数：“交叉熵”。 交叉熵 ¶ 我们视sigmoid函数输出的值为一个概率，表示分类器对预测结果的确信程度，记 \\mathbf{W},~\\mathbf{b} \\in \\boldsymbol{\\Theta} \\mathbf{W},~\\mathbf{b} \\in \\boldsymbol{\\Theta} ，则 \\begin{equation} \\begin{aligned} \\mathbf{p}(y_i=1|\\mathbf{x};~\\boldsymbol{\\Theta}) &= \\sigma(\\mathbf{x};~\\boldsymbol{\\Theta}), \\\\ \\mathbf{p}(y_i=0|\\mathbf{x};~\\boldsymbol{\\Theta}) &= 1 - \\sigma(\\mathbf{x};~\\boldsymbol{\\Theta}). \\end{aligned} \\end{equation} 注意这里的概率向量的含义是，其中第i个元素表明第i个超平面分类结果的确信程度。 然而，这个概率只是分类器对分类结果的确信程度，却并非是分类准确度的概率，实际上，分类准确度的概率，应当表述为 \\begin{equation} \\begin{aligned} \\mathbf{p}(\\mathbf{y}|\\mathbf{x};~\\boldsymbol{\\Theta}) &= \\mathbf{p}(y_i=1|\\mathbf{x};~\\boldsymbol{\\Theta})^{\\mathbf{y}} \\mathbf{p}(y_i=0|\\mathbf{x};~\\boldsymbol{\\Theta})^{1-\\mathbf{y}}\\\\ &= \\sigma(\\mathbf{x};~\\boldsymbol{\\Theta})^{\\mathbf{y}} \\left(1 - \\sigma(\\mathbf{x};~\\boldsymbol{\\Theta}) \\right)^{1-\\mathbf{y}}. \\end{aligned} \\end{equation} 注意 这里 \\mathbf{x}^{\\mathbf{y}} \\mathbf{x}^{\\mathbf{y}} 表示的是对每个元素一一求取指数，即函数第i个元素的返回值应当为 {x_i}^{y_i} {x_i}^{y_i} 。 我们使用真实值 \\mathbf{y} \\mathbf{y} 作为指数给概率向量加权。当 \\mathbf{y}=1 \\mathbf{y}=1 时，以预测值为1的可信度作为概率；反之则以预测值为0的可信度作为概率。这就是最大似然估计方法。至此，我们可以写出似然估计函数 \\begin{align} L(\\boldsymbol{\\Theta}) = \\mathbf{p}(\\mathbf{y}^{(k)}|\\mathbf{x}^{(k)};~\\boldsymbol{\\Theta}). \\end{align} 对似然估计函数取对数，则有 \\begin{equation} \\begin{aligned} l(\\boldsymbol{\\Theta}) &= \\sum_{k=1}^N \\log \\left( \\mathbf{p}(\\mathbf{y}^{(k)}|\\mathbf{x}^{(k)};~\\boldsymbol{\\Theta}) \\right) \\\\ &= \\sum_{k=1}^N \\mathbf{y}^{(k)} \\cdot \\log\\left(\\sigma(\\mathbf{x}^{(k)};~\\boldsymbol{\\Theta})\\right) + \\left(1 - \\mathbf{y}^{(k)} \\right) \\cdot \\log\\left(1 - \\sigma(\\mathbf{x}^{(k)};~\\boldsymbol{\\Theta})\\right). \\end{aligned} \\end{equation} 我们最终的目的是要最大化似然函数，亦即 \\mathbf{W},~\\mathbf{b} = \\arg\\max\\limits_{\\boldsymbol{\\Theta}} l(\\boldsymbol{\\Theta}) \\mathbf{W},~\\mathbf{b} = \\arg\\max\\limits_{\\boldsymbol{\\Theta}} l(\\boldsymbol{\\Theta}) ，这等价于最小化 -l(\\boldsymbol{\\Theta}) -l(\\boldsymbol{\\Theta}) 。对比 (8) (8) 和 (9) (9) ，于是我们可以定义交叉熵为 \\begin{align} \\mathcal{L} \\left( \\mathbf{y},~ \\tilde{\\mathbf{y}} \\right) = \\mathbf{y} \\cdot \\log\\left( \\tilde{\\mathbf{y}} \\right) + \\left(1 - \\mathbf{y} \\right) \\cdot \\log\\left(1 - \\tilde{\\mathbf{y}} \\right). \\end{align} 若我们记 \\tilde{\\mathbf{y}} = \\sigma(\\tilde{\\mathbf{x}}) \\tilde{\\mathbf{y}} = \\sigma(\\tilde{\\mathbf{x}}) ，代入sigmoid函数，为了确保该损失函数的稳定性，我们可以将 (14) (14) 整理为 \\begin{align} \\mathcal{L} \\left( \\mathbf{y},~ \\tilde{\\mathbf{x}} \\right) = \\max(\\tilde{\\mathbf{x}}, \\mathbf{0}) - \\tilde{\\mathbf{x}} \\cdot \\mathbf{y} + \\log\\left(1 + e^{-|\\tilde{\\mathbf{x}}|} \\right). \\end{align} 提示 这里交叉熵整理的推导过程参见 Tensorflow-API官方文档 。 实际情况下，我们使用 (15) (15) 来求取sigmoid函数激活下的交叉熵。 解线性多分类问题 ¶ 代码规范 ¶ 建立一个具有较强可读性的Tensorflow工程需要我们活用python的模块化设计。我们通常推荐以下的结构 . ├─ data/ # where we store our data │ └─ ... ├─ tools.py # codes for post-processing and analyzing records. ├─ extension.py # codes for extending the tensorflow model. ├─ dparser.py # data parser └─ main.py # main module where we define our tensorflow model. 除了保存数据的文件夹，我们应当有三个子模块。其中 tool : 用来处理、分析生成的数据，通常与Tensorflow无关； extension : 用来扩展tensorflow，例如在这里自定义网络层和操作符； dparser : 数据处理器，用来读取并预处理送入网络的数据； main : 主模块，只定义跟Tensorflow模型有关的内容，需要引用 extension 和 dparser 。 视情况可以灵活调整结构，但建议将定义Tensorflow模型的代码单独放在主模块里，和其他外围代码分离。 撰写各个模块时，建议使用类封装各组功能相同的函数。具有良好使用习惯的coder应当注意给各个面向用户的类、函数撰写（哪怕简短的）说明文字，在一些较长的函数、方法的定义中，适当注释各部分的功能，以便读者能正确理解代码意义。 另外，在对象命名上，python有如下必须遵守或不成文的规定，和C/C++用户熟悉的蛇形命名法不同，它大致包括 类与函数多用驼峰命名法，变量可以采用驼峰或蛇形命名法。 驼峰命名法指的是用大小写区分每个单词块，例如 alphaBetaFunction () ； 蛇形命名法指的是用下划线区分每个单词块，例如 alpha_beta_function = 10 ； 宏变量使用全字大写+蛇形命名法 函数/方法，还有模块均是首字母小写，但类的首字母大写。 用单下划线 _ 表示临时存储器，或省略参数，例如一个函数 func () 有两个返回值时，可以用 _ , b = func () 表示我们只需要第二个返回值；单下划线还可以与星号连用省略多个返回值； 以单下划线开头的方法，表示模块级的私有方法，在模块以外使用 import 导入类时，不会导入这些方法，例如 def _alphaBeta ( self ): ； 以单下划线结尾的对象，用来和python的关键字区分，例如 func ( x , class_ ) ; 以双下划线开头的方法，如果不以双下划线结尾，则表示类级的私有方法，只有类内部的方法能调用这些方法，在类外部、包括继承的子类里都原则上不能调用（但其实也有办法调用），例如 def _alphaBeta ( self ): ； 以双下划线同时开头和结尾的方法，一般是用来 重写 (override) 特殊功能，例如 def __getattribute__ (): 将重写获得类属性的方法。 数据生成 ¶ 在本项目里，我们不需要扩展Tensorflow。但是，我们需要以随机生成数据代替数据集。因此，首先，通过以下代码定义数据生成器 dparser.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class TestDataSet : ''' A generator of the data set for testing the linear model. ''' def __init__ ( self , scale_x , A , c ): ''' Initialize the data generator. scale_x: the scale of input vector. A, c: the linear transformation. ''' self . s_x = 2 * scale_x self . A = A self . c = c self . len_x = A . shape [ 0 ] self . config () def config ( self , train = True , batch = 100 , noise = 0.1 ): ''' Configuration train: a flag for controlling the iterator mode. batch: the number of samples in a batch noise: std. of the error added to the y. ''' self . train = bool ( train ) self . batch = batch self . noise = noise def next_train ( self ): ''' Get the next train batch: (x, y) ''' x = self . s_x * ( np . random . random ([ self . batch , self . len_x ]) - 0.5 ) y = np . matmul ( x , self . A ) + self . c if self . noise > 1e-3 : y = y + np . random . normal ( 0 , self . noise , size = y . shape ) y = np . greater ( y , 0.0 ) . astype ( np . float32 ) return x , y def next_test ( self ): ''' Get the next test batch x. ''' return self . s_x * ( np . random . random ([ self . batch , self . len_x ]) - 0.5 ) def __iter__ ( self ): while True : samp = self . __next__ () yield samp def __next__ ( self ): if self . train : return self . next_train () else : return self . next_test () 该生成器输入一组 \\mathbf{A},~\\mathbf{c} \\mathbf{A},~\\mathbf{c} ，以及相关配置，之后就可以通过 迭代器 (iterator) 或 方法 (method) 随机生成数据。这种数据集写法我们在后面还会用到， model . fit 允许我们不是馈入样本（或样本批次），而是馈入一个 生成器(generator) 。因此我们重写了 __iter__ 方法，并使其通过 yield 返回一个生成器。这样我们定义的数据集类就可以被Keras的训练函数 model . fit 使用。接下来，调用如下测试代码： dparser.py 1 2 3 4 5 6 7 8 9 10 def test_dataset (): A = np . random . normal ( 0 , 10 , [ 10 , 6 ]) c = np . random . uniform ( 1 , 3 , [ 1 , 6 ]) dataSet = TestDataSet ( 10 , A , c ) dIter = iter ( dataSet ) for i in range ( 10 ): x , y = next ( dIter ) print ( np . sum ( y , axis = 0 ) / 100 ) test_dataset () Output [ 0.47 0.57 0.58 0.56 0.5 0.38 ] [ 0.6 0.61 0.47 0.48 0.38 0.52 ] [ 0.5 0.61 0.49 0.42 0.45 0.53 ] [ 0.59 0.52 0.44 0.44 0.49 0.51 ] [ 0.54 0.59 0.48 0.5 0.51 0.47 ] [ 0.49 0.57 0.56 0.49 0.53 0.4 ] [ 0.5 0.61 0.51 0.54 0.51 0.52 ] [ 0.5 0.51 0.61 0.5 0.44 0.5 ] [ 0.44 0.46 0.53 0.45 0.56 0.52 ] [ 0.52 0.46 0.51 0.52 0.49 0.44 ] 我们随机生成了 \\mathbf{x} \\mapsto \\mathbf{y}:~\\mathbb{R}^{10} \\mapsto \\mathbb{R}^6 \\mathbf{x} \\mapsto \\mathbf{y}:~\\mathbb{R}^{10} \\mapsto \\mathbb{R}^6 的数据，每组数据100个，并且测试了10组。输出结果是各组测试中， \\mathbf{y} \\mathbf{y} 在对应维度上分类为1的概率估计。结果基本都在0.5左右，说明我们的这种数据生成模式产生的点能均匀分布在各个超平面两侧，适合进行后续测试。 定义线性顺序模型 ¶ 顺序(sequential) 模型是一个单输入单输出模型，网络结构较为简单，也不存在跨层短接（残差连接）。在大多数情况下，已经上手的Tensorflow用户不使用这个模型，故而作为我们入门的第一个project，我们姑且用之，但我们将不再使用顺序模型来实现后续的project。一个顺序模型大致可以描述为下图的模式： graph LR st(输<br/>入) --> l1[层<br/>1] l1 --> l2[层<br/>2] l2 --> l3[层<br/>3] l3 --> ldots[层<br/>...] ldots --> ed(输<br/>出) classDef styStart fill:#FAE6A9,stroke:#BA9132; class st,ed styStart 由于我们完成的是一个线性分类器，故而我们使用单层的序列模型即可。 接下来，我们来定义一个类， class LinClsHandle : 。定义一个类的时候，我们通常需要定义的内容包括 在初始化方法 __init__ 里定义传入网络的固定参数，例如学习速率，存取路径等； 在方法 construct 里定义网络的构造和使用的优化器； 在方法 train 里定义训练网络的过程，主要需要调用 model . fit 。如果我们在数据集的定义非常完善，则这一环节不需要花费太多的功夫； 在方法 test 里定义测试网络的过程，主要需要调用 model . evaluate 。如果有必要，可以通过 model . predict 返回测试结果。 初始化方法 ¶ 首先，定义初始化方法： lin-cls.py: class LinClsHandle 1 2 3 4 5 6 7 8 9 10 def __init__ ( self , learning_rate = 0.01 , epoch = 10 , steppe = 30 ): ''' Initialization and pass fixed parameters. learning_rate: the learning rate for optimizer. epoch: training epochs. steppe: steps per epoch ''' self . lr = learning_rate self . epoch = epoch self . steppe = steppe 由于目前我们的project还非常简单，这里只需要有学习速率( learning_rate )，轮次数( epoch )和每轮迭代次数( steppe )即可。 构造方法 ¶ 接下来定义网络构造 lin-cls.py: class LinClsHandle 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 def construct ( self ): ''' Construct a linear model and set the optimizer as Adam ''' # Construction self . model = tf . keras . Sequential () self . dense1 = tf . keras . layers . Dense ( LABEL_SHAPE , use_bias = True , input_shape = ( INPUT_SHAPE ,), kernel_initializer = tf . keras . initializers . RandomNormal ( 0.0 , stddev = 10.0 ), bias_initializer = tf . keras . initializers . Constant ( 2 ), activation = None ) self . model . add ( self . dense1 ) # Set optimizer self . model . compile ( optimizer = tf . train . AdamOptimizer ( self . lr ), loss = self . loss , metrics = [ self . accuracy ] ) @staticmethod def loss ( y_true , y_pred ): return tf . nn . sigmoid_cross_entropy_with_logits ( labels = y_true , logits = y_pred ) @staticmethod def accuracy ( y_true , y_pred ): return tf . keras . backend . mean ( tf . keras . backend . equal ( y_true , tf . keras . backend . round ( tf . keras . backend . sigmoid ( y_pred )))) 须知 这里 LABEL_SHAPE 和 INPUT_SHAPE 为两个宏变量，分别为输出和输入的向量维度。 我们使用 Dense 定义全连接层，它的用法请参照 这里 。由于我们已经知道 \\mathbf{A} \\mathbf{A} 和 \\mathbf{c} \\mathbf{c} 可能的取值范围，这里我们重定义了 \\mathbf{W} \\mathbf{W} 和 \\mathbf{b} \\mathbf{b} 的初始化方式。 另外，注意我们这里构造网络的时候有如下技巧： 我们定义的网络输出是 \\mathbf{W}\\mathbf{x} + \\mathbf{b} \\mathbf{W}\\mathbf{x} + \\mathbf{b} ，而非 \\sigma(\\mathbf{W}\\mathbf{x} + \\mathbf{b}) \\sigma(\\mathbf{W}\\mathbf{x} + \\mathbf{b}) 。这是因为我们需要通过还未被激活的输出用来计算sigmoid交叉熵，亦即式 (15) (15) ； 我们通过静态方法，直接调用Tensorflow自带的 sigmoid交叉熵 函数来作为Keras模型的损失函数 self..loss ； 我们通过静态方法，调用Keras的后端API，自己定义了预测准确度的测度函数 self.accuracy ； 我们将网络层的关键字 self.dense1 保留在了实例中，这是为了确保接下来我们能通过实例抽取该层的参数。 之所以煞费周折地进行这些处理，盖因为Keras的内建API里目前还没有提供对互不相斥的多分类的支持。例如，无论是 tf.keras.metrics.categorical_accuracy 还是 tf.keras.metrics.categorical_crossentropy ，都要求分类的真实值为one-hot类型的向量组，因而它们只适合用在softmax分类器上。为了解决这一问题，我们自己实现了sigmoid分类器。 训练和测试方法 ¶ 最后定义的式训练和测试方法。由于我们目前的project还比较简单，关于这两部分都直接调用现有的API即可。使用的API在之前已经说明。 model.fit 在没有额外设置的情况下，默认会返回一个 History回调器 ； model.evaluate 返回的是测试样本给出的损失函数和准确值测度。 model.predict 返回的是测试样本给出的网络输出。详情请参照 顺序模型API 。 lin-cls.py: class LinClsHandle 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def train ( self , dataSet ): ''' Use a data set to train the network. ''' return self . model . fit ( dataSet , epochs = self . epoch , steps_per_epoch = self . steppe ) def test ( self , data , labels ): ''' Use (data, label) pairs to test the results. ''' loss , accu = self . model . evaluate ( data , labels ) print ( 'Evaluated loss =' , loss ) print ( 'Evaluated accuracy =' , accu ) return self . model . predict ( data ) 调试 ¶ 首先，训练网络。我们随机生成 \\mathbf{x} \\mapsto \\mathbf{y}:~\\mathbb{R}^{10} \\mapsto \\mathbb{R}^6 \\mathbf{x} \\mapsto \\mathbf{y}:~\\mathbb{R}^{10} \\mapsto \\mathbb{R}^6 的线性变换，并且设置好数据集，给定噪声扰动为 \\boldsymbol{\\varepsilon} \\sim \\mathcal{N}(0,1)^6 \\boldsymbol{\\varepsilon} \\sim \\mathcal{N}(0,1)^6 。设定20个epoch，每个epoch迭代500次，每次馈入32个样本构成的batch，然后开始训练： lin-cls.py 1 2 3 4 5 6 7 8 A = np . random . normal ( 0 , 10 , [ INPUT_SHAPE , LABEL_SHAPE ]) c = np . random . uniform ( 1 , 3 , [ 1 , LABEL_SHAPE ]) dataSet = dp . TestDataSet ( 10 , A , c ) dataSet . config ( batch = 32 , noise = 0.1 ) # Construct the model and train it. h = LinClsHandle ( learning_rate = 0.01 , epoch = 20 , steppe = 500 ) h . construct () record = h . train ( iter ( dataSet )) Output Epoch 1 /20 500 /500 [==============================] - 3s 5ms/step - loss: 48 .2269 - accuracy: 0 .5458 Epoch 2 /20 500 /500 [==============================] - 1s 2ms/step - loss: 25 .5149 - accuracy: 0 .6491 Epoch 3 /20 500 /500 [==============================] - 1s 2ms/step - loss: 11 .9822 - accuracy: 0 .7607 Epoch 4 /20 500 /500 [==============================] - 1s 2ms/step - loss: 5 .6580 - accuracy: 0 .8513 Epoch 5 /20 500 /500 [==============================] - 1s 2ms/step - loss: 2 .7230 - accuracy: 0 .9106 Epoch 6 /20 500 /500 [==============================] - 1s 2ms/step - loss: 1 .1082 - accuracy: 0 .9462 Epoch 7 /20 500 /500 [==============================] - 1s 2ms/step - loss: 0 .3278 - accuracy: 0 .9708 Epoch 8 /20 500 /500 [==============================] - 1s 3ms/step - loss: 0 .0618 - accuracy: 0 .9878 Epoch 9 /20 500 /500 [==============================] - 1s 2ms/step - loss: 0 .0149 - accuracy: 0 .9963 Epoch 10 /20 500 /500 [==============================] - 1s 2ms/step - loss: 0 .0121 - accuracy: 0 .9979 Epoch 11 /20 500 /500 [==============================] - 1s 2ms/step - loss: 0 .0124 - accuracy: 0 .9976 Epoch 12 /20 500 /500 [==============================] - 1s 2ms/step - loss: 0 .0121 - accuracy: 0 .9978 Epoch 13 /20 500 /500 [==============================] - 1s 2ms/step - loss: 0 .0121 - accuracy: 0 .9973 Epoch 14 /20 500 /500 [==============================] - 1s 2ms/step - loss: 0 .0120 - accuracy: 0 .9974 Epoch 15 /20 500 /500 [==============================] - 1s 2ms/step - loss: 0 .0121 - accuracy: 0 .9970 Epoch 16 /20 500 /500 [==============================] - 1s 2ms/step - loss: 0 .0116 - accuracy: 0 .9971 Epoch 17 /20 500 /500 [==============================] - 1s 2ms/step - loss: 0 .0120 - accuracy: 0 .9967 Epoch 18 /20 500 /500 [==============================] - 1s 3ms/step - loss: 0 .0114 - accuracy: 0 .9971 Epoch 19 /20 500 /500 [==============================] - 1s 2ms/step - loss: 0 .0114 - accuracy: 0 .9969 Epoch 20 /20 500 /500 [==============================] - 1s 2ms/step - loss: 0 .0113 - accuracy: 0 .9970 接下来，从训练返回的 History 类型的回调器中抽取对loss和accuracy的记录。 lin-cls.py 1 2 showCurve ( record . epoch , record . history [ 'loss' ], xlabel = 'epoch' , ylabel = 'Cross entropy' , log = True ) showCurve ( record . epoch , record . history [ 'accuracy' ], xlabel = 'epoch' , ylabel = 'Accuracy' ) Output 重新设定数据集的产生方式，变为每个batch含10个样本。使用这组重新随机生成的数据测试网络输出， lin-cls.py 1 2 3 4 5 6 7 8 9 10 11 12 # Generate a group of testing samples: dataSet . config ( batch = 10 ) x , y = next ( dataSet ) # Check the testing results yp = dp . sigmoid ( h . test ( x , y )) _ , ( ax1 , ax2 ) = plt . subplots ( 1 , 2 ) ax1 . imshow ( y , interpolation = 'nearest' , aspect = 'auto' ) ax1 . set_title ( 'True class' ) ax2 . imshow ( yp , interpolation = 'nearest' , aspect = 'auto' ) ax2 . set_title ( 'Predicted class' ) plt . gcf () . set_size_inches ( 10 , 5 ), plt . show () Output 注意我们未对测量的结果阈值化，因此显示出来的测量结果和理想值略有差别，但从图可知，阈值化后则测量结果全部准确。 通过抽取 h.dense1 的参数，我们可以对比 \\mathbf{A} \\mathbf{A} 和 \\mathbf{W} \\mathbf{W} ，以及 \\mathbf{c} \\mathbf{c} 和 \\mathbf{b} \\mathbf{b} ， lin-cls.py 1 2 3 4 5 6 7 8 9 10 11 # Check the regressed values W , b = h . dense1 . get_weights () plt . imshow ( A , interpolation = 'nearest' , aspect = 'auto' ), plt . colorbar (), plt . gca () . set_title ( 'A' ) plt . gcf () . set_size_inches ( 6 , 5 ), plt . show () plt . imshow ( W , interpolation = 'nearest' , aspect = 'auto' ), plt . colorbar (), plt . gca () . set_title ( 'W' ) plt . gcf () . set_size_inches ( 6 , 5 ), plt . show () plt . plot ( c . T , label = 'c' ) plt . plot ( b . T , label = 'b' ) plt . legend () plt . gcf () . set_size_inches ( 5 , 5 ), plt . show () Output 可以发现，虽然我们训练的分类器十分有效，但其权值和预期的 \\mathbf{A} \\mathbf{A} , \\mathbf{c} \\mathbf{c} 并不相同。这是由于我们训练的样本加入了噪声。这种技术常用于神经网络的训练，被认为是一种提高鲁棒性、减小过拟合、避免不稳定解的一个有效手段。可以看出真实值 \\mathbf{A} \\mathbf{A} 存在偏高值，但 \\mathbf{W} \\mathbf{W} 的数值更加均匀。","text_tokens":["data","linclshandle","1s","0.59","预期","可读性","下划","pass","虽然","fixed","向量","差别","normal","配置","标准","做到","默认","哪","假设","通常","二个","vdots","single","0.44","9878","神经网","subplots","left","...","lr","9462","/","gca","权值","最后","对应","总是","足够","符合","官方","dense1","一维","20","26","灵活","51","结构","{","两个","整理","只要","工程","train","print","3","改写","文件","数目","module","要求","处理器","临时","entropy","静态方法","地","提供","define","a","说明","使","化","并","9","有关","lin","较长","9708","cross","感知机","生成器","3s","处理","分布","9963","sequential","返回值","变为","节","事实","略有","linear","12","for","results","frac","layers","equal","^","多用","故而","l3","是因为","使得","（","iter","set","指数","产生","次数","47","staticmethod","以单","arg","自定义","0.54","存在","既然","额外","有效","情况","变量","9978","求解","boldsymbol","看待","nearest","5ms","理想","之旅","全部","测试","9970","dataset","它","不","0.47","5458","0618","相同","9969","无关","向","详情请","至此","beta","br","evaluated","还有","写法","参数","鲁棒性","34","事实上","稳定","均","用单","内容","interpolation","mathbb","infty","softmax","注意","认为","predicted","描述","equation","标量","bias","撰写","布尔","可信","只有","大量","stroke","后","复杂度","processing","records","大写","属于","range","看成","解决","func","拟合","内部","optimizer","和","矩阵","python","我们","存储","&","才","多个","if","为了","config","相若","准确度","大小","简短","override","单独","残差","这组","per","0.1","begin","视","未知","3ms","添加","inches","一层","线性变换","环节","不是","与","#","三个","7","ba9132","即","每","check","做","无论是","外围","align","8513","19","分离","线性组合","由此可知","代码","15","模块","要","fae6a9","性关系","看作","in","关键","axis","首先","0.6","迭代","互不","开头","比较简单","6580","思源","\\","大小写","重","看出","单词","size","one","红线","各个","写出","器中","由","float32","放在","随机","等价","样本",";","generate","私有","左右","化后","需要","values","initialization","l","文件夹","input","很","扩展","短接","adamoptimizer","none","这","0.58","49","tensorflow","extension","16",",","0.51","extending","类中","结尾","插值","却","regression","9106","rate","陆续","=","init","深度","import","宏","尽管","字母","称","mathcal","图","accu","第","视为","；","技巧","error","求导","后来","构建","向用","一般","因为","加入","ldots","了","快速","组合","round","一大","test","重新","w","摘要","来","where","那么","当","下图","tilde","如果","leqslant","对比","分类","yield","network","引出","较为简单","意味","dense","model","相斥","23","to","用法","不再","实例","偏高值","全字","codes","项目","负值","0.61","10.0","减小","the","超平面","形式","return","回归","意味着","以","方法","bool","神经网络","特殊","每组","0124","len","对角","7230","showcurve","记","project","9979","都","initializer",")","正确理解","技术","操作符","diter","属性","存储器","单","遵守","add","应当","计算","批次","给","method","9974","mathbf","另外","获得","堆叠","部分","功能","成器","compile","加权","点","samples","大多数","详情","常用","42","sigmoid","这里","29","0.52","维度","必要","所以","网络结构","并非","含","推荐","0.42","并且","有限","while","pyplot","将","传入","44","习惯","表明","实现","[","问题","各","p","32","mode","现有","原则上","重写","最","we","除了","二","建立","跨层","特征","接下","tool","内","]","stddev","function","分析","是否","1","e","min","0.49","内建","级","单单","right","logistic","但类","改进","38","初始化","保存","各自","每次","固定","层叠","以外","只","0.56","最大","samp","|","提示","平面","星号","scale","多数","输","构造方法","group","cls","cdot","适合","theta","label","loss","跟","一定","任意","数据","任","层","transformation","第二","进行","b","概率","analyzing","一个","ylabel","熟悉","块","给定","交叉","0.48","classdef","彼此","不成","1082","分类器","完成","太多","代入","其中","regressed","由于","封装","的话","测试代码","文字","蛇形","介绍","出来","预测","也","关键字","确信","确定","jacobian","包括","vector","<","值为","熵","next","多","np","it",">","10","正值","aligned","命名","网络","0.01","在","均匀分布","以及","饮水","因而","linspace","采用","早期","会","次","keras","9967","操作","of","如何","预处理","added","被","auto","调试","不会","steps","规定","0121","通过","噪声","存取","api","training","对象","训练","非常","展示","好处","作为","有趣","真实","testing","31","number","fill","step","下来","and","速率","就是","数据分布","值","新","含义","之所以","stystart","其他","adam","建议","initialize","准确","实数","支持","可能","可见","x","基本","参见","把","noise","st","最小","煞","yp","d","网络层","ed","5","记录","走上",".","”","代表","哪怕","只能","─","满足","过","验证","最大化","单调","直接","模式","馈入","允许","0.4","参照","2269","crossentropy","name","shape"," ","45","映射","33","饮水思源","initializers","而是","h","¶","random","可微","预测值","于","轮","layer","该","pred","用到","线性","则","子","图示","读者","首字母","fit","路径","初始","'","模块化","our","）","省略","外部","一侧","空间","求取","py","0120","成","0113","驼峰","类","上","varepsilon","l1","、","parameters","这个","可读","划线","0114","顺序","模型","这是","perceptron","最小化","2","送入","理论","结果","合适","类级","后面","扰动","weights","并不相同","gcf","41","testdataset","用户","设置","其实","器","0.46","须知","抽取","history","时","上述","17","6491","end","完善","对数","分别","面向用户","良好","54","lvert","8","generator","保留","方式","前","推导","显示","件夹","下划线","开","是","但","集类","活用","表示","hat","dparser","注释","500","主","好","__","constant","之前","3278","greater","mean","优化","原则","均匀","孱弱","with","j","权重","大多","iterator","直线","然而","开始","非常简单","true","还会","小写","sigma","费周折","较为","反之","调整结构","~","record","0149","0.38","exp","常数","上手","std","之后","阈值","个","partial","k","25","目的","0","每轮","ax1","0.53","知道","cdots","l2","继承","出原","一条","_","术语","姑且","n","35","就","集","例如","发展","6","，","ij","flag","use","之间","log","实际","9822","coder","法指","以双","用","100","但是","然后","matmul","legend","显式","设计","理器","tools","r","没有","labels","│","graph","由此","自带","类型","分入","先河","*","epoch","激活","mapsto","(","第一","activation","每个","文档","某","返回","调用","取值","}","一组","9976","@","├","aspect","端","必须","39","若","如下","蓝线","有","c++","一一","关于","调整","入","组","y","非线性","as","main","只是","steppe","show","连用","提高","独立","未","或","else","接下来","bmatrix","推断出","简简单单","可以","hot","正确","变换","周折","48","24","一种","反","0.0","特别","手段","读取","以便","确保","列","46","kernel","..","以下","21","9973","sum","发现","title","本","过程","称为","limits","神经","实际上","推断","解析","偏置","+","角度","alphabeta","两侧","意义","2ms","而","元素","xlabel","为","引用","设定","parser","使用","避免","包含","一类","效果","花费","关系","目前","sim","i","给出","连接","对","感知","这一","max","叫","28","37","大化","categorical","4","7607","还","0.57","考虑","store","鉴往知来","面向","？","matplotlib","-","一个点","相关","9971","不同","alpha","52","代替","backend","plot","pairs","两","一","又","出","还是","logits","14","plt","行","t","具有","标准化","nn","办法","可信度","区分","等","accuracy","线性关系","测度","36","知机","中","两层","22","metrics","法","它们","定义数据","损失","导数","construction","输出","learning","估计","astype","二维","从","40","colorbar","十分","11","输入","类时","同时","第一个",":","50","output","27","定性","一些","s","全","找到","：","单层","退化","请","简单","特性","的","imshow","c","斯蒂","稳定性","getattribute","post","较强","人意","class","尽如","def","这种","范围","0116","最早","解","尽如人意","numpy","回调","本身","比较","randomnormal","数据测试","即可","更加","&&","学习","。","后续","alphabetafunction","第二个","30","讨论","一个多","编写","逻辑","ax2","用来","其","1e","测量","53","轴","定义","最终","可知","适当","构造","evaluate","tf","复杂","之","0.45","13","自定","盖","对角线","不以","式","0.5","测试方法","43","非","一个二维","因此","这样","无论","5149","该层","截距","已经","交点","batch","predict","18","静态","get","且","序列","construct","导入","主要","取","首字","生成","写成","即式","这些","功夫","成文","数值","能","大致","时候","不成文","双","下","各组","不能","构成","亦","到","configuration","dp","自己","self","于是","└","似然","子类","规范","概率论","入门","uniform","函数","里","神经元","epochs","信度","程度","controlling","rvert","理解","“","表述"],"title":"线性分类","title_tokens":["分类","线性"]},{"location":"book-1-x/chapter-1/linear-classification/#_1","text":"摘要 本节介绍如何使用顺序模型(sequential model)来编写一个线性分类器，使用sigmoid函数激活，并验证其效果。","text_tokens":["验证","并","如何","一个","sequential","，"," ",")","节","分类器","线性","摘要","来","介绍","。","本","编写","分类","其","sigmoid","激活","(","顺序","model","模型","使用","函数","效果"],"title":"线性分类","title_tokens":["分类","线性"]},{"location":"book-1-x/chapter-1/linear-classification/#_2","text":"","text_tokens":[],"title":"理论","title_tokens":["理论"]},{"location":"book-1-x/chapter-1/linear-classification/#_3","text":"考虑我们有如下的二分类数据集 (\\mathbf{x},~y_i) \\in \\mathbb{D}_i (\\mathbf{x},~y_i) \\in \\mathbb{D}_i ，并且有一个未知的常数向量 \\mathbf{a}_i \\mathbf{a}_i 和未知的常数标量 c_i c_i ，使得： \\begin{equation} y_i = \\left\\{ \\begin{aligned} 0, && \\mathbf{a}_i^T \\mathbf{x} + c_i \\leqslant 0, \\\\ 1, && \\mathbf{a}_i^T \\mathbf{x} + c_i > 0. \\end{aligned} \\right. \\end{equation} 其中， \\mathbf{a} \\mathbf{a} 可以看成是某超平面的（未标准化的）法向量，那么 \\mathbf{a}^T \\mathbf{x} + c = 0 \\mathbf{a}^T \\mathbf{x} + c = 0 是该超平面的截距式定义，亦即该平面与 x_i x_i 轴的交点可以显式表述为 x_i^{(0)} = - \\frac{c}{a_i} x_i^{(0)} = - \\frac{c}{a_i} 。由此可知，式 (1) (1) 显式定义了一个点在超平面的哪一侧。特别地，若 \\mathbf{x} \\mathbf{x} 是一个二维向量，则该超平面退化为一维平面；若 \\mathbf{x} \\mathbf{x} 是一个标量，则该超平面退化为一条直线。 若我们定义 (\\mathbf{x},~\\mathbf{y}) \\in \\mathbb{D} (\\mathbf{x},~\\mathbf{y}) \\in \\mathbb{D} ，有 \\begin{equation} \\mathbf{y} = \\begin{bmatrix} y_1 \\\\ y_2 \\\\ \\vdots \\\\ y_n \\end{bmatrix}, ~~ \\mathbf{A} = \\begin{bmatrix} \\mathbf{a}^T_1 \\\\ \\mathbf{a}^T_2 \\\\ \\vdots \\\\ \\mathbf{a}^T_n \\end{bmatrix}, ~~ \\mathbf{c} = \\begin{bmatrix} c_1 \\\\ c_2 \\\\ \\vdots \\\\ c_n \\end{bmatrix}. \\end{equation} 则我们可以认为 \\begin{align} \\mathbf{y} = \\left\\{ \\begin{bmatrix}\\hat{y}_1 > 0 & \\hat{y}_2 > 0 & \\cdots & \\hat{y}_n > 0\\end{bmatrix}^T, ~ \\left| ~ \\hat{\\mathbf{y}} = \\mathbf{A} \\mathbf{x} + \\mathbf{c} + \\boldsymbol{\\varepsilon} \\right. \\right\\}, \\end{align} 其中 \\boldsymbol{\\varepsilon} \\boldsymbol{\\varepsilon} 是一个定义噪声的向量。 我们可以把向量 \\mathbf{y} \\mathbf{y} 的元素看成是互不相关的多个超平面对向量 \\mathbf{x} \\mathbf{x} 各自独立的分类结果。即 y_i = \\{ \\hat{y}_i>0 ~ | ~ \\hat{y}_i = \\mathbf{a}_i^T \\mathbf{x} + c_i + \\varepsilon_i \\} y_i = \\{ \\hat{y}_i>0 ~ | ~ \\hat{y}_i = \\mathbf{a}_i^T \\mathbf{x} + c_i + \\varepsilon_i \\} 。由于每个超平面构成一个二分类，如果把每个二分类看作是向量是否属于这个类的测度，那么 \\mathbf{y} \\mathbf{y} 可以被看作是一个多分类的结果，尽管向量 \\mathbf{x} \\mathbf{x} 可能被同时分入多个类中。 假设我们的数据集 (\\mathbf{x},~\\mathbf{y}) \\in \\mathbb{D} (\\mathbf{x},~\\mathbf{y}) \\in \\mathbb{D} 符合 (3) (3) 定义的数据分布特征。我们的基本要求是，在我们不知道 \\mathbf{A},~\\mathbf{c} \\mathbf{A},~\\mathbf{c} 的情况下，使用大量 (\\mathbf{x}^{(k)},~\\mathbf{y}^{(k)}) \\in \\mathbb{D} (\\mathbf{x}^{(k)},~\\mathbf{y}^{(k)}) \\in \\mathbb{D} 样本训练一个线性分类器，使得当我们给定任意一个新样本 \\mathbf{x} \\mathbf{x} 的时候，分类器能推断出其对应的 \\mathbf{y} \\mathbf{y} 来（亦即是否属于该分类）。 在这个问题里，我们虽然不知道 \\mathbf{A},~\\mathbf{c} \\mathbf{A},~\\mathbf{c} ，但我们知道由 (3) (3) 确定的线性关系，因此，我们可以随机生成一组 \\mathbf{W},~\\mathbf{b} \\mathbf{W},~\\mathbf{b} ，构建线性模型： \\begin{align} \\tilde{\\mathbf{y}} = \\sigma ( \\mathbf{W} \\mathbf{x} + \\mathbf{b} ). \\end{align} 其中，可微函数 \\sigma \\sigma 是一个将实数空间 \\mathbb{R}^n \\mathbb{R}^n 映射到有限范围的实数空间 [0,~1]^n [0,~1]^n 内的函数。特别地， \\sigma(-\\infty)=0,~\\sigma(0)=0.5,~\\sigma(+\\infty)=1 \\sigma(-\\infty)=0,~\\sigma(0)=0.5,~\\sigma(+\\infty)=1 。因此，可以将 \\sigma \\sigma 看作是二分类布尔函数的插值函数。理论上，只要我们找到 \\mathbf{W}=\\mathbf{A} \\mathbf{W}=\\mathbf{A} ， \\mathbf{b}=\\mathbf{c} \\mathbf{b}=\\mathbf{c} ，则该线性分类器可以直接拟合出原分布来。","text_tokens":["y","=","被","尽管","独立","未","虽然","向量","bmatrix","推断出","可以","；","噪声","标准","哪","假设","训练","构建","vdots","了","特别","w","left","来","数据分布","那么","当","新","tilde","如果","leqslant","分类","对应","符合","推断","+","一维","元素","实数","为","可能","{","x","基本","把","使用","只要","d","关系","3","i","超平面","要求",".","对","地","a","直接","考虑","分布","-","一个点","相关"," ",")","映射","可微","该","frac","t","则","线性","^","标准化","使得","mathbf","）","（","线性关系","一侧","空间","测度","法","类","varepsilon","上","这个","情况","boldsymbol","模型","二维","2","结果","同时","理论","并且","有限","将","不","找到","：","问题","退化","[","end","的","c","二","mathbb","infty","特征","认为","equation","标量","范围","内","是","但","]","布尔","大量","hat","是否","1","属于","看成","&&","拟合","。","和","我们","&","多个","一个多","right","直线","其","sigma","各自","~","轴","begin","定义","未知","可知","常数","|","平面","k","0","与","知道","cdots","即","任意","出原","数据","一条","式","_","0.5","align","n","集","b","一个","由此可知","给定","，","一个二维","性关系","看作","in","分类器","因此","截距","交点","其中","互不","由于","\\","显式","生成","r","能","由","时候","随机","样本","确定","由此","下","构成","分入","亦","到","(","每个","某",">","}","一组","aligned","在","若","如下","里","有","函数",",","类中","插值","表述"],"title":"问题描述","title_tokens":["问题","描述"]},{"location":"book-1-x/chapter-1/linear-classification/#_4","text":"我们将 (4) (4) 定义的线性模型称为 单层感知机 (Single-layer perceptron) 模型。它包含一个权重矩阵 \\mathbf{W} \\mathbf{W} 和一个偏置矩阵 \\mathbf{b} \\mathbf{b} 。事实上，可以将 (4) (4) 改写成如下形式 \\begin{align} \\tilde{\\mathbf{y}} = \\sigma \\left( \\begin{bmatrix} \\mathbf{W} & \\mathbf{b} \\end{bmatrix} \\begin{bmatrix} \\mathbf{x} \\\\ 1 \\end{bmatrix} \\right). \\end{align} 可见偏置本身可以看成是输入向量多了一个常数元素的等价模型。 感知机是最早的神经网络形式，它非常孱弱，只能解线性问题，但却为神经网络后来的发展开了先河。在单层感知机里，我们视输入向量 \\mathbf{x} \\mathbf{x} 的每个元素为一个“神经元”，矩阵 \\mathbf{W} \\mathbf{W} 和偏置 \\mathbf{b} \\mathbf{b} 将我们的输入映射到输出层 \\mathbf{y} \\mathbf{y} ，输出层的每个元素也视为一个神经元。在这个过程中， W_{ij} W_{ij} 作为 i i 行 j j 列的元素，代表了连接两个神经元的权重。我们用红线代表正值，蓝线代表负值，感知机可以被图示为 线性感知机的输出也是输入的线性组合，但我们可以添加激活函数，即 \\sigma(\\cdot) \\sigma(\\cdot) 将其映射到非线性空间。这要求我们添加的激活函数是一个非线性函数。 事实上，将单层感知机层叠，前一层的输出作为后一层的输入，就构建出早期的神经网络。这种网络每一层都是全连接的（两个神经元之间总是有权重，尽管值可能为0），每一层都有激活函数。理论上，任意一个两层堆叠的感知机，只要神经元数目足够多，就可以拟合出任意一个非线性函数。然而，实际测试中，这一理论的效果并不尽如人意，因此又有陆续地改进，才有了后来的深度学习。饮水思源，鉴往知来，我们也将从这个简简单单的单层模型开始，走上学习“深度学习”之旅。","text_tokens":["y","非线性","陆续","=","深度","被","尽管","向量","bmatrix","视为","简简单单","可以","后来","非常","构建","single","作为","了","神经网","组合","w","left","列","值","tilde","过程","总是","称为","足够","神经","偏置","元素","为","可见","可能","{","x","两个","包含","负值","只要","效果","改写","i","数目","感知",".","形式","”","代表","只能","连接","要求","这一","地","神经网络","并","4","感知机","鉴往知来","-","都"," ",")","映射","饮水思源","事实","又","出","layer","行","线性","图示","mathbf","）","堆叠","（","空间","知机","成","中","两层","上","这个","输出","模型","从","perceptron","之旅","输入","理论","测试","走上","将","它","不","全","单层","问题","事实上","end","的","简单","人意","尽如","前","这种","开","是","最早","解","但","尽如人意","本身","后","1","看成","拟合","学习","。","矩阵","和","我们","&","才","孱弱","单单","j","权重","right","然而","开始","改进","其","sigma","begin","定义","视","层叠","常数","添加","一层","cdot","0","即","任意","每","层","_","align","就","b","一个","线性组合","发展","，","ij","因此","之间","实际","用","思源","\\","红线","也","等价","先河","到","激活","(","多","每个","}","正值","网络","在","蓝线","如下","里","函数","神经元","这","有","饮水","早期","“","却"],"title":"感知机","title_tokens":["知机","感知机","感知"]},{"location":"book-1-x/chapter-1/linear-classification/#sigmoid","text":"在上述介绍中，我们没有解决的两个问题是， 如何定义插值函数 \\sigma \\sigma ？ 如何找到合适的 \\mathbf{W},~\\mathbf{b} \\mathbf{W},~\\mathbf{b} ？ 我们首先讨论第一个问题。一般地，多分类问题中，如果各个分类彼此并非相斥，且不一定要将结果分入任一类的话，我们可以用 Sigmoid 函数来定义 \\sigma \\sigma ，亦即 \\begin{align} \\sigma(\\mathbf{x}) = \\frac{1}{ 1 + e^{-\\mathbf{x}}}. \\end{align} 它同时满足 \\sigma(-\\infty)=0,~\\sigma(0)=0.5,~\\sigma(+\\infty)=1 \\sigma(-\\infty)=0,~\\sigma(0)=0.5,~\\sigma(+\\infty)=1 ，且是一个单调函数。以下代码向我们展示了这种函数的特性： Python 1 2 3 4 5 6 7 8 9 10 11 12 import numpy as np import matplotlib.pyplot as plt def test_sigmoid (): x = np . linspace ( - 5 , 5 , 100 ) y = 1 / ( 1 + np . exp ( - x ) ) plt . plot ( x , y ) plt . xlabel ( 'x' ), plt . ylabel ( 'y' ) plt . gcf () . set_size_inches ( 5 , 5 ), plt . show () if __name__ == '__main__' : test_sigmoid () Output 使用sigmoid函数的一大好处是，它的导数求解非常简单，很适合用来做神经网络这样一个复杂模型的激活函数。注意虽然 \\sigma(\\mathbf{x}) \\sigma(\\mathbf{x}) 和 \\mathbf{x} \\mathbf{x} 都是向量，这意味着导数是Jacobian矩阵，但由于 \\sigma \\sigma 是一个对 \\mathbf{x} \\mathbf{x} 各元素独立的解析函数，这个Jacobian矩阵实际上是一个对角矩阵，对角线上第j个元素的值为 \\begin{align} \\left. \\frac{ \\partial \\sigma(x) }{ \\partial x } \\right|_{x=x_j} = \\left. - e^{-x} \\left( - \\frac{1}{\\left( 1+e^{-x} \\right)^2} \\right) \\right|_{x=x_j} = - \\sigma(x_j) \\sigma(1 - x_j). \\end{align} 可见，该函数的导数和计算函数本身的复杂度相若，可以做到快速求导。","text_tokens":["y","如何","=","as","main","show","import","独立","虽然","向量","第","可以","做到","求导","非常","展示","一般","好处","了","快速","神经网","一大","test","w","left","来","以下","/","值","如果","分类","神经","实际上","解析","+","意味","元素","xlabel","为","相斥","可见","{","x","使用","两个","一类","3","5",".","对","地","满足","意味着","神经网络","4","单调","9","对角","？","matplotlib","-","name","都"," ",")","plot","12","该","plt","计算","frac","^","'","mathbf","set","中","上","sigmoid","这个","导数","并非","求解","模型","2","11","合适","第一个","结果","同时",":","output","pyplot","将","它","不","gcf","找到","向","：","问题","各","上述","特性","end","的","简单","infty","注意","8","def","这种","是","numpy","但","本身","复杂度","1","e","解决","__","。","python","和","矩阵","我们","讨论","if","j","相若","right","非常简单","用来","sigma","~","begin","定义","exp","|","inches","复杂","个","partial","0","适合","7","即","一定","任","对角线","_","做","0.5","align","b","一个","ylabel","代码","6","，","彼此","要","这样","首先","实际","由于","且","用","100","\\","的话","size","各个","介绍","没有","jacobian","分入","亦","激活","多","第一","(","np","10","}","很","网络","在","函数","这","linspace",",","插值"],"title":"Sigmoid函数","title_tokens":["sigmoid","函数"]},{"location":"book-1-x/chapter-1/linear-classification/#_5","text":"接下来，我们需要解决第二个问题，亦即找到 \\mathbf{W},~\\mathbf{b} \\mathbf{W},~\\mathbf{b} 。这一问题通常可以写成反问题的形式： \\begin{align} \\arg \\min_\\limits{\\mathbf{W},~\\mathbf{b}} \\sum_{k=1}^N \\mathcal{L} \\left( \\mathbf{y}^{(k)},~ \\sigma ( \\mathbf{W} \\mathbf{x}^{(k)} + \\mathbf{b} ) \\right). \\end{align} 最简单的情况下，我们可以把 损失函数(loss function) 定义为 \\begin{align} \\mathcal{L} \\left( \\mathbf{y},~ \\tilde{\\mathbf{y}} \\right) = \\lVert \\mathbf{y} - \\tilde{\\mathbf{y}} \\rVert_2^2. \\end{align} 我们称 (8) (8) 为 逻辑斯蒂回归(logistic regression) 。有趣的是，虽然这个术语叫“回归”，但它解的其实是个分类问题。但是，既然这是一个分类问题，我们可以不使用这个损失函数，而是从概率论的角度看待这个问题。由此，我们引出一个新的损失函数：“交叉熵”。","text_tokens":["y","=","称","mathcal","虽然","接下来","可以","通常","二个","有趣","反","下来","w","left","新","sum","tilde","分类","limits","引出","+","角度","为","{","x","把","使用",".","形式","这一","”","叫","回归","-"," ",")","而是","^","mathbf","arg","损失","这个","既然","情况","看待","这是","从","2","它","不","找到","其实","：","问题","简单","end","的","最","斯蒂","lvert","8","接下","是","但","解","function","min","1","解决","。","我们","第二个","right","logistic","逻辑","sigma","~","begin","定义","个","k","loss","即","术语","_","align","n","第二","b","概率","一个","交叉","，","但是","\\","写成","下","由此","亦","需要","熵","(","l","}","概率论","函数",",","rvert","“","regression"],"title":"求解问题","title_tokens":["求解","问题"]},{"location":"book-1-x/chapter-1/linear-classification/#_6","text":"我们视sigmoid函数输出的值为一个概率，表示分类器对预测结果的确信程度，记 \\mathbf{W},~\\mathbf{b} \\in \\boldsymbol{\\Theta} \\mathbf{W},~\\mathbf{b} \\in \\boldsymbol{\\Theta} ，则 \\begin{equation} \\begin{aligned} \\mathbf{p}(y_i=1|\\mathbf{x};~\\boldsymbol{\\Theta}) &= \\sigma(\\mathbf{x};~\\boldsymbol{\\Theta}), \\\\ \\mathbf{p}(y_i=0|\\mathbf{x};~\\boldsymbol{\\Theta}) &= 1 - \\sigma(\\mathbf{x};~\\boldsymbol{\\Theta}). \\end{aligned} \\end{equation} 注意这里的概率向量的含义是，其中第i个元素表明第i个超平面分类结果的确信程度。 然而，这个概率只是分类器对分类结果的确信程度，却并非是分类准确度的概率，实际上，分类准确度的概率，应当表述为 \\begin{equation} \\begin{aligned} \\mathbf{p}(\\mathbf{y}|\\mathbf{x};~\\boldsymbol{\\Theta}) &= \\mathbf{p}(y_i=1|\\mathbf{x};~\\boldsymbol{\\Theta})^{\\mathbf{y}} \\mathbf{p}(y_i=0|\\mathbf{x};~\\boldsymbol{\\Theta})^{1-\\mathbf{y}}\\\\ &= \\sigma(\\mathbf{x};~\\boldsymbol{\\Theta})^{\\mathbf{y}} \\left(1 - \\sigma(\\mathbf{x};~\\boldsymbol{\\Theta}) \\right)^{1-\\mathbf{y}}. \\end{aligned} \\end{equation} 注意 这里 \\mathbf{x}^{\\mathbf{y}} \\mathbf{x}^{\\mathbf{y}} 表示的是对每个元素一一求取指数，即函数第i个元素的返回值应当为 {x_i}^{y_i} {x_i}^{y_i} 。 我们使用真实值 \\mathbf{y} \\mathbf{y} 作为指数给概率向量加权。当 \\mathbf{y}=1 \\mathbf{y}=1 时，以预测值为1的可信度作为概率；反之则以预测值为0的可信度作为概率。这就是最大似然估计方法。至此，我们可以写出似然估计函数 \\begin{align} L(\\boldsymbol{\\Theta}) = \\mathbf{p}(\\mathbf{y}^{(k)}|\\mathbf{x}^{(k)};~\\boldsymbol{\\Theta}). \\end{align} 对似然估计函数取对数，则有 \\begin{equation} \\begin{aligned} l(\\boldsymbol{\\Theta}) &= \\sum_{k=1}^N \\log \\left( \\mathbf{p}(\\mathbf{y}^{(k)}|\\mathbf{x}^{(k)};~\\boldsymbol{\\Theta}) \\right) \\\\ &= \\sum_{k=1}^N \\mathbf{y}^{(k)} \\cdot \\log\\left(\\sigma(\\mathbf{x}^{(k)};~\\boldsymbol{\\Theta})\\right) + \\left(1 - \\mathbf{y}^{(k)} \\right) \\cdot \\log\\left(1 - \\sigma(\\mathbf{x}^{(k)};~\\boldsymbol{\\Theta})\\right). \\end{aligned} \\end{equation} 我们最终的目的是要最大化似然函数，亦即 \\mathbf{W},~\\mathbf{b} = \\arg\\max\\limits_{\\boldsymbol{\\Theta}} l(\\boldsymbol{\\Theta}) \\mathbf{W},~\\mathbf{b} = \\arg\\max\\limits_{\\boldsymbol{\\Theta}} l(\\boldsymbol{\\Theta}) ，这等价于最小化 -l(\\boldsymbol{\\Theta}) -l(\\boldsymbol{\\Theta}) 。对比 (8) (8) 和 (9) (9) ，于是我们可以定义交叉熵为 \\begin{align} \\mathcal{L} \\left( \\mathbf{y},~ \\tilde{\\mathbf{y}} \\right) = \\mathbf{y} \\cdot \\log\\left( \\tilde{\\mathbf{y}} \\right) + \\left(1 - \\mathbf{y} \\right) \\cdot \\log\\left(1 - \\tilde{\\mathbf{y}} \\right). \\end{align} 若我们记 \\tilde{\\mathbf{y}} = \\sigma(\\tilde{\\mathbf{x}}) \\tilde{\\mathbf{y}} = \\sigma(\\tilde{\\mathbf{x}}) ，代入sigmoid函数，为了确保该损失函数的稳定性，我们可以将 (14) (14) 整理为 \\begin{align} \\mathcal{L} \\left( \\mathbf{y},~ \\tilde{\\mathbf{x}} \\right) = \\max(\\tilde{\\mathbf{x}}, \\mathbf{0}) - \\tilde{\\mathbf{x}} \\cdot \\mathbf{y} + \\log\\left(1 + e^{-|\\tilde{\\mathbf{x}}|} \\right). \\end{align} 提示 这里交叉熵整理的推导过程参见 Tensorflow-API官方文档 。 实际情况下，我们使用 (15) (15) 来求取sigmoid函数激活下的交叉熵。","text_tokens":["y","只是","=","mathcal","向量","第","；","可以","api","真实","作为","确保","w","left","就是","来","当","值","sum","tilde","含义","对比","分类","过程","limits","实际上","官方","+","准确","元素","为","{","x","参见","使用","最小","整理","i","超平面","对",".","max","以","方法","大化","最大化","9","记","-","返回值"," ",")","预测值","于","应当","14","该","则","给","^","可信度","mathbf","求取","指数","加权","arg","sigmoid","这里","损失","这个","情况","输出","并非","估计","boldsymbol","最小化","结果","将","定性","表明","至此","p","时","end","的","稳定","对数","稳定性","注意","8","推导","equation","是","可信","表示","1","e","。","和","我们","&","为了","准确度","然而","right","sigma","反之","~","begin","最终","视","定义","最大","|","提示","平面","个","k","目的","0","theta","cdot","即","_","align","n","概率","b","一个","交叉","15","，","要","分类器","in","代入","log","其中","实际","\\","取","写出","预测","等价","确信",";","下","亦","熵","激活","(","每个","于是","返回","l","文档","}","似然","aligned","函数","这","若","有","tensorflow","一一",",","信度","程度","却","表述"],"title":"交叉熵","title_tokens":["交叉","熵"]},{"location":"book-1-x/chapter-1/linear-classification/#_7","text":"","text_tokens":[],"title":"解线性多分类问题","title_tokens":["分类","解","线性","多","问题"]},{"location":"book-1-x/chapter-1/linear-classification/#_8","text":"建立一个具有较强可读性的Tensorflow工程需要我们活用python的模块化设计。我们通常推荐以下的结构 . ├─ data/ # where we store our data │ └─ ... ├─ tools.py # codes for post-processing and analyzing records. ├─ extension.py # codes for extending the tensorflow model. ├─ dparser.py # data parser └─ main.py # main module where we define our tensorflow model. 除了保存数据的文件夹，我们应当有三个子模块。其中 tool : 用来处理、分析生成的数据，通常与Tensorflow无关； extension : 用来扩展tensorflow，例如在这里自定义网络层和操作符； dparser : 数据处理器，用来读取并预处理送入网络的数据； main : 主模块，只定义跟Tensorflow模型有关的内容，需要引用 extension 和 dparser 。 视情况可以灵活调整结构，但建议将定义Tensorflow模型的代码单独放在主模块里，和其他外围代码分离。 撰写各个模块时，建议使用类封装各组功能相同的函数。具有良好使用习惯的coder应当注意给各个面向用户的类、函数撰写（哪怕简短的）说明文字，在一些较长的函数、方法的定义中，适当注释各部分的功能，以便读者能正确理解代码意义。 另外，在对象命名上，python有如下必须遵守或不成文的规定，和C/C++用户熟悉的蛇形命名法不同，它大致包括 类与函数多用驼峰命名法，变量可以采用驼峰或蛇形命名法。 驼峰命名法指的是用大小写区分每个单词块，例如 alphaBetaFunction () ； 蛇形命名法指的是用下划线区分每个单词块，例如 alpha_beta_function = 10 ； 宏变量使用全字大写+蛇形命名法 函数/方法，还有模块均是首字母小写，但类的首字母大写。 用单下划线 _ 表示临时存储器，或省略参数，例如一个函数 func () 有两个返回值时，可以用 _ , b = func () 表示我们只需要第二个返回值；单下划线还可以与星号连用省略多个返回值； 以单下划线开头的方法，表示模块级的私有方法，在模块以外使用 import 导入类时，不会导入这些方法，例如 def _alphaBeta ( self ): ； 以单下划线结尾的对象，用来和python的关键字区分，例如 func ( x , class_ ) ; 以双下划线开头的方法，如果不以双下划线结尾，则表示类级的私有方法，只有类内部的方法能调用这些方法，在类外部、包括继承的子类里都原则上不能调用（但其实也有办法调用），例如 def _alphaBeta ( self ): ； 以双下划线同时开头和结尾的方法，一般是用来 重写 (override) 特殊功能，例如 def __getattribute__ (): 将重写获得类属性的方法。","text_tokens":["data","main","=","预处理","import","可读性","宏","字母","连用","不会","下划","或","规定","；","可以","正确","对象","通常","向用","二个","一般","读取","and","以便","where","...","以下","/","如果","其他","建议","+","alphabeta","意义","灵活","model","结构","引用","x","parser","使用","codes","全字","两个","工程","网络层","the","处理器","文件","临时","module","结尾",".","哪怕","─","define","说明","方法","并","有关","特殊","还","较长","store","面向","处理","-","返回值","都"," ","正确理解","不同","操作符",")","alpha","属性","for","存储器","单","遵守","应当","具有","读者","给","子","首字母","多用","则","办法","our","模块化","另外","）","区分","省略","（","部分","功能","py","外部","获得","中","驼峰","以单","类","上","自定义","法","、","这里","可读","划线","情况","变量","模型","送入","类时","推荐","类级",":","同时","将","一些","习惯","它","用户","相同","无关","其实","各","beta","时","还有","参数","原则上","均","重写","的","we","除了","c","getattribute","用单","post","内容","较强","建立","良好","面向用户","注意","class","def","tool","件夹","下划线","撰写","是","但","活用","只有","function","表示","processing","分析","records","dparser","注释","大写","主","func","内部","__","。","级","python","和","alphabetafunction","我们","存储","第二个","原则","多个","但类","大小","简短","用来","单独","override","保存","小写","调整结构","定义","视","只","以外","适当","星号","与","自定","#","三个","跟","继承","数据","不以","_","外围","第二","analyzing","b","例如","一个","分离","代码","熟悉","块","模块","，","不成","关键","其中","开头","coder","法指","以双","用","封装","大小写","导入","理器","设计","生成","tools","文字","单词","各个","蛇形","首字","成文","这些","关键字","能","大致","放在","也","│","不成文","各组","包括",";","私有","双","不能","需要","(","每个","self","返回","调用","文件夹","└","10","扩展","命名","子类","网络","├","在","必须","函数","如下","里","有","tensorflow","extension","c++","采用",",","extending","调整","理解","操作"],"title":"代码规范","title_tokens":["规范","代码"]},{"location":"book-1-x/chapter-1/linear-classification/#_9","text":"在本项目里，我们不需要扩展Tensorflow。但是，我们需要以随机生成数据代替数据集。因此，首先，通过以下代码定义数据生成器 dparser.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class TestDataSet : ''' A generator of the data set for testing the linear model. ''' def __init__ ( self , scale_x , A , c ): ''' Initialize the data generator. scale_x: the scale of input vector. A, c: the linear transformation. ''' self . s_x = 2 * scale_x self . A = A self . c = c self . len_x = A . shape [ 0 ] self . config () def config ( self , train = True , batch = 100 , noise = 0.1 ): ''' Configuration train: a flag for controlling the iterator mode. batch: the number of samples in a batch noise: std. of the error added to the y. ''' self . train = bool ( train ) self . batch = batch self . noise = noise def next_train ( self ): ''' Get the next train batch: (x, y) ''' x = self . s_x * ( np . random . random ([ self . batch , self . len_x ]) - 0.5 ) y = np . matmul ( x , self . A ) + self . c if self . noise > 1e-3 : y = y + np . random . normal ( 0 , self . noise , size = y . shape ) y = np . greater ( y , 0.0 ) . astype ( np . float32 ) return x , y def next_test ( self ): ''' Get the next test batch x. ''' return self . s_x * ( np . random . random ([ self . batch , self . len_x ]) - 0.5 ) def __iter__ ( self ): while True : samp = self . __next__ () yield samp def __next__ ( self ): if self . train : return self . next_train () else : return self . next_test () 该生成器输入一组 \\mathbf{A},~\\mathbf{c} \\mathbf{A},~\\mathbf{c} ，以及相关配置，之后就可以通过 迭代器 (iterator) 或 方法 (method) 随机生成数据。这种数据集写法我们在后面还会用到， model . fit 允许我们不是馈入样本（或样本批次），而是馈入一个 生成器(generator) 。因此我们重写了 __iter__ 方法，并使其通过 yield 返回一个生成器。这样我们定义的数据集类就可以被Keras的训练函数 model . fit 使用。接下来，调用如下测试代码： dparser.py 1 2 3 4 5 6 7 8 9 10 def test_dataset (): A = np . random . normal ( 0 , 10 , [ 10 , 6 ]) c = np . random . uniform ( 1 , 3 , [ 1 , 6 ]) dataSet = TestDataSet ( 10 , A , c ) dIter = iter ( dataSet ) for i in range ( 10 ): x , y = next ( dIter ) print ( np . sum ( y , axis = 0 ) / 100 ) test_dataset () Output [ 0.47 0.57 0.58 0.56 0.5 0.38 ] [ 0.6 0.61 0.47 0.48 0.38 0.52 ] [ 0.5 0.61 0.49 0.42 0.45 0.53 ] [ 0.59 0.52 0.44 0.44 0.49 0.51 ] [ 0.54 0.59 0.48 0.5 0.51 0.47 ] [ 0.49 0.57 0.56 0.49 0.53 0.4 ] [ 0.5 0.61 0.51 0.54 0.51 0.52 ] [ 0.5 0.51 0.61 0.5 0.44 0.5 ] [ 0.44 0.46 0.53 0.45 0.56 0.52 ] [ 0.52 0.46 0.51 0.52 0.49 0.44 ] 我们随机生成了 \\mathbf{x} \\mapsto \\mathbf{y}:~\\mathbb{R}^{10} \\mapsto \\mathbb{R}^6 \\mathbf{x} \\mapsto \\mathbf{y}:~\\mathbb{R}^{10} \\mapsto \\mathbb{R}^6 的数据，每组数据100个，并且测试了10组。输出结果是各组测试中， \\mathbf{y} \\mathbf{y} 在对应维度上分类为1的概率估计。结果基本都在0.5左右，说明我们的这种数据生成模式产生的点能均匀分布在各个超平面两侧，适合进行后续测试。","text_tokens":["data","of","y","init","=","0.59","added","被","else","或","通过","normal","接下来","可以","配置","error","训练","48","testing","0.44","24","31","number","0.0","了","下来","test","46","并且","以下","21","/","sum","yield","本","对应","分类","initialize","+","两侧","20","26","51","23","model","to","为","x","{","noise","基本","项目","使用","0.61","0.42","train","print","3","the","5","i","超平面",".","28","return","都","以","37","a","bool","方法","使","并","4","9","len","0.57","每组","模式","馈入","生成器","允许","0.4","分布","-","shape","相关"," ","45","52","33","代替",")","而是","diter","random","linear","12","for","14","该","用到","fit","批次","^","method","'","mathbf","）","iter","（","成器","py","36","set","产生","samples","点","中","47","22","42","上","定义数据","29","0.54","维度","0.52","输出","估计","astype","40","2","11","输入","结果","50","后面",":","测试","while","output","27","dataset","44","不","41","testdataset","s","0.47","器","[","：","0.46","32","mode","17","写法","34","重写","的","c","mathbb","54","8","class","generator","接下","def","这种","集类","是","]","dparser","1","range","__","0.49","。","greater","后续","我们","30","if","config","均匀","iterator","true","还会","38","1e","其","~","53","0.1","0.38","定义","0.56","samp","std","scale","之后","平面","个","25","不是","0","13","0.45","适合","0.53","7","均匀分布","数据","_","transformation","0.5","35","就","进行","集","概率","19","一个","0.48","代码","43","15","6","，","flag","因此","这样","in","axis","首先","0.6","迭代","batch","18","get","但是","100","\\","matmul","测试代码","生成","size","各个","r","能","float32","随机","vector","样本","各组","左右","*","需要","next","configuration","(","mapsto","np","self","调用","返回","input","10",">","}","一组","扩展","在","39","函数","如下","里","以及","uniform","0.58","49","tensorflow","16","0.51",",","说明","controlling","keras","组"],"title":"数据生成","title_tokens":["生成","数据"]},{"location":"book-1-x/chapter-1/linear-classification/#_10","text":"顺序(sequential) 模型是一个单输入单输出模型，网络结构较为简单，也不存在跨层短接（残差连接）。在大多数情况下，已经上手的Tensorflow用户不使用这个模型，故而作为我们入门的第一个project，我们姑且用之，但我们将不再使用顺序模型来实现后续的project。一个顺序模型大致可以描述为下图的模式： graph LR st(输<br/>入) --> l1[层<br/>1] l1 --> l2[层<br/>2] l2 --> l3[层<br/>3] l3 --> ldots[层<br/>...] ldots --> ed(输<br/>出) classDef styStart fill:#FAE6A9,stroke:#BA9132; class st,ed styStart 由于我们完成的是一个线性分类器，故而我们使用单层的序列模型即可。 接下来，我们来定义一个类， class LinClsHandle : 。定义一个类的时候，我们通常需要定义的内容包括 在初始化方法 __init__ 里定义传入网络的固定参数，例如学习速率，存取路径等； 在方法 construct 里定义网络的构造和使用的优化器； 在方法 train 里定义训练网络的过程，主要需要调用 model . fit 。如果我们在数据集的定义非常完善，则这一环节不需要花费太多的功夫； 在方法 test 里定义测试网络的过程，主要需要调用 model . evaluate 。如果有必要，可以通过 model . predict 返回测试结果。","text_tokens":["linclshandle","init","接下来","通过","可以","；","存取","通常","训练","非常","作为","ldots","下来","test","速率","来","下图","lr","...","/","如果","分类","过程","stystart","较为简单","为","model","结构","不再","st","使用","花费","fill","ed","3","传入","train","连接",".","方法","模式","sequential","project","-"," ",")","单","一","出","线性","路径","fit","l3","则","故而","初始","）","等","（","大多数","类","l1","存在","这个","必要","顺序","网络结构","情况","输出","模型","2","输入","结果","第一个",":","测试","将","不","用户","器","[","：","br","单层","参数","简单","完善","的","内容","跨层","class","接下","描述","是","但","]","stroke","1","即可","__","学习","。","后续","和","实现","优化","我们","大多","初始化","较为","固定","定义","多数","上手","构造","输","evaluate","之","环节","l2","#","ba9132","数据","姑且","层","集","残差","例如","一个","classdef","，","fae6a9","分类器","完成","太多","已经","predict","由于","用","序列","construct","主要","功夫","也","大致","时候","graph","<","下",";","包括","需要","(","第一","调用","返回",">","短接","网络","入门","在","这","里","有","tensorflow",",","入"],"title":"定义线性顺序模型","title_tokens":["顺序","定义","模型","线性"]},{"location":"book-1-x/chapter-1/linear-classification/#_11","text":"首先，定义初始化方法： lin-cls.py: class LinClsHandle 1 2 3 4 5 6 7 8 9 10 def __init__ ( self , learning_rate = 0.01 , epoch = 10 , steppe = 30 ): ''' Initialization and pass fixed parameters. learning_rate: the learning rate for optimizer. epoch: training epochs. steppe: steps per epoch ''' self . lr = learning_rate self . epoch = epoch self . steppe = steppe 由于目前我们的project还非常简单，这里只需要有学习速率( learning_rate )，轮次数( epoch )和每轮迭代次数( steppe )即可。","text_tokens":["linclshandle","rate","init","=","steppe","pass","fixed","steps","training","非常","and","速率","lr","3","the","5","目前",".","方法","4","9","lin","还","project","-"," ",")","for","轮","初始","'","py","次数","这里","parameters","learning","2",":","：","简单","的","class","8","def","1","即可","__","optimizer","学习","。","和","我们","30","初始化","非常简单","per","定义","只","cls","每轮","7","_","6","，","首先","迭代","由于","需要","epoch","(","self","initialization","10","0.01","有","epochs",","],"title":"初始化方法","title_tokens":["方法","初始化","初始"]},{"location":"book-1-x/chapter-1/linear-classification/#_12","text":"接下来定义网络构造 lin-cls.py: class LinClsHandle 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 def construct ( self ): ''' Construct a linear model and set the optimizer as Adam ''' # Construction self . model = tf . keras . Sequential () self . dense1 = tf . keras . layers . Dense ( LABEL_SHAPE , use_bias = True , input_shape = ( INPUT_SHAPE ,), kernel_initializer = tf . keras . initializers . RandomNormal ( 0.0 , stddev = 10.0 ), bias_initializer = tf . keras . initializers . Constant ( 2 ), activation = None ) self . model . add ( self . dense1 ) # Set optimizer self . model . compile ( optimizer = tf . train . AdamOptimizer ( self . lr ), loss = self . loss , metrics = [ self . accuracy ] ) @staticmethod def loss ( y_true , y_pred ): return tf . nn . sigmoid_cross_entropy_with_logits ( labels = y_true , logits = y_pred ) @staticmethod def accuracy ( y_true , y_pred ): return tf . keras . backend . mean ( tf . keras . backend . equal ( y_true , tf . keras . backend . round ( tf . keras . backend . sigmoid ( y_pred )))) 须知 这里 LABEL_SHAPE 和 INPUT_SHAPE 为两个宏变量，分别为输出和输入的向量维度。 我们使用 Dense 定义全连接层，它的用法请参照 这里 。由于我们已经知道 \\mathbf{A} \\mathbf{A} 和 \\mathbf{c} \\mathbf{c} 可能的取值范围，这里我们重定义了 \\mathbf{W} \\mathbf{W} 和 \\mathbf{b} \\mathbf{b} 的初始化方式。 另外，注意我们这里构造网络的时候有如下技巧： 我们定义的网络输出是 \\mathbf{W}\\mathbf{x} + \\mathbf{b} \\mathbf{W}\\mathbf{x} + \\mathbf{b} ，而非 \\sigma(\\mathbf{W}\\mathbf{x} + \\mathbf{b}) \\sigma(\\mathbf{W}\\mathbf{x} + \\mathbf{b}) 。这是因为我们需要通过还未被激活的输出用来计算sigmoid交叉熵，亦即式 (15) (15) ； 我们通过静态方法，直接调用Tensorflow自带的 sigmoid交叉熵 函数来作为Keras模型的损失函数 self..loss ； 我们通过静态方法，调用Keras的后端API，自己定义了预测准确度的测度函数 self.accuracy ； 我们将网络层的关键字 self.dense1 保留在了实例中，这是为了确保接下来我们能通过实例抽取该层的参数。 之所以煞费周折地进行这些处理，盖因为Keras的内建API里目前还没有提供对互不相斥的多分类的支持。例如，无论是 tf.keras.metrics.categorical_accuracy 还是 tf.keras.metrics.categorical_crossentropy ，都要求分类的真实值为one-hot类型的向量组，因而它们只适合用在softmax分类器上。为了解决这一问题，我们自己实现了sigmoid分类器。","text_tokens":["y","linclshandle","as","=","宏","被","未","向量","接下来","通过","hot","；","技巧","api","因为","周折","真实","作为","24","了","0.0","下来","and","round","确保","w","来","kernel","lr","..","21","keras","分类","之所以","adam","dense1","+","20","26","dense","为","23","model","用法","可能","而","{","x","实例","相斥","使用","两个","煞","10.0","train","网络层","3","the","5","静态方法","entropy","连接",".","目前","return","提供","地","对","要求","a","这一","方法","categorical","4","9","lin","还","直接","cross","参照","处理","sequential","-","shape","initializer"," ",")","backend","crossentropy","都","initializers","linear","12","add","还是","logits","14","支持","pred","计算","layers","equal","nn","初始","'","是因为","mathbf","另外","accuracy","compile","py","set","测度","中","staticmethod","22","metrics","它们","上","sigmoid","这里","维度","损失","所以","变量","construction","输出","模型","这是","2","11","输入",":","将","它","全","抽取","[","须知","请","：","问题","17","参数","的","c","分别","softmax","注意","class","接下","8","保留","def","范围","是","]","stddev","后","randomnormal","1","解决","constant","optimizer","。","mean","和","内建","实现","我们","with","为了","activation","准确度","true","初始化","用来","费周折","sigma","定义","只","构造","tf","25","cls","label","13","适合","loss","#","知道","7","盖","_","层","无论是","进行","b","19","例如","交叉","15","非","6","，","use","关键","无论","分类器","该层","已经","18","静态","由于","互不","用","construct","\\","重","即式","one","这些","预测","关键字","能","没有","labels","时候","值为","自带","类型","亦","需要","熵","激活","(","多","自己","self","取值","调用","input","10","准确","}","adamoptimizer","@","网络","none","端","在","这","如下","函数","有","里","因而","tensorflow","16",",","方式","bias","组"],"title":"构造方法","title_tokens":["构造方法","构造","方法"]},{"location":"book-1-x/chapter-1/linear-classification/#_13","text":"最后定义的式训练和测试方法。由于我们目前的project还比较简单，关于这两部分都直接调用现有的API即可。使用的API在之前已经说明。 model.fit 在没有额外设置的情况下，默认会返回一个 History回调器 ； model.evaluate 返回的是测试样本给出的损失函数和准确值测度。 model.predict 返回的是测试样本给出的网络输出。详情请参照 顺序模型API 。 lin-cls.py: class LinClsHandle 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def train ( self , dataSet ): ''' Use a data set to train the network. ''' return self . model . fit ( dataSet , epochs = self . epoch , steps_per_epoch = self . steppe ) def test ( self , data , labels ): ''' Use (data, label) pairs to test the results. ''' loss , accu = self . model . evaluate ( data , labels ) print ( 'Evaluated loss =' , loss ) print ( 'Evaluated accuracy =' , accu ) return self . model . predict ( data )","text_tokens":["data","linclshandle","steppe","=","steps","accu","；","api","默认","训练","test","值","最后","network","准确","model","to","使用","train","print","目前","3","5","the","给出",".","return","说明","a","方法","4","9","还","直接","lin","参照","project","-","都"," ",")","pairs","两","12","results","14","fit","'","accuracy","部分","py","测度","详情","set","额外","损失","情况","顺序","输出","模型","2","11","测试",":","dataset","设置","器","详情请","evaluated","history","现有","简单","的","class","8","def","是","回调","比较","1","即可","之前","。","和","我们","per","定义","evaluate","cls","label","13","loss","7","式","_","测试方法","一个","6","，","use","已经","predict","由于","比较简单","没有","labels","样本","下","epoch","(","调用","self","返回","10","网络","在","这","函数","epochs",",","关于","会"],"title":"训练和测试方法","title_tokens":["训练","测试方法","测试","和","方法"]},{"location":"book-1-x/chapter-1/linear-classification/#_14","text":"首先，训练网络。我们随机生成 \\mathbf{x} \\mapsto \\mathbf{y}:~\\mathbb{R}^{10} \\mapsto \\mathbb{R}^6 \\mathbf{x} \\mapsto \\mathbf{y}:~\\mathbb{R}^{10} \\mapsto \\mathbb{R}^6 的线性变换，并且设置好数据集，给定噪声扰动为 \\boldsymbol{\\varepsilon} \\sim \\mathcal{N}(0,1)^6 \\boldsymbol{\\varepsilon} \\sim \\mathcal{N}(0,1)^6 。设定20个epoch，每个epoch迭代500次，每次馈入32个样本构成的batch，然后开始训练： lin-cls.py 1 2 3 4 5 6 7 8 A = np . random . normal ( 0 , 10 , [ INPUT_SHAPE , LABEL_SHAPE ]) c = np . random . uniform ( 1 , 3 , [ 1 , LABEL_SHAPE ]) dataSet = dp . TestDataSet ( 10 , A , c ) dataSet . config ( batch = 32 , noise = 0.1 ) # Construct the model and train it. h = LinClsHandle ( learning_rate = 0.01 , epoch = 20 , steppe = 500 ) h . construct () record = h . train ( iter ( dataSet )) Output Epoch 1 /20 500 /500 [==============================] - 3s 5ms/step - loss: 48 .2269 - accuracy: 0 .5458 Epoch 2 /20 500 /500 [==============================] - 1s 2ms/step - loss: 25 .5149 - accuracy: 0 .6491 Epoch 3 /20 500 /500 [==============================] - 1s 2ms/step - loss: 11 .9822 - accuracy: 0 .7607 Epoch 4 /20 500 /500 [==============================] - 1s 2ms/step - loss: 5 .6580 - accuracy: 0 .8513 Epoch 5 /20 500 /500 [==============================] - 1s 2ms/step - loss: 2 .7230 - accuracy: 0 .9106 Epoch 6 /20 500 /500 [==============================] - 1s 2ms/step - loss: 1 .1082 - accuracy: 0 .9462 Epoch 7 /20 500 /500 [==============================] - 1s 2ms/step - loss: 0 .3278 - accuracy: 0 .9708 Epoch 8 /20 500 /500 [==============================] - 1s 3ms/step - loss: 0 .0618 - accuracy: 0 .9878 Epoch 9 /20 500 /500 [==============================] - 1s 2ms/step - loss: 0 .0149 - accuracy: 0 .9963 Epoch 10 /20 500 /500 [==============================] - 1s 2ms/step - loss: 0 .0121 - accuracy: 0 .9979 Epoch 11 /20 500 /500 [==============================] - 1s 2ms/step - loss: 0 .0124 - accuracy: 0 .9976 Epoch 12 /20 500 /500 [==============================] - 1s 2ms/step - loss: 0 .0121 - accuracy: 0 .9978 Epoch 13 /20 500 /500 [==============================] - 1s 2ms/step - loss: 0 .0121 - accuracy: 0 .9973 Epoch 14 /20 500 /500 [==============================] - 1s 2ms/step - loss: 0 .0120 - accuracy: 0 .9974 Epoch 15 /20 500 /500 [==============================] - 1s 2ms/step - loss: 0 .0121 - accuracy: 0 .9970 Epoch 16 /20 500 /500 [==============================] - 1s 2ms/step - loss: 0 .0116 - accuracy: 0 .9971 Epoch 17 /20 500 /500 [==============================] - 1s 2ms/step - loss: 0 .0120 - accuracy: 0 .9967 Epoch 18 /20 500 /500 [==============================] - 1s 3ms/step - loss: 0 .0114 - accuracy: 0 .9971 Epoch 19 /20 500 /500 [==============================] - 1s 2ms/step - loss: 0 .0114 - accuracy: 0 .9969 Epoch 20 /20 500 /500 [==============================] - 1s 2ms/step - loss: 0 .0113 - accuracy: 0 .9970 接下来，从训练返回的 History 类型的回调器中抽取对loss和accuracy的记录。 lin-cls.py 1 2 showCurve ( record . epoch , record . history [ 'loss' ], xlabel = 'epoch' , ylabel = 'Cross entropy' , log = True ) showCurve ( record . epoch , record . history [ 'accuracy' ], xlabel = 'epoch' , ylabel = 'Accuracy' ) Output 重新设定数据集的产生方式，变为每个batch含10个样本。使用这组重新随机生成的数据测试网络输出， lin-cls.py 1 2 3 4 5 6 7 8 9 10 11 12 # Generate a group of testing samples: dataSet . config ( batch = 10 ) x , y = next ( dataSet ) # Check the testing results yp = dp . sigmoid ( h . test ( x , y )) _ , ( ax1 , ax2 ) = plt . subplots ( 1 , 2 ) ax1 . imshow ( y , interpolation = 'nearest' , aspect = 'auto' ) ax1 . set_title ( 'True class' ) ax2 . imshow ( yp , interpolation = 'nearest' , aspect = 'auto' ) ax2 . set_title ( 'Predicted class' ) plt . gcf () . set_size_inches ( 10 , 5 ), plt . show () Output 注意我们未对测量的结果阈值化，因此显示出来的测量结果和理想值略有差别，但从图可知，阈值化后则测量结果全部准确。 通过抽取 h.dense1 的参数，我们可以对比 \\mathbf{A} \\mathbf{A} 和 \\mathbf{W} \\mathbf{W} ，以及 \\mathbf{c} \\mathbf{c} 和 \\mathbf{b} \\mathbf{b} ， lin-cls.py 1 2 3 4 5 6 7 8 9 10 11 # Check the regressed values W , b = h . dense1 . get_weights () plt . imshow ( A , interpolation = 'nearest' , aspect = 'auto' ), plt . colorbar (), plt . gca () . set_title ( 'A' ) plt . gcf () . set_size_inches ( 6 , 5 ), plt . show () plt . imshow ( W , interpolation = 'nearest' , aspect = 'auto' ), plt . colorbar (), plt . gca () . set_title ( 'W' ) plt . gcf () . set_size_inches ( 6 , 5 ), plt . show () plt . plot ( c . T , label = 'c' ) plt . plot ( b . T , label = 'b' ) plt . legend () plt . gcf () . set_size_inches ( 5 , 5 ), plt . show () Output 可以发现，虽然我们训练的分类器十分有效，但其权值和预期的 \\mathbf{A} \\mathbf{A} , \\mathbf{c} \\mathbf{c} 并不相同。这是由于我们训练的样本加入了噪声。这种技术常用于神经网络的训练，被认为是一种提高鲁棒性、减小过拟合、避免不稳定解的一个有效手段。可以看出真实值 \\mathbf{A} \\mathbf{A} 存在偏高值，但 \\mathbf{W} \\mathbf{W} 的数值更加均匀。","text_tokens":["y","linclshandle","rate","=","steppe","1s","9106","of","auto","show","预期","被","提高","mathcal","未","0121","差别","虽然","接下来","normal","通过","可以","噪声","变换","训练","48","0113","testing","9878","加入","一种","真实","了","step","神经网","and","下来","重新","test","subplots","w","9973","9462","/","值","gca","发现","权值","对比","title","分类","神经","dense1","2ms","20","准确","xlabel","为","model","{","x","设定","noise","使用","避免","偏高值","yp","sim","train","3","the","5","记录","entropy","减小",".","对","过","0124","a","化","神经网络","4","7607","lin","9708","9","7230","并不相同","3s","馈入","showcurve","cross","2269","9963","-","shape","9979"," ",")","0120","9971","变为","h","random","略有","plot","12","于","results","14","plt","线性","则","t","^","9974","'","mathbf","iter","accuracy","常用","py","set","产生","samples","varepsilon","sigmoid","、","存在","有效","0114","9978","输出","learning","含","boldsymbol","nearest","理想","5ms","从","colorbar","2","11","十分","这是","全部","结果","weights",":","并且","扰动","output","测试","dataset","5458","testdataset","0618","9969","gcf","相同","不","设置","抽取","：","[","history","32","6491","17","参数","鲁棒性","imshow","稳定","的","c","interpolation","mathbb","注意","认为","8","接下","class","方式","predicted","显示","0116","这种","是","但","解","]","回调","技术","数据测试","1","500","更加","好","拟合","。","3278","和","我们","均匀","config","图","开始","true","这组","ax2","测量","其","手段","0149","record","每次","~","0.1","3ms","然后","9970","可知","inches","阈值","线性变换","个","group","25","cls","0","label","13","ax1","loss","#","7","数据","9967","check","_","n","8513","集","b","19","一个","ylabel","给定","15","6","，","1082","5149","因此","分类器","首先","迭代","batch","9822","18","log","regressed","6580","get","由于","construct","\\","legend","看出","生成","size","出来","r","器中","数值","随机","样本","generate","类型","构成","化后","epoch","next","mapsto","(","dp","np","每个","it","返回","input","10","values","}","9976","网络","0.01","aspect","uniform","以及","16",",","次"],"title":"调试","title_tokens":["调试"]}]}