{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"扉页 ¶ 摘要 Tensorflow总纲，写给初学者们。本页面将简述Tensorflow的基本原理，结构设计以及版本更新。读者亦可在本页找到本教程将提供给读者对Tensorflow怎样的认识。 注意 由于技术限制，现在中文搜索功能无法完善，请注意当搜索关键词的时候自行分词，例如： 开放源代码软件库 无法搜到任何内容。但可以搜索 开放 源代码 软件 库 即可确保索引到上述内容。 Tensorflow总说 ¶ Tensorflow官网 TensorFlow™ 是一个开放源代码软件库，用于进行高性能数值计算。借助其灵活的架构，用户可以轻松地将计算工作部署到多种平台（CPU、GPU、TPU）和设备（桌面设备、服务器集群、移动设备、边缘设备等）。TensorFlow™ 最初是由 Google Brain 团队（隶属于 Google 的 AI 部门）中的研究人员和工程师开发的，可为机器学习和深度学习提供强力支持，并且其灵活的数值计算核心广泛应用于许多其他科学领域。 Tensorflow治学 ¶ 写在所有内容之前，读者不得不看以下几个页面，本教程所述内容大略来自于对这些资料的研读。 Tensorflow官网(中/英文) : https://www.tensorflow.org/ Keras中文文档 : https://keras-zh.readthedocs.io/ Tensorflow 2.0前瞻(英文) : https://medium.com/tensorflow/effective-tensorflow-2-0-best-practices-and-whats-changed-a0ca48767aff Tensorflow 2.0前瞻(中文) : https://zhuanlan.zhihu.com/p/50049041 提示 特别值得注意的是，现在官方文档至少在教程部分， 已经支持中英双语 。相比官方文档，我们的教程更侧重于以搭建工程为导向的设计。然而现在官方文档的翔实可读程度，确实不可错过。另一方面，Keras的 官方中文文档 似乎已不再更新，上面提供的原官方中文文档译者现在正在更新、维护的版本。 大略来说，学习Tensorflow主要应当依赖于官方文档的介绍。敝人自r1.4版开始入门Tensorflow，即是通过学习官方文档的教程来快速上手。相比四处蒐集资料，官方文档能提供一个完整、系统、完全贴合时下最新API的例子，帮助用户建立一个与Tensorflow各个功能合宜的使用习惯。若是通过在Github上检索他人的project，固然是一个很好的上手办法，但是往往就会遗漏某些重要的功能而不学。例如，Tensorflow自带的网络存取和Tensorboard API，在时兴的一些project中，经常会因方便之故，以numpy的IO来代替。笔者以为，如此培养起来的使用习惯，可谓走入偏门。当然，从这一点来说，本教程也亦复如是，即使笔者写下这些内容的时候，参照的乃是时下最新的API，时间一久，难免会过时。倘若笔者懒惰一些，不再时时更新本教程，那么本教程也就入不足取之流了。 虽然如此，教程也有并不合宜的地方。最大的问题莫过于Tensorflow本身，它有着日新月异的变化，此时能圆转如意地使用的API，到了彼时也许就成了废案。这就导致Tensorflow的官方教程也不断更新。r1.4时，教程还主要集中在如何使用“底层”API上，到了r1.9.0，就已经变成基本围绕着 tf.keras 设计的思路了。最新消息显示，即将上线的Tensorflow 2.0，将会彻底抛弃过去的“中层”API以下的全部方法， tf.layers , tf.contrib 都将被移除，倘若长期墨守成规，局限在入门时候的一套技术上，迟早会被官方库如此迅速的更新所弃。这也是无可奈何之事。毕竟Tensorflow仍然处于不断改进之中。倘若希望追求一个更加稳定、长期可用的库，keras或许是一个不错的选择。 故而，本教程将基本基于Tensorflow现在的版本(r1.13)展开介绍。本教程既可以看作一个入门教程，也可以看作是本人重新自学新版Tensorflow规范化API的一个手记，故而命名本教程为“手札”。读者不妨跟着笔者的思路，有如与笔者共学一般读下来本教程。 Tensorflow原理 ¶ 一个标准的Tensorflow工作流可以表示成这样： graph TD st(开始) --> Sess[启动Session] Sess --> ConNet[构建网络] subgraph 构造流程 ioNet>读取网络参数] --> ConNet end subgraph 执行流程 ioDat>导入数据] --> Run ConNet --> Run[执行网络] Run --> ioNetS>保存网络参数] Run --> ioRes>导出结果] end ioRes --> SessCl[关闭Session] SessCl --> ed(结束) classDef styStart fill:#FAE6A9,stroke:#BA9132; classDef styIO fill:#cde498,stroke:#13540c; class st,ed styStart class ioNet,ioNetS,ioDat,ioRes styIO 与一般的计算库不同，Tensorflow的执行流程大体可以分为两步： 构造流程 : 在这一步，Tensorflow根据用户代码构造一个 数据流图(dataflow graph) 。所谓数据流图，指的是由一系列 张量(Tensor) 构成的符号运算集合。就如同一张流程图一样，在这一阶段，尽管用户定义了每一步的运算（从简单的加减乘除到复杂的网络单元），但是没有任何运算被执行。就像一个程序员撰写代码一样，Tensorflow在这一步，将用户的代码转换成它的“机器语言”，但是网络还没有进入被使用的阶段。 执行流程 : 在这一步，Tensorflow将计算用户指定的某个 Tensor 的输出结果。要得到一个Tensor的输出，则必须得计算它一系列的依赖变量。例如，我们已知 y = x_1 + x_2 y = x_1 + x_2 , x_2 = z_1 \\times z_2 x_2 = z_1 \\times z_2 。那么，如果Tensorflow要得到 y y 的结果，它就必须先计算 x_2 x_2 。这个过程被完全地封装起来，从用户看来，我们只需要调用 y y 的输出即可，不需要关心Tensorflow是怎样按照流图完成计算的。 因此，典型的Tensorflow式的语言风格也可以这样划分： 构造流程 : 用户定义整个网络的符号运算，指定网络各个节点的属性、输入和输出。这些代码往往被写成一个函数（例如 def construct (): ） 执行流程 : 创建一个Session，在Session内调用构造函数，然后输入数据，得到并保存输出结果。必要情况下，还需要导入导出网络参数。 这里提到 会话(Session) 。Session如同一个Tensorflow虚拟机，在一个Session打开的时候，设备的计算资源（GPU, CPU, 带宽等）才被加载。Session又如同一个工人，用户撰写的网络构造代码如同车间，输入的数据如同商品，“工人（Session）”利用预定义好的“车间（流图）”将可以快速、批量地生产这些“商品（数据）”。这样地设计保证了一些外围的代码，例如指定网络参数的名称、函数的属性等操作，不需要重复进行，从而确保处理数据的时候，总是执行必要的代码，加快运算速度。 另一方面，构造-执行的结构还封装了许多提高运算效率的特性，例如多线程。尽管用户定义网络构造的时候，所写的代码是按照逻辑顺序的、线性的。但实际运行的时候，Tensorflow可以自行发现网络的哪些部分可以被同时运行，从而利用多核系统的计算资源。这些过程也是被完全封装起来的，用户并不需要花费心思去专门进行这些调整。 须知 在Tensorflow已经转变为Keras导向的现在，Session的调用被Keras API封装了起来，从用户的角度来看，现在已经不再需要手动调用Session。 Tensorflow API架构 ¶ 下图显示了当前Tensorflow-API的组织形式 Tensorflow在多个平台上均有部署，包括Python, C++, Java, Javascript, Go等，未来还可能支持更多的语言。然而，不同平台上，API的使用方式和代码风格是大不相同的。例如，Python的语言风格目前已经朝向Keras转变，而Javascript仍倾向于使用中层API；C++和Java偏向于使用底层API编写程序。本教程只针对时兴Python的API编写，除非涉及到特定的专题，不会讨论其他语言上Tensorflow的用法。 一般而言，Tensorflow将API面向划分为三个层次： 高层API (High level) : 包括Estimators和Keras； 中层API (Mid level) : 包括layers, datasets, loss和metrics等具有功能性的函数，例如网络层的定义，Loss Function，对结果的测量函数等； 底层API (Low level) : 包括具体的加减乘除、具有解析式的数学函数、卷积、对Tensor属性的测量等。 从r1.4入门的用户，所接受的训练往往是从底层API开始，使用自己的代码风格构建对应中层API的函数，然后再用自己定义好的中层API构建网络。在这种代码风格的驱使下，用户除了需要定义各个网络层具体的表达式，还需要设计输入输出的接口，用来调用 优化器(optimizer) 的接口等操作。 另一种使用方式，是从中层API开始，直接使用预定义好的网络层构建网络，这样的代码风格会节省一部分时间，相当于几乎不再需要接触底层API，但是在输入输出、网络训练和测试等更高层的模块设计上，和底层API用户的代码风格相似。 Estimators是从r1.4就已经存在的API了，它可以被看成是已经集成在Tensorflow里的完整的网络。因此，Estimators往往适合分发、需求不高的应用，但是并不适合使用Tensorflow的研究者。尽管至今为止，Tensorflow仍然对Estimators倍加推崇，但本教程将完全不涉及这方面的内容。 另一个高层API是 Eager Execution ，从r1.9起，Tensorflow就加入了这种新的使用模式，并且在Tensorflow 2.0中，它仍然将会被保留。Eager摈弃了上述的构造-执行流程，任何对Tensor的定义会被立时计算、并可得到结果。对于需要进行小规模的调试、检查API功能的用户而言更加方便。但是，据一些用户的反响，现在Eager还没有做到和之前API的完全兼容，本教程将基本不涉及Eager的用法。 因此，Keras API将是本教程的重中之重。使用本教程的用户，可以对照目前的官方文档，跟进本教程的思路，自己逐步实现各个project的设计。使用Keras风格的设计，代码量会明显少于前面提到的各种风格（Estimators除外）。事实上， tf.keras 和底层API之间具有一定的兼容，这样的编写风格能让我们在满足自己设计的派生功能的基础上，尽可能使用规范化、预定义的API单元，从而减少代码出错的可能性。通过对本教程TF 1.x版的学习，对未来2.0版的上手也会带来莫大帮助。 金宇琛( @cainmagi )，2019年3月2日 Yuchen Jin( @cainmagi ), Mar. 2, 2019 教程导读 ¶ 接下来，本教程将会涉及 从线性问题入门 : 如何使用Tensorflow完成一个简单的线性分类设计，我们将从Hello World开始，逐步过渡到一个具有核函数的非线性问题project。 Hello world: 第一个Tensorflow程序。 线性分类: 一个简单的二分类问题。 线性回归: 一个同样简单的，线性拟合问题。 非线性回归: 拟合一个简单的，可以表达出解析式的非线性函数。 非线性分类: 使用线性分类器对非线性分布的数据进行分类。 训练与测试分立 : 从这一章开始，并试图解决几个更加复杂的实际问题。这里涉及到的project相对更大、更完整，训练往往需要一定时间才能完成。因此，在本章，所有项目的训练、测试环节都会分开，我们将从这里开始，使用TensorBoard跟踪我们的训练情况，并介绍如何存取神经网络。 Super Resolution: 使用神经网络进行图像像素插值。 Sparse Coding: 使用线性的词典学习(dictionary learning)来进行图像像素插值。 Generitive Model: 使用时兴的生成模型(Generitive Model)来完成图像风格的转换。 原生的数据管理 : 从这一章开始，我们将纳入Tensorflow自带的数据管理API。实际上，很多用户并不习惯使用这些API，往往倾向于自己完成数据的导入导出。虽然这并非一个复杂的工作，但据Tensorflow的文档，原生的数据管理内部实现了多线程，本身更适合用于提高数据IO的效率。读者可以酌情选择是否需要阅读本章。 使用MINIST数据集: 使用原生的数据管理来IO一个现成的MINIST数据集，这一节改自 官方文档教程 。 使用RNN处理文章: 通过LSTM模型来进行文本分类，并使用原生的数据管理来IO一个现成的IMDB数据集，这一节改自 官方文档教程 。 使用RBM生成音频: 通过限制玻尔兹曼机(RBM)来编写一个简单的音乐生成器，这一节改自 llSourcell/Music_Generator_Demo 。 其他的高级技巧 : 本章将介绍一些特殊的、利用底层API技巧，使得用户能更灵活地定制Tensorflow-keras，从而实现一些仅依靠原生库不能实现的功能。","text_tokens":["搭建","一种","基于","effective","本原","边缘","手","既","一节","程度","均","class","关心","内部","将会","英文","形式","测试","过渡","st","end","2.0","涉及","存在","minist","赖于","除非","本页","加减","工作","节点","线性","最大","生成器","和","其他","部分","layers","过时","了","分发","现成","google","1","；","跟着","生产","守成","无可","专门","相同","generator","车间","下来","本","侧重于","使用","亦复如是","也许","同时","不会","分词","反响","情况","各种","¶","得","加减乘除","整个","但本","摈弃","尽可","ed","时","13","相对","导向","借助","这样","对照","手记","桌面","技术","construct","高层","会","张量","low","运算","工程","一系列","编写程序","英双语","语言","调试","结果","dictionary","机","倍加","初学者","构设","们","构造","coding","封装","9.0","数学","重中之重","设计","着","灵活","这个","medium","流图","第一","兼容","效率","自行","高性能","转变","时候","使得","换成","移除","tf","转换","_","完整","角度","接下来","fill","至少","奈何","神经","model","找到","一些","顺序","分类","若","音乐","具有","llsourcell","手动","原生","模块","建立","长期","未来","偏门","正在","\\","看作","以为","须知","官方","仍然","而言","所","翔实","某个","核","datasets","系统","等","走入","加载","styio","并非","看成","可谓","发现","学习","明显","imdb","工程师","不得不","gpu","训练","可以","更加","得到","新月","本身","已知","def","4","虽然","节省","据","当","值得","底层","之中","网络单元","检索","实际上","扉页","似乎","上面","初学","习惯","分为","不能","2019","总纲","是","重新","iores","去","好","批量","改","由","稳定","卷积","技巧","不足","subgraph","显示","计算资源","计算","从而","™","(","构建","用户","分布","应当","之流","商品","写下","从","跟踪",".","这","ionet","，","表达","时间","sparse","部署","符号","往往","立时","属性","虚拟","这方面","tensorflow","yuchen","纳入","词典","13540c","莫过于","墨守","命名","外围","很多","中文搜索","方面","不合宜","同样","完成","将","相比","花费","教程","导读","但据","玻尔兹曼","stystart","可","规范","r1","指","并不需要","api","撰写","对应","表达式","mar","文档","没有","专题","原理","日","两步","久","消息","至今","流程图","来自","新","加快","总是","心思","程序","会因","numpy","环节","墨守成","变成","介绍","不错","更大","这种","插值","所有","特别","定制","派生","要",":","如此","玻尔","接下","更新","服务器","github","懒惰","[","二","特殊","重复","对于","像素","标准","面向","ionets","尽可能","高性","经常","认识","第一个","应用","一套","本人","并","必要","图像","提供","写","zhuanlan","才能","先","zhihu","另","集中","是从","函数","值得注意","一般","图","朝向","例子","依靠","培养","学","侧重","原","抛弃","逻辑","功能","由于","源代码","科学","接受","器","文本","“","彼时","故而","转换成","里","注意","learning","project","给",">","保证","项目","有如","像","io","过于","因此","都","优化","时时","brain","关键","+","fae6a9","管理","性能","构造函数","lstm","50049041","总说","来说","需求","文章","地方","深度","c++","high","上线","平台","多线程","数值","完全","所弃","构成","带来","不高","版本","编写","来看","结构设计","一个","达式","多种","满足","y","大不相同","whats","tpu","提到","彻底","tensor","库","一系","划分","神经网","重于","或许","资源","调用","特定","不妨","规模","现在","所写","过程","帮助","操作","金宇琛","共","导出","www","对","一张","tensorboard","：","表示","所谓","与","然后","function","自己","部门","加入","做到","笔者","之前","实现","go","出","完善","架构","其","单元","readthedocs","stroke","execution","读取","兹曼","0","当于","不可","但是","支持","入门","best","手札","中层","复杂","官网","典型","月","例如","写成","即将","无法","提示","很","规范化","足取","基本原理","最新消息","相当","在","结束","义好","以及","定义","内容","启动","另一方","少于","特性","检查","如是","音频","上","不学","看","新版","减少","年","关键词","这方","session","倘若","如同","基础","版","迟早会","确实","level","重要","他人","几乎","ai","利用","来","简单","执行","处于","难免会","摘要","许多","dataflow","自学","错过","最初","学者","预定","回归","事实","广泛应用","保存","无可奈何","必须","开发","神经网络","分开","/","展开","指定","目前","移动","创建","事","功能性","选择","而","并且","即使","敝","loss","已经","进入","不合","）","按照","广泛","的",",","com","rnn","依赖","研究","变量","一","机器语言","然而","x","相似","写给","人员","又","还","强力","之间","流","领域","双语","维护","快速","地","contrib","也","简述","graph","组织","调整","再用","resolution","参照",";","一定","时兴","成器","从这一点","a0ca48767aff","依赖于","”","起来","读","推崇","大体","追求","人","让","已","具体","当前","线程","classdef","酌情","进行","数据管理","2","如果","出错","有着","集","处理","根据","各个","此时","以下","测量","代码","9","起","cainmagi","开始","存取","打开","metrics","更","确保","以","但","程序员","全部","流程","阶段","开放","速度","过去","不得","软件","限制","cde498","一方","尽管","jin","模型","上述","一点","基本","四处","接口","入门教程","成规","zh","乃是","毕竟","org","前面","小规模","局限","看来","为","所述","demo","讨论","最新","搜索","代替","入","阅读","固然","某些","一章","式","数据","合宜","iodat","keras","输入输出","那么","z","不断更新","world","保留","解决","可用","practices","接触","ba9132","自带","译者","到","索引","系列","不","rbm","模式","不断","仅","对本","方法","风格","集群","另一方面","机器","connet","是否","generitive","遗漏","废案","一部分","亦可","这里","任何","关闭","主要","除外","哪些","自","层次","td","名称","请","一方面","思路","导入","不同","即可","不断改进","跟进","输出","迟早","提高","轻松","一部","属于","用法","带宽","试图","estimators","可能","数据流","工人","包括","每","方便","我们","怎样","生成","日新月异","网络层","如何","只","研读","之故","偏向","为止","用来","高级","3","java","不足取","参数","资料","倾向","super","解析","通过","成","服务","本章","变化","隶属","核心","驱使","changed","下图","拟合","（","希望","范化","针对","事实上","逐步","p","围绕","能","前瞻","仍","导致","网络","直接","隶属于","团队","方式","结构","迅速","被","分立"," ","有","多个","javascript","研究者","hello","中文","用于","于","蒐集","读者","才","适合","能圆转","sesscl","办法","就","]","输入","一般而言","会话","cpu","and","多","运行","设备","它","@","非线性","一样","集成","#","实际","需要","一步","义","量会",")","可能性","虚拟机","除了","墨守成规","music","务器","多核","之","run","-","当然","sess","=","times","。","几个","搜","问题","莫过","如意","这些","则","大略","下","三个","内","分类器","、","治学","集合","莫大","难免","https","不再","改进","python","即","页面","多线","贴合","相当于","中","mid","eager","optimizer","乘除"],"title":"扉页","title_tokens":["扉页"]},{"location":"#_1","text":"摘要 Tensorflow总纲，写给初学者们。本页面将简述Tensorflow的基本原理，结构设计以及版本更新。读者亦可在本页找到本教程将提供给读者对Tensorflow怎样的认识。 注意 由于技术限制，现在中文搜索功能无法完善，请注意当搜索关键词的时候自行分词，例如： 开放源代码软件库 无法搜到任何内容。但可以搜索 开放 源代码 软件 库 即可确保索引到上述内容。","text_tokens":["认识","现在","亦可","任何","时候","关键","提供","本原","原理","对","请","关键词","：","即可","的","搜索","可以","完善","，","找到","代码","本页","技术","功能","由于","源代码","当","。","写给","搜","tensorflow","摘要","确保","但","学者","注意","初学者","初学","版本","结构设计","中文搜索","例如","简述","给","构设","结构","无法","开放","到","们","索引","总纲"," ","将","基本原理","更新","怎样","限制","设计","中文","软件","页面","在","教程","本","库","以及","读者","上述","基本","内容","自行","分词"],"title":"扉页","title_tokens":["扉页"]},{"location":"#tensorflow","text":"Tensorflow官网 TensorFlow™ 是一个开放源代码软件库，用于进行高性能数值计算。借助其灵活的架构，用户可以轻松地将计算工作部署到多种平台（CPU、GPU、TPU）和设备（桌面设备、服务器集群、移动设备、边缘设备等）。TensorFlow™ 最初是由 Google Brain 团队（隶属于 Google 的 AI 部门）中的研究人员和工程师开发的，可为机器学习和深度学习提供强力支持，并且其灵活的数值计算核心广泛应用于许多其他科学领域。","text_tokens":["™","用户","边缘","为","部门","，","其","架构","工作","部署","tensorflow","和","支持","其他","官网","google","到","将","集群","机器","可","借助","桌面","轻松","ai","属于","工程","许多","最初","广泛应用","服务器","开发","灵活","高性","移动","高性能","应用","服务","提供","并且","隶属","）","核心","广泛","的","（","研究","源代码","科学","人员","强力","领域","地","隶属于","团队"," ","于","用于","等","brain","cpu","设备","学习","性能","工程师","进行","gpu","可以","深度","务器","代码","平台","。","数值","、","一个","开放","多种","是","软件","tpu","库","由","中","计算"],"title":"Tensorflow总说","title_tokens":["tensorflow","总说"]},{"location":"#tensorflow_1","text":"写在所有内容之前，读者不得不看以下几个页面，本教程所述内容大略来自于对这些资料的研读。 Tensorflow官网(中/英文) : https://www.tensorflow.org/ Keras中文文档 : https://keras-zh.readthedocs.io/ Tensorflow 2.0前瞻(英文) : https://medium.com/tensorflow/effective-tensorflow-2-0-best-practices-and-whats-changed-a0ca48767aff Tensorflow 2.0前瞻(中文) : https://zhuanlan.zhihu.com/p/50049041 提示 特别值得注意的是，现在官方文档至少在教程部分， 已经支持中英双语 。相比官方文档，我们的教程更侧重于以搭建工程为导向的设计。然而现在官方文档的翔实可读程度，确实不可错过。另一方面，Keras的 官方中文文档 似乎已不再更新，上面提供的原官方中文文档译者现在正在更新、维护的版本。 大略来说，学习Tensorflow主要应当依赖于官方文档的介绍。敝人自r1.4版开始入门Tensorflow，即是通过学习官方文档的教程来快速上手。相比四处蒐集资料，官方文档能提供一个完整、系统、完全贴合时下最新API的例子，帮助用户建立一个与Tensorflow各个功能合宜的使用习惯。若是通过在Github上检索他人的project，固然是一个很好的上手办法，但是往往就会遗漏某些重要的功能而不学。例如，Tensorflow自带的网络存取和Tensorboard API，在时兴的一些project中，经常会因方便之故，以numpy的IO来代替。笔者以为，如此培养起来的使用习惯，可谓走入偏门。当然，从这一点来说，本教程也亦复如是，即使笔者写下这些内容的时候，参照的乃是时下最新的API，时间一久，难免会过时。倘若笔者懒惰一些，不再时时更新本教程，那么本教程也就入不足取之流了。 虽然如此，教程也有并不合宜的地方。最大的问题莫过于Tensorflow本身，它有着日新月异的变化，此时能圆转如意地使用的API，到了彼时也许就成了废案。这就导致Tensorflow的官方教程也不断更新。r1.4时，教程还主要集中在如何使用“底层”API上，到了r1.9.0，就已经变成基本围绕着 tf.keras 设计的思路了。最新消息显示，即将上线的Tensorflow 2.0，将会彻底抛弃过去的“中层”API以下的全部方法， tf.layers , tf.contrib 都将被移除，倘若长期墨守成规，局限在入门时候的一套技术上，迟早会被官方库如此迅速的更新所弃。这也是无可奈何之事。毕竟Tensorflow仍然处于不断改进之中。倘若希望追求一个更加稳定、长期可用的库，keras或许是一个不错的选择。 故而，本教程将基本基于Tensorflow现在的版本(r1.13)展开介绍。本教程既可以看作一个入门教程，也可以看作是本人重新自学新版Tensorflow规范化API的一个手记，故而命名本教程为“手札”。读者不妨跟着笔者的思路，有如与笔者共学一般读下来本教程。","text_tokens":["搭建","基于","effective","手","既","程度","将会","英文","2.0","赖于","最大","和","部分","layers","过时","了","跟着","守成","无可","下来","本","侧重于","使用","亦复如是","也许","时","13","导向","手记","技术","会","工程","英双语","9.0","设计","着","medium","时候","移除","tf","完整","至少","奈何","一些","若","建立","长期","偏门","正在","看作","以为","官方","仍然","翔实","系统","走入","可谓","学习","不得不","可以","更加","新月","本身","4","虽然","值得","底层","之中","检索","似乎","上面","习惯","是","重新","好","稳定","不足","显示","(","用户","应当","之流","写下",".","这","，","时间","往往","tensorflow","莫过于","墨守","命名","方面","不合宜","相比","将","教程","可","规范","r1","api","文档","久","消息","来自","会因","numpy","墨守成","变成","介绍","不错","所有","特别",":","如此","更新","懒惰","github","经常","一套","本人","并","提供","写","zhuanlan","zhihu","集中","值得注意","一般","例子","培养","学","侧重","原","抛弃","功能","“","彼时","故而","注意","project","有如","io","过于","都","时时","50049041","来说","地方","上线","完全","所弃","版本","一个","whats","彻底","库","重于","或许","不妨","现在","帮助","共","www","对","tensorboard","与","笔者","之前","readthedocs","0","不可","但是","支持","入门","best","手札","中层","官网","例如","即将","提示","很","规范化","足取","最新消息","在","内容","另一方","如是","上","不学","看","新版","倘若","版","迟早会","确实","重要","他人","来","处于","难免会","自学","错过","无可奈何","/","展开","事","选择","而","即使","敝","已经","不合","的",",","com","依赖","一","然而","还","双语","维护","快速","地","contrib","也","参照","时兴","从这一点","a0ca48767aff","依赖于","”","起来","读","追求","人","已","2","有着","各个","此时","以下","开始","存取","更","以","全部","过去","不得","一方","一点","基本","四处","入门教程","成规","zh","乃是","毕竟","org","局限","为","所述","最新","代替","入","固然","某些","合宜","keras","那么","不断更新","可用","practices","自带","译者","到","不断","方法","另一方面","遗漏","废案","主要","自","一方面","思路","不断改进","迟早","方便","我们","日新月异","如何","研读","之故","不足取","资料","通过","成","变化","changed","希望","范化","p","围绕","能","前瞻","导致","网络","迅速","被"," ","有","于","中文","蒐集","读者","能圆转","办法","就","and","它",")","墨守成规","之","-","当然","。","几个","问题","莫过","如意","这些","大略","下","、","难免","https","不再","改进","即","页面","贴合","中"],"title":"Tensorflow治学","title_tokens":["tensorflow","治学"]},{"location":"#tensorflow_2","text":"一个标准的Tensorflow工作流可以表示成这样： graph TD st(开始) --> Sess[启动Session] Sess --> ConNet[构建网络] subgraph 构造流程 ioNet>读取网络参数] --> ConNet end subgraph 执行流程 ioDat>导入数据] --> Run ConNet --> Run[执行网络] Run --> ioNetS>保存网络参数] Run --> ioRes>导出结果] end ioRes --> SessCl[关闭Session] SessCl --> ed(结束) classDef styStart fill:#FAE6A9,stroke:#BA9132; classDef styIO fill:#cde498,stroke:#13540c; class st,ed styStart class ioNet,ioNetS,ioDat,ioRes styIO 与一般的计算库不同，Tensorflow的执行流程大体可以分为两步： 构造流程 : 在这一步，Tensorflow根据用户代码构造一个 数据流图(dataflow graph) 。所谓数据流图，指的是由一系列 张量(Tensor) 构成的符号运算集合。就如同一张流程图一样，在这一阶段，尽管用户定义了每一步的运算（从简单的加减乘除到复杂的网络单元），但是没有任何运算被执行。就像一个程序员撰写代码一样，Tensorflow在这一步，将用户的代码转换成它的“机器语言”，但是网络还没有进入被使用的阶段。 执行流程 : 在这一步，Tensorflow将计算用户指定的某个 Tensor 的输出结果。要得到一个Tensor的输出，则必须得计算它一系列的依赖变量。例如，我们已知 y = x_1 + x_2 y = x_1 + x_2 , x_2 = z_1 \\times z_2 x_2 = z_1 \\times z_2 。那么，如果Tensorflow要得到 y y 的结果，它就必须先计算 x_2 x_2 。这个过程被完全地封装起来，从用户看来，我们只需要调用 y y 的输出即可，不需要关心Tensorflow是怎样按照流图完成计算的。 因此，典型的Tensorflow式的语言风格也可以这样划分： 构造流程 : 用户定义整个网络的符号运算，指定网络各个节点的属性、输入和输出。这些代码往往被写成一个函数（例如 def construct (): ） 执行流程 : 创建一个Session，在Session内调用构造函数，然后输入数据，得到并保存输出结果。必要情况下，还需要导入导出网络参数。 这里提到 会话(Session) 。Session如同一个Tensorflow虚拟机，在一个Session打开的时候，设备的计算资源（GPU, CPU, 带宽等）才被加载。Session又如同一个工人，用户撰写的网络构造代码如同车间，输入的数据如同商品，“工人（Session）”利用预定义好的“车间（流图）”将可以快速、批量地生产这些“商品（数据）”。这样地设计保证了一些外围的代码，例如指定网络参数的名称、函数的属性等操作，不需要重复进行，从而确保处理数据的时候，总是执行必要的代码，加快运算速度。 另一方面，构造-执行的结构还封装了许多提高运算效率的特性，例如多线程。尽管用户定义网络构造的时候，所写的代码是按照逻辑顺序的、线性的。但实际运行的时候，Tensorflow可以自行发现网络的哪些部分可以被同时运行，从而利用多核系统的计算资源。这些过程也是被完全封装起来的，用户并不需要花费心思去专门进行这些调整。 须知 在Tensorflow已经转变为Keras导向的现在，Session的调用被Keras API封装了起来，从用户的角度来看，现在已经不再需要手动调用Session。","text_tokens":["从而","现在","所写","(","构建","过程","用户","操作","看来","导出","一张","商品","为","所谓","表示","：","从","与","然后","class","关心","这","st","end","ionet","单元","，","数据","式","stroke","读取","加减","工作","iodat","符号","节点","线性","那么","往往","keras","属性","虚拟","z","tensorflow","但是","和","部分","13540c","复杂","外围","典型","了","例如","ba9132","1","写成","到","方面","生产","专门","系列","将","不","完成","车间","花费","结束","在","义好","定义","风格","connet","stystart","机器","启动","使用","另一方面","同时","另一方","特性","情况","指","这里","关闭","任何","撰写","并不需要","api","哪些","得","没有","加减乘除","td","整个","名称","ed","两步","session","导入","如同","流程图","不同","一方面","即可","加快","总是","心思","输出","程序","导向","这样","提高","计算资源","construct","利用","张量","运算","一系列","简单","执行","带宽","语言","dataflow","结果","许多","预定","数据流","保存","要","工人","构造",":","每","必须","封装","我们","怎样","[","设计","重复","只","这个","标准","流图","ionets","效率","自行","指定","参数","转变","创建","并","必要","时候","成","换成","进入","已经","先","按照","）","转换","_","图","的",",","一般","函数","fill","（","角度","依赖","变量","一","机器语言","逻辑","一些","顺序","x","“","又","还","流","手动","转换成","快速","地","网络","graph","也",">","结构","保证","\\",";","被","调整"," ","须知","像","因此","”","起来","才","某个","大体","sesscl","就","]","输入","等","加载","系统","会话","cpu","styio","+","运行","fae6a9","它","设备","发现","构造函数","一样","classdef","线程","#","gpu","进行","可以","一步","2","如果","需要","实际",")","得到","虚拟机","根据","已知","处理","各个","def","代码","多核","run","-","开始","sess","=","times","多线程","。","完全","构成","则","这些","打开","确保","网络单元","下","但","内","集合","、","一个","来看","程序员","流程","分为","阶段","速度","不再","是","iores","y","cde498","提到","去","多线","批量","tensor","库","一系","尽管","由","划分","资源","一方","调用","subgraph","计算","乘除"],"title":"Tensorflow原理","title_tokens":["tensorflow","原理"]},{"location":"#tensorflow-api","text":"下图显示了当前Tensorflow-API的组织形式 Tensorflow在多个平台上均有部署，包括Python, C++, Java, Javascript, Go等，未来还可能支持更多的语言。然而，不同平台上，API的使用方式和代码风格是大不相同的。例如，Python的语言风格目前已经朝向Keras转变，而Javascript仍倾向于使用中层API；C++和Java偏向于使用底层API编写程序。本教程只针对时兴Python的API编写，除非涉及到特定的专题，不会讨论其他语言上Tensorflow的用法。 一般而言，Tensorflow将API面向划分为三个层次： 高层API (High level) : 包括Estimators和Keras； 中层API (Mid level) : 包括layers, datasets, loss和metrics等具有功能性的函数，例如网络层的定义，Loss Function，对结果的测量函数等； 底层API (Low level) : 包括具体的加减乘除、具有解析式的数学函数、卷积、对Tensor属性的测量等。 从r1.4入门的用户，所接受的训练往往是从底层API开始，使用自己的代码风格构建对应中层API的函数，然后再用自己定义好的中层API构建网络。在这种代码风格的驱使下，用户除了需要定义各个网络层具体的表达式，还需要设计输入输出的接口，用来调用 优化器(optimizer) 的接口等操作。 另一种使用方式，是从中层API开始，直接使用预定义好的网络层构建网络，这样的代码风格会节省一部分时间，相当于几乎不再需要接触底层API，但是在输入输出、网络训练和测试等更高层的模块设计上，和底层API用户的代码风格相似。 Estimators是从r1.4就已经存在的API了，它可以被看成是已经集成在Tensorflow里的完整的网络。因此，Estimators往往适合分发、需求不高的应用，但是并不适合使用Tensorflow的研究者。尽管至今为止，Tensorflow仍然对Estimators倍加推崇，但本教程将完全不涉及这方面的内容。 另一个高层API是 Eager Execution ，从r1.9起，Tensorflow就加入了这种新的使用模式，并且在Tensorflow 2.0中，它仍然将会被保留。Eager摈弃了上述的构造-执行流程，任何对Tensor的定义会被立时计算、并可得到结果。对于需要进行小规模的调试、检查API功能的用户而言更加方便。但是，据一些用户的反响，现在Eager还没有做到和之前API的完全兼容，本教程将基本不涉及Eager的用法。 因此，Keras API将是本教程的重中之重。使用本教程的用户，可以对照目前的官方文档，跟进本教程的思路，自己逐步实现各个project的设计。使用Keras风格的设计，代码量会明显少于前面提到的各种风格（Estimators除外）。事实上， tf.keras 和底层API之间具有一定的兼容，这样的编写风格能让我们在满足自己设计的派生功能的基础上，尽可能使用规范化、预定义的API单元，从而减少代码出错的可能性。通过对本教程TF 1.x版的学习，对未来2.0版的上手也会带来莫大帮助。 金宇琛( @cainmagi )，2019年3月2日 Yuchen Jin( @cainmagi ), Mar. 2, 2019","text_tokens":["一种","手","均","将会","形式","测试","存在","涉及","2.0","除非","加减","和","其他","部分","layers","了","分发","1","；","相同","本","使用","不会","反响","各种","加减乘除","但本","摈弃","尽可","这样","对照","高层","会","low","编写程序","语言","调试","结果","倍加","构造","数学","重中之重","设计","兼容","转变","tf","完整","一些","具有","模块","未来","官方","仍然","而言","所","datasets","等","看成","明显","学习","训练","可以","更加","得到","4","节省","据","底层","2019","是","好","卷积","显示","计算","从而","(","构建","用户","从",".","，","表达","时间","部署","往往","立时","属性","这方面","yuchen","tensorflow","方面","将","教程","可","规范","r1","api","表达式","对应","mar","文档","没有","专题","日","至今","新","程序","这种","派生",":","对于","面向","尽可能","应用","并","另","是从","函数","一般","朝向","功能","接受","器","里","project","因此","优化","需求","c++","high","平台","完全","带来","不高","编写","达式","一个","满足","大不相同","提到","tensor","划分","特定","调用","规模","现在","帮助","操作","金宇琛","对","自己","：","然后","function","加入","做到","之前","实现","go","单元","execution","当于","但是","支持","入门","中层","月","例如","规范化","相当","在","义好","定义","内容","少于","检查","上","年","减少","这方","基础","版","level","几乎","执行","预定","事实","目前","功能性","而","并且","loss","已经","）","的",",","研究","然而","x","相似","还","之间","也","再用","组织","一定","时兴","推崇","让","具体","当前","进行","2","出错","各个","测量","代码","9","起","cainmagi","开始","metrics","更","流程","尽管","jin","上述","基本","接口","前面","小规模","为","讨论","式","keras","输入输出","保留","接触","到","不","模式","对本","风格","一部分","任何","除外","层次","思路","不同","跟进","输出","一部","用法","estimators","可能","包括","方便","我们","网络层","只","偏向","为止","用来","3","java","倾向","解析","通过","驱使","下图","（","针对","范化","事实上","逐步","能","仍","网络","直接","方式","被"," ","有","多个","javascript","研究者","于","适合","一般而言","就","输入","多","它","@","集成","需要","义","量会",")","可能性","除了","-","。","下","三个","、","莫大","不再","python","相当于","eager","mid","中","optimizer","乘除"],"title":"Tensorflow API架构","title_tokens":["tensorflow","架构"," ","api"]},{"location":"#_2","text":"接下来，本教程将会涉及 从线性问题入门 : 如何使用Tensorflow完成一个简单的线性分类设计，我们将从Hello World开始，逐步过渡到一个具有核函数的非线性问题project。 Hello world: 第一个Tensorflow程序。 线性分类: 一个简单的二分类问题。 线性回归: 一个同样简单的，线性拟合问题。 非线性回归: 拟合一个简单的，可以表达出解析式的非线性函数。 非线性分类: 使用线性分类器对非线性分布的数据进行分类。 训练与测试分立 : 从这一章开始，并试图解决几个更加复杂的实际问题。这里涉及到的project相对更大、更完整，训练往往需要一定时间才能完成。因此，在本章，所有项目的训练、测试环节都会分开，我们将从这里开始，使用TensorBoard跟踪我们的训练情况，并介绍如何存取神经网络。 Super Resolution: 使用神经网络进行图像像素插值。 Sparse Coding: 使用线性的词典学习(dictionary learning)来进行图像像素插值。 Generitive Model: 使用时兴的生成模型(Generitive Model)来完成图像风格的转换。 原生的数据管理 : 从这一章开始，我们将纳入Tensorflow自带的数据管理API。实际上，很多用户并不习惯使用这些API，往往倾向于自己完成数据的导入导出。虽然这并非一个复杂的工作，但据Tensorflow的文档，原生的数据管理内部实现了多线程，本身更适合用于提高数据IO的效率。读者可以酌情选择是否需要阅读本章。 使用MINIST数据集: 使用原生的数据管理来IO一个现成的MINIST数据集，这一节改自 官方文档教程 。 使用RNN处理文章: 通过LSTM模型来进行文本分类，并使用原生的数据管理来IO一个现成的IMDB数据集，这一节改自 官方文档教程 。 使用RBM生成音频: 通过限制玻尔兹曼机(RBM)来编写一个简单的音乐生成器，这一节改自 llSourcell/Music_Generator_Demo 。 其他的高级技巧 : 本章将介绍一些特殊的、利用底层API技巧，使得用户能更灵活地定制Tensorflow-keras，从而实现一些仅依靠原生库不能实现的功能。","text_tokens":["从而","(","分布","用户","导出","对","demo","从","tensorboard","自己","跟踪","与","一节","内部","将会","实现","测试","阅读","过渡","这","一章","出","涉及","，","表达","式","数据","时间","sparse","minist","兹曼","工作","线性","keras","往往","tensorflow","生成器","入门","world","词典","解决","纳入","其他","复杂","很多","了","现成","自带","到","同样","完成","将","不","rbm","generator","教程","在","下来","但据","本","玻尔兹曼","风格","仅","是否","使用","generitive","情况","这里","api","音频","文档","自","导入","相对","程序","提高","回归","环节","利用","会","来","简单","介绍","试图","dictionary","更大","机","插值","所有","定制",":","coding","玻尔","接下","特殊","我们","二","设计","生成","神经网络","如何","分开","灵活","像素","/","第一","效率","高级","倾向","第一个","super","图像","解析","并","选择","通过","使得","才能","本章","转换","函数","接下来","的","拟合","完整","_","依靠","rnn","神经","model","逐步","一些","功能","能","分类","文本","音乐","具有","llsourcell","原生","地","网络","learning","project","resolution","一定","分立","项目"," ","hello","时兴","官方","成器","于","用于","io","因此","都","读者","适合","核","并非","管理","学习","非线性","lstm","imdb","线程","酌情","进行","实际","可以","训练","需要","数据管理","集","文章","更加",")","处理","本身","music","虽然","-","开始","存取","多线程","。","几个","问题","这些","更","底层","实际上","编写","分类器","、","一个","习惯","不能","限制","多线","模型","库","神经网","改","技巧"],"title":"教程导读","title_tokens":["教程","导读"]},{"location":"licenses/","text":"协议 (Licenses) ¶ 本站协议 (中文版) ¶ MIT 开源许可协议 版权所有 © 2019, 金宇琛 (cainmagi) 特此向任何得到本软件副本或相关文档的人授权：被授权人有权使用、复制、修改、 合并、出版、发布、散布、再授权和/或贩售软件及软件的副本，及授予被供应人 同等权利，只需服从以下义务： 在软件和软件的所有副本中都必须包含以上版权声明和本许可声明。 该软件是\"按原样\"提供的，没有任何形式的明示或暗示，包括但不限于为特定目的和 不侵权的适销性和适用性的保证担保。在任何情况下，作者或版权持有人，都无权要求 任何索赔，或有关损害赔偿的其他责任。无论在本软件的使用上或其他买卖交易中， 是否涉及合同，侵权或其他行为。 License of this website (English version) ¶ MIT License Copyright © 2019 Yuchen Jin (cainmagi) Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 本站相关项目的协议 ¶ 下面介绍的诸多协议，原则上并无必要列在本条目中（例如MIT License）。列在下侧，主要是为了向诸位支持本文档的开发者致以真诚的谢意。亦将荣耀与在下的感谢致以高天之上的上帝，愿你保守这份文档，成为众人的帮助。 License of Material ¶ MIT License Copyright © 2016 - 2019 Martin Donath Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. License of MkDocs ¶ BSD 2-Clause \"Simplified\" License Copyright © 2014, Tom Christie. All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. License of Jieba3K ¶ The MIT License (MIT) Copyright © 2013 Sun Junyi Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. License of Simple Lightbox ¶ The MIT License (MIT) Copyright © 2018 Damir Brekalo Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. License of MathJax ¶ Apache License 2.0 See the full license here: MathJax license License of mermaid ¶ The MIT License (MIT) Copyright © 2014 - 2018 Knut Sveidqvist Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","text_tokens":["hereby","contract","致以","出版","files","形式","liable","涉及","2.0","包含","列在","和","其他","谢意","原则上","reserved","许可","本","martin","使用","website","明示","情况","business","version","lightbox","¶","开源","授权","版权","full","noninfringement","以上","express","that","is","goods","provided","作者","mermaid","限于","special","之上","donath","适用性","purpose","infringement","exemplary","contributors","included","claim","bsd","协议","相关","性","free","following","so","liability","charge","诸多","whom","conditions","得到","this","reproduce","无论","such","2016","way","notice","高天","sun","kind","direct","2014","source","be","2019","是","or","亦","授权人","(","dealings","rights","knut","substitute","code","are",".","without","再","restriction","有权","，","incidental","procurement","even","yuchen","诸位","use","fitness","需","将","theory","特此","modify","文档","没有","forms","distribution","要求","caused","适用","substantial","介绍","services","所有","保守",":","副本","but","interruption","list","并","必要","possibility","merchantability","non","提供","供应","not","whether","真诚","otherwise","及","apache","保证","项目","licenses","connection","都","copies","jieba3k","strict","同等","permit","服从","下面","permission","有人","版权所有","行为","as","limitation","有关","redistributions","特定","software","warranties","帮助","金宇琛","form","：","与","all","must","sell","redistribution","clause","支持","out","损害赔偿","例如","无","上帝","deal","to","在","感谢","条目","warranty","if","上","\"","列","合并","本站","复制","适销","权利","你","持有","persons","必须","no","原样","开发","tom","/","散布","众人","索赔","distribute","damages","loss","）","see","的",",","an","advised","目的","of","中文版","这份","合同","无权","brekalo",";","particular","copyright","modification","人","为了","implied","profits","该软件","merge","2","以下","向","cainmagi","贩售","consequential","however","junyi","修改","但","other","sublicense","暗示","mkdocs","action","subject","买卖","materials","软件","或","the","disclaimer","jin","license","in","愿","data","为","english","2013","from","publish","by","持有人","furnished","indirect","person","arising","不","成为","above","是否","sveidqvist","associated","任何","主要","damir","发布","documentation","christie","责任","holders","for","交易","原则","包括","simple","文版","只","损害","shall","material","a","下侧","simplified","担保","negligence","obtaining","portions","（","on","holder","2018","with","do","event","met","©","侵权","binary","mit","被","including"," ","中文","授予","声明","any","and","damage","开发者","authors","义务","retain",")","disclaimed","mathjax","赔偿","here","-","。","copy","下","、","permitted","granted","按","limited","荣耀","中","tort"],"title":"协议","title_tokens":["协议"]},{"location":"licenses/#licenses","text":"","text_tokens":[],"title":"协议 (Licenses)","title_tokens":["协议"," ",")","licenses","("]},{"location":"licenses/#_1","text":"MIT 开源许可协议 版权所有 © 2019, 金宇琛 (cainmagi) 特此向任何得到本软件副本或相关文档的人授权：被授权人有权使用、复制、修改、 合并、出版、发布、散布、再授权和/或贩售软件及软件的副本，及授予被供应人 同等权利，只需服从以下义务： 在软件和软件的所有副本中都必须包含以上版权声明和本许可声明。 该软件是\"按原样\"提供的，没有任何形式的明示或暗示，包括但不限于为特定目的和 不侵权的适销性和适用性的保证担保。在任何情况下，作者或版权持有人，都无权要求 任何索赔，或有关损害赔偿的其他责任。无论在本软件的使用上或其他买卖交易中， 是否涉及合同，侵权或其他行为。","text_tokens":["授权人","(","金宇琛","为","：","出版","形式","再","有权","涉及","，","包含","和","其他","持有人","损害赔偿","需","不","特此","许可","在","本","是否","使用","明示","情况","任何","文档","上","\"","没有","开源","授权","版权","发布","以上","要求","适用","合并","责任","复制","适销","权利","所有","持有","交易","包括","副本","必须","原样","作者","限于","只","损害","/","散布","索赔","提供","担保","供应","适用性","的",",","目的","协议","相关","合同","无权","©","侵权","及","性","mit","保证","被"," ","都","授予","声明","人","该软件","同等","义务","服从",")","得到","以下","赔偿","无论","向","cainmagi","贩售","。","修改","下","有人","但","版权所有","行为","、","暗示","2019","按","是","买卖","软件","或","有关","中","特定"],"title":"本站协议 (中文版)","title_tokens":["协议"," ","(","文版",")","中文","中文版","本站"]},{"location":"licenses/#license-of-this-website-english-version","text":"MIT License Copyright © 2019 Yuchen Jin (cainmagi) Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","text_tokens":["license","hereby","in","(","dealings","contract","rights",".","all","files","without","restriction","liable","sell","from","yuchen","publish","use","fitness","furnished","out","person","arising","deal","above","to","modify","associated","warranty","\"","noninfringement","express","documentation","substantial","holders","for","is","persons","provided",":","no","but","/","shall","a","distribute","merchantability","damages","obtaining","purpose",",","not","portions","an","included","whether","of","claim","with","do","event","©","otherwise","mit","free","including"," ","particular","following","connection","so","liability","copyright","copies","charge","any","and","implied","whom","authors","merge","conditions","permit",")","this","cainmagi","notice","copy","permission","other","as","sublicense","kind","granted","action","2019","subject","be","limitation","or","limited","the","jin","tort","software","warranties"],"title":"License of this website (English version)","title_tokens":["english"," ","license","(","this","version",")","website","of"]},{"location":"licenses/#_2","text":"下面介绍的诸多协议，原则上并无必要列在本条目中（例如MIT License）。列在下侧，主要是为了向诸位支持本文档的开发者致以真诚的谢意。亦将荣耀与在下的感谢致以高天之上的上帝，愿你保守这份文档，成为众人的帮助。","text_tokens":["license","为了","并","必要","诸多","主要","下侧","愿","帮助","文档","致以","开发者","与","）","的","（","，","向","列","下面","列在","。","介绍","协议","真诚","诸位","支持","这份","下","谢意","你","例如","无","高天","保守","上帝","原则","mit","原则上"," ","是","将","成为","荣耀","在","开发","感谢","本","条目","中","亦","之上","众人"],"title":"本站相关项目的协议","title_tokens":["协议","相关","的","本站","项目"]},{"location":"licenses/#license-of-material","text":"MIT License Copyright © 2016 - 2019 Martin Donath Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","text_tokens":["license","hereby","in","(","dealings","contract","rights",".","all","files","without","restriction","liable","sell","from","publish","use","fitness","furnished","out","person","arising","deal","above","to","modify","martin","associated","warranty","\"","express","documentation","substantial","holders","for","is","persons","provided",":","no","but","/","shall","a","distribute","merchantability","non","damages","donath","obtaining","purpose",",","infringement","not","portions","an","included","whether","of","claim","with","do","event","©","otherwise","mit","free","including"," ","particular","following","connection","so","liability","copyright","copies","charge","any","and","implied","whom","authors","merge","conditions","permit",")","this","-","2016","notice","copy","permission","other","as","sublicense","kind","granted","action","2019","subject","be","limitation","or","limited","the","tort","software","warranties"],"title":"License of Material","title_tokens":["of"," ","license","material"]},{"location":"licenses/#license-of-mkdocs","text":"BSD 2-Clause \"Simplified\" License Copyright © 2014, Tom Christie. All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","text_tokens":["license","in","(","contract","data","rights","substitute","code","form","are",".","all","without","liable","must","incidental","procurement","even","redistribution","clause","by","use","fitness","indirect","out","arising","reserved","theory","above","to","business","if","\"","forms","distribution","express","documentation","christie","caused","that","holders","for","is","goods","services","provided",":","no","but","tom","special","/","shall","interruption","list","a","possibility","merchantability","simplified","damages","loss","negligence","purpose",",","not","exemplary","contributors","on","advised","holder","whether","of","with","bsd","event","met","©","binary","otherwise",";","including"," ","particular","following","liability","copyright","modification","any","and","implied","damage","strict","profits","conditions","2","retain",")","this","reproduce","disclaimed","such","-","consequential","way","notice","however","other","as","permitted","direct","2014","source","be","or","materials","limited","the","disclaimer","redistributions","tort","software","warranties"],"title":"License of MkDocs","title_tokens":["of"," ","license","mkdocs"]},{"location":"licenses/#license-of-jieba3k","text":"The MIT License (MIT) Copyright © 2013 Sun Junyi Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","text_tokens":["license","hereby","in","(","dealings","contract","rights",".","all","files","without","2013","restriction","liable","sell","from","publish","use","fitness","furnished","out","person","arising","deal","above","to","modify","associated","warranty","\"","noninfringement","express","documentation","substantial","holders","for","is","persons","provided",":","no","but","/","shall","a","distribute","merchantability","damages","obtaining","purpose",",","not","portions","an","included","whether","of","claim","with","do","event","©","otherwise","mit","free","including"," ","particular","following","connection","so","liability","copyright","copies","charge","any","and","implied","whom","authors","merge","conditions","permit",")","this","notice","copy","junyi","permission","other","as","sublicense","sun","kind","granted","action","subject","be","limitation","or","limited","the","tort","software","warranties"],"title":"License of Jieba3K","title_tokens":["of"," ","license","jieba3k"]},{"location":"licenses/#license-of-simple-lightbox","text":"The MIT License (MIT) Copyright © 2018 Damir Brekalo Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","text_tokens":["license","hereby","in","(","dealings","contract","rights",".","all","files","without","restriction","liable","sell","from","publish","use","fitness","furnished","out","person","arising","deal","above","to","modify","associated","warranty","\"","damir","noninfringement","express","documentation","substantial","holders","for","is","persons","provided",":","no","but","/","shall","a","distribute","merchantability","damages","obtaining","purpose",",","not","portions","an","included","2018","whether","of","claim","with","do","event","brekalo","©","otherwise","mit","free","including"," ","particular","following","connection","so","liability","copyright","copies","charge","any","and","implied","whom","authors","merge","conditions","permit",")","this","notice","copy","permission","other","as","sublicense","kind","granted","action","subject","be","limitation","or","limited","the","tort","software","warranties"],"title":"License of Simple Lightbox","title_tokens":[" ","simple","license","lightbox","of"]},{"location":"licenses/#license-of-mathjax","text":"Apache License 2.0 See the full license here: MathJax license","text_tokens":["full",":"," ","license","the","2.0","mathjax","here","apache","see"],"title":"License of MathJax","title_tokens":["of"," ","license","mathjax"]},{"location":"licenses/#license-of-mermaid","text":"The MIT License (MIT) Copyright © 2014 - 2018 Knut Sveidqvist Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","text_tokens":["license","hereby","in","(","dealings","contract","knut","rights",".","all","files","without","restriction","liable","sell","from","publish","use","fitness","furnished","out","person","arising","deal","above","to","modify","sveidqvist","associated","warranty","\"","noninfringement","express","documentation","substantial","holders","for","is","persons","provided",":","no","but","/","shall","a","distribute","merchantability","damages","obtaining","purpose",",","not","portions","an","included","2018","whether","of","claim","with","do","event","©","otherwise","mit","free","including"," ","particular","following","connection","so","liability","copyright","copies","charge","any","and","implied","whom","authors","merge","conditions","permit",")","this","-","notice","copy","permission","other","as","sublicense","kind","granted","2014","action","subject","be","limitation","or","limited","the","tort","software","warranties"],"title":"License of mermaid","title_tokens":["of"," ","license","mermaid"]},{"location":"release-notes/","text":"更新记录 ¶ 大版本更新 ¶ 在此记录本文档的主要更新，读者可以在此确认经过更新后，本文档添加了哪些主要的内容、话题。 0.1 @ February 25, 2019 ¶ 正式立项，开始本文档的撰写工作。目前尚处于未完成状态，计划包括： Tensorflow 1.12 入门教程 从线性问题入门 80% 训练与测试分立 0% 原生的数据管理 0% 其他的高级技巧 0% Tensorflow 2.0 入门教程 0% Tensorflow 第三方扩展库 入门教程 0% 局部更新记录 ¶ 0.22 @ March 17, 2019 ¶ 完成“从线性问题入门”专题下的 非线性回归 ； 微调样式表(stylesheet)文件； 修正“从线性问题入门”专题下的 线性回归 的一些笔误； 将MathJax的默认渲染修改为HTML-CSS。 0.20 @ March 12, 2019 ¶ 完成“从线性问题入门”专题下的 线性回归 ； 微调样式表(stylesheet)文件； 修正前文的一些笔误。 0.18-r1.13 @ March 9, 2019 ¶ 由于Tensorflow的新版 r1.13 发行版预编译包开始支持CUDA 10，本文的内容全部根据 r1.13 版进行调整。特别注意这个星期是Tensorflow 2.0-alpha 横空出世的日子，可喜可贺，可喜可贺。 0.18 @ March 6, 2019 ¶ 完善“从线性问题入门”专题下的 线性分类 ，补充了一些概念便于初学者理解。 0.17 @ March 5, 2019 ¶ 完成“从线性问题入门”专题下的 线性分类 ； 修正前文的一些笔误。 0.15 @ March 4, 2019 ¶ 完成“从线性问题入门”专题下的 本章总说 和 Hello world! ； 微调图片链接， MathJax 的显示特性。 0.12 @ March 3, 2019 ¶ 补完扉页。未来可能会调整 教程导读 ； 修复 Arithmatex 对 MathJax 的引入； 引入 mermaid 库，用于绘制示意图。 0.11 @ February 25, 2019 ¶ 提交 Google Analytics 和 Google Search Console 的账户关联资料； 提交 Disqus 关联资料。 0.10 @ February 25, 2019 ¶ 正式立项，并撰写扉页的一部分。","text_tokens":["0.10","(","记录","17","console","80","补完","为","对","从","：","账户","与",".","测试","%","引入","2.0","横空出世","，","数据","完善","链接","工作","0","线性","默认","笔误","tensorflow","支持","入门","局部","其他","html","和","world","部分","样式","february","6","了","google","cuda","；","1.12","完成","将","0.15","0.11","绘制","日子","在","教程","导读","本","内容","预","示意图","r1","特性","一部分","撰写","主要","文档","哪些","¶","新版","专题","编译","13","版","march","扩展","回归","发行版","arithmatex","会","出世","一部","处于","本文","补充","学者","!","初学者","添加","可能","特别","包括","更新","mermaid","关联","可喜","样式表","这个","三方","高级","目前","理解","3","25","资料","并","经过","0.22","本章","图片链接","话题","的",",","意图","星期","微调","文件","一些","由于","分类","横空","5","未","“","便于","原生","大","概念","注意","未来","调整","分立"," ","空出","hello","前文","立项","图片","用于","修复","”","读者","渲染","search","确认","可贺","第三方","10","0.17","@","管理","可喜可贺","0.18","0.12","非线性","示意","总说","0.1","后","数据管理","训练","可以","12","进行","stylesheet",")","记录本","提交","根据","状态","mathjax","9","此","4","-","开始","disqus","。","第三","问题","alpha","修正","修改","下","扉页","版本","初学","、","全部","css","2019","正式","是","发行","0.20","尚","库","包","技巧","计划","analytics","显示","入门教程"],"title":"更新记录","title_tokens":["记录","更新"]},{"location":"release-notes/#_1","text":"","text_tokens":[],"title":"更新记录","title_tokens":["记录","更新"]},{"location":"release-notes/#_2","text":"在此记录本文档的主要更新，读者可以在此确认经过更新后，本文档添加了哪些主要的内容、话题。","text_tokens":["记录","主要","经过","文档","哪些","后","话题","的","可以","记录本","，","此","。","了","添加","、","更新","在","本","读者","内容","确认"],"title":"大版本更新","title_tokens":["版本","大","更新"]},{"location":"release-notes/#01-february-25-2019","text":"正式立项，开始本文档的撰写工作。目前尚处于未完成状态，计划包括： Tensorflow 1.12 入门教程 从线性问题入门 80% 训练与测试分立 0% 原生的数据管理 0% 其他的高级技巧 0% Tensorflow 2.0 入门教程 0% Tensorflow 第三方扩展库 入门教程 0%","text_tokens":["撰写","第三方","文档","80","管理","从","：","与","数据管理","训练","的","测试","%","状态","扩展","2.0","，","数据","工作","开始","0","线性","。","处于","未","tensorflow","问题","入门","第三","其他","原生","包括","分立","正式","完成"," ","1.12","入门教程","立项","尚","教程","本","库","技巧","计划","三方","高级","目前"],"title":"0.1 @ February 25, 2019","title_tokens":["2019"," ","25",",","february","@","0.1"]},{"location":"release-notes/#_3","text":"","text_tokens":[],"title":"局部更新记录","title_tokens":["更新","局部","记录"]},{"location":"release-notes/#022-march-17-2019","text":"完成“从线性问题入门”专题下的 非线性回归 ； 微调样式表(stylesheet)文件； 修正“从线性问题入门”专题下的 线性回归 的一些笔误； 将MathJax的默认渲染修改为HTML-CSS。","text_tokens":["(","为","专题","非线性","从","的","stylesheet",")","微调","mathjax","文件","回归","一些","-","线性","默认","笔误","。","问题","“","入门","修正","修改","html","下","样式","；","css","完成"," ","将","”","样式表","渲染"],"title":"0.22 @ March 17, 2019","title_tokens":["2019"," ",",","march","17","@","0.22"]},{"location":"release-notes/#020-march-12-2019","text":"完成“从线性问题入门”专题下的 线性回归 ； 微调样式表(stylesheet)文件； 修正前文的一些笔误。","text_tokens":["(","专题","从","的","stylesheet",")","微调","文件","回归","一些","线性","笔误","。","问题","“","入门","修正","下","样式","；","完成"," ","前文","”","样式表"],"title":"0.20 @ March 12, 2019","title_tokens":["2019","12"," ",",","march","0.20","@"]},{"location":"release-notes/#018-r113-march-9-2019","text":"由于Tensorflow的新版 r1.13 发行版预编译包开始支持CUDA 10，本文的内容全部根据 r1.13 版进行调整。特别注意这个星期是Tensorflow 2.0-alpha 横空出世的日子，可喜可贺，可喜可贺。","text_tokens":["可贺","10","新版","可喜可贺","编译","13",".","进行","的","版","星期","根据","2.0","横空出世","，","发行版","开始","由于","-","出世","横空","。","本文","tensorflow","支持","alpha","注意","特别","cuda","全部","调整"," ","是","空出","发行","日子","可喜","包","这个","预","内容","r1"],"title":"0.18-r1.13 @ March 9, 2019","title_tokens":["2019","."," ",",","march","@","0.18","9","-","13","r1"]},{"location":"release-notes/#018-march-6-2019","text":"完善“从线性问题入门”专题下的 线性分类 ，补充了一些概念便于初学者理解。","text_tokens":["专题","从","的","完善","，","一些","线性","分类","。","问题","“","便于","入门","补充","下","概念","学者","了","初学","初学者"," ","”","理解"],"title":"0.18 @ March 6, 2019","title_tokens":["2019"," ",",","march","@","6","0.18"]},{"location":"release-notes/#017-march-5-2019","text":"完成“从线性问题入门”专题下的 线性分类 ； 修正前文的一些笔误。","text_tokens":["的","问题","完成","“","入门"," ","；","修正","前文","笔误","下","”","专题","从","线性","分类","一些","。"],"title":"0.17 @ March 5, 2019","title_tokens":["2019","5"," ",",","march","0.17","@"]},{"location":"release-notes/#015-march-4-2019","text":"完成“从线性问题入门”专题下的 本章总说 和 Hello world! ； 微调图片链接， MathJax 的显示特性。","text_tokens":["特性","专题","本章","从","图片链接","总说","的","微调","，","mathjax","链接","线性","。","问题","“","和","入门","world","下","!","；","完成"," ","hello","图片","”","显示"],"title":"0.15 @ March 4, 2019","title_tokens":["2019"," ","0.15",",","march","@","4"]},{"location":"release-notes/#012-march-3-2019","text":"补完扉页。未来可能会调整 教程导读 ； 修复 Arithmatex 对 MathJax 的引入； 引入 mermaid 库，用于绘制示意图。","text_tokens":["补完","示意","对","的","意图","引入","mathjax","，","arithmatex","会","。","扉页","可能","未来","；","调整"," ","绘制","mermaid","用于","教程","修复","导读","库","示意图"],"title":"0.12 @ March 3, 2019","title_tokens":["2019"," ",",","march","@","0.12","3"]},{"location":"release-notes/#011-february-25-2019","text":"提交 Google Analytics 和 Google Search Console 的账户关联资料； 提交 Disqus 关联资料。","text_tokens":["disqus","的"," ","资料","和","；","提交","关联","console","google","analytics","search","账户","。"],"title":"0.11 @ February 25, 2019","title_tokens":["2019","0.11"," ","25",",","february","@"]},{"location":"release-notes/#010-february-25-2019","text":"正式立项，并撰写扉页的一部分。","text_tokens":["正式","的","一部分","并","撰写","立项","部分","扉页","，","一部","。"],"title":"0.10 @ February 25, 2019","title_tokens":["2019"," ","25",",","0.10","february","@"]},{"location":"book-1-x/chapter-1/","text":"从线性问题入门 ¶ 摘要 本章将从线性问题入手，讨论最简单的分类与回归问题。我们将随机生成指定分布的数据，通过理论值，检查实验效果。这些简单的、解析的问题，可以提供读者一个直观的感受，并帮助读者快速上手Tensorflow的基本概念与运用。本章中，我们不会涉及任何数据存取、跟踪测度方面的概念，也不会将训练和测试分开，旨在使读者能集中心思到代码规范和Tensorflow的基本功能上。 漫谈线性问题 ¶ 在机器学习领域，线性问题既简单也不简单。目前神经网络主要是指多层、非凸的网络结构，常常用来解复杂的、难以推导的问题。但这并不意味着线性问题容易解决。相反，在很多情况下，线性问题是解不唯一的(undetermined)，解不稳定的(ill-posed/ill-conditioned)，条件的(constrained)。同时，为了得到一个快速收敛的、高质量的解，即使对线性问题，人们也在不断提出、改进解法。例如ISTA, AMP, PGD, LISTA, vAMP等算法，都用来解线性问题。在此不作详细展开。 我们已经知道，一个线性函数具有可加性，和一次齐次性，亦即 \\begin{align} f(x_1 + x_2) &= f(x_1) + f(x_2), \\\\ f(\\alpha x) &= \\alpha f(x). \\end{align} 因此，求解一个线性问题，我们需要将问题纯粹以 线性函数 进行描述。例如， \\begin{align} \\mathbf{y} \\sim \\mathbf{A}\\mathbf{x}. \\end{align} 具体而言， \\mathbf{x} \\mathbf{x} 是我们的已知数据， \\mathbf{y} \\mathbf{y} 是我们的未知量，我们需要找到一个合适的 \\mathbf{A} \\mathbf{A} 来确保 \\mathbf{x} \\mathbf{x} 能拟合到 \\mathbf{y} \\mathbf{y} 。如果此处 \\mathbf{y} \\in \\{0,~1\\}^p \\mathbf{y} \\in \\{0,~1\\}^p 是一个代表p类-分类的向量，那么这就是一个线性分类问题；相反，如果此处 \\mathbf{y} \\in \\mathbb{R}^p \\mathbf{y} \\in \\mathbb{R}^p 在连续p维空间取值，那么这就是一个线性回归问题。 线性问题与凸问题 ¶ 请注意，虽然我们在此处提到“ 线性问题 (Linear problem) ”，但我们指的并非“ 线性规划 (Linear programming) ”。虽然严格意义上，线性规划才是真正的线性问题，但我们在此处尚不讨论线性规划相关的内容，而是着眼于机器学习应用最普遍的两个领域， 分类 和 回归 上。实际上，这两种问题虽然求解的是线性函数，但本质上是凸问题。 例如，如果我们要求解回归问题，通常可以表述成 \\begin{equation} \\begin{aligned} \\arg \\min_{\\mathbf{A}}~& \\sum_{i=1}^N \\mathcal{L}(\\mathbf{A},~\\mathbf{x}_i,~\\mathbf{y}_i), \\\\ \\mathcal{L}(\\mathbf{A},~\\mathbf{x},~\\mathbf{y}) &= \\lVert \\mathbf{y} - \\mathbf{A}\\mathbf{x} \\rVert^2_2. \\end{aligned} \\end{equation} 虽然我们求解的模型 \\mathbf{A} \\mathbf{A} 是线性的，但我们优化的函数对象 \\mathcal{L} \\mathcal{L} 是一个 凸函数 (convex function) 。在此，我们可以将这个标量函数(同时也是凸函数)表述为 \\begin{align} \\forall~\\alpha,~\\beta,~\\mathbf{x}_1,~\\mathbf{x}_2,~\\mathcal{L}(\\alpha\\mathbf{x}_1 + \\beta\\mathbf{x}_2) \\leqslant \\alpha\\mathcal{L}(\\mathbf{x}_1) + \\beta\\mathcal{L}(\\mathbf{x}_2). \\end{align} 我们将这个问题表述为 最小二乘问题(Least-square problem) 。正是由于 \\mathbf{A} \\mathbf{A} 是线性的， \\mathcal{L} \\mathcal{L} 才能被确保为一个凸函数，进而，我们才能确保上述问题能得到精确的全局最小值解。 知悉Tensorflow ¶ 在本章接下来的内容里，我们将探讨Tensorflow如何求解一些简单的问题。对于初次上手的读者而言，在安装Tensorflow，亲自开始写一些project之前，笔者推荐你到这个游乐场“抢鲜体验”一番， Tensorflow Playground 在这个在线页面里，用户不需要有任何编程知识，可以通过直观的操作界面，建立一个简单的 多层感知机网络(有时也叫做Artificial Neural Network, ANN) ，并且实时观测网络的性能和测度。它提供了几个简单的二维数据集，供用户体验不同的数据集下，各种分类、回归问题的合宜解法。如果读者已经对神经网络的基本原理有所了解，相信能通过这个小小的实验场达到心有灵犀。我们在本章所做的project和demo，大体不跳出这个试验场的范畴，只是会略微复杂一点而已。 本章要点 ¶ 下图展示了通过本章学习，能了解到的概念： graph LR st(Hello world!) --> linclas(线性分类) linclas --> linreg(线性回归) linreg --> nonlinreg(非线性回归) nonlinreg --> ed(非线性分类) lp[感知机] --> linclas sigma[Logsitc回归] --> linclas ce[交叉熵] --> linclas opt[优化器] --> linreg argpar[项目选项] --> linreg para[参数回归] --> nonlinreg sdlayer[自定义层] --> nonlinreg kernel[核函数] --> ed classDef styStart fill:#FAE6A9,stroke:#BA9132; class st,linclas,linreg,nonlinreg,ed styStart Hello world : 首先，在本节，读者将了解Tensorflow的安装方法，并编写通过第一个简单的Tensorflow程序。 线性分类 : 本节通过解一个简单的二分类问题，我们将引入单层感知机、Logistic回归和交叉熵的概念，并且实验结果进行可视化。 线性回归 : 本节通过解一个与上一节难度相仿的，简单的回归问题，另读者能对比不同优化器的性能、特点，并介绍如何在项目中进行arugument parsing(引入项目的可选项)。 非线性回归 : 本节将修改上一节回归问题的激活函数，将线性的回归问题推广到解析函数参数回归的范畴。同时介绍自行编写网络层(类API)的方法。 非线性分类 : 本节将通过上一节的参数回归，引入核函数的概念，将线性分类问题推广到非线性空间里。","text_tokens":["基本概念","本原","对比","既","sigma","一节","class","高质","测试","end","st","涉及","人们","线性","理论值","和","了","1","；","意味着","下来","本","感知机","parsing","同时","不会","情况","达到","心有灵犀","f","各种","漫谈","叫做","¶","least","ed","交叉","意味","观测","难度","constrained","logsitc","相仿","square","略微","回归","^","会","收敛","结果","要点","探讨","posed","层","这个","全局","第一","自行","aligned","了解","提出","基本功","_","接下来","fill","神经","知悉","找到","未知量","一些","分类","知道","意义","相关","具有","熵","建立","界面","性","\\","通常","运用","&","而言","线性规划","所","核","等","并非","学习","普遍","}","训练","可以","得到","上手","已知","此","虽然","初次","旨在","实际上","align","leqslant","空间","lvert","是","尚","稳定","高质量","亦","小小","可选","(","分布","用户","从","跟踪",".","对象","标量","这","vamp","引入","严格","多层","，","实时","范畴","首先","tensorflow","很多","激活","方面","rvert","两种","将","stystart","规范","指","求解","api","编程","原理","供","conditioned","心思","程序","要求","介绍","入手",":","感知","自定","接下","二","[","对于","随机","第一个","应用","并","难以","提供","写","才能","beta","equation","另","集中","函数","效果","本节","undetermined","功能","由于","纯粹","器","“","概念","里","注意","project","最小值","代表",">","项目","因此","都","常常","优化","mathbf","i","+","sdlayer","二维","fae6a9","性能","logistic","artificial","min","跳出","有时","sum","r","ce","维空间","编写","一个","亲自","y","非凸","lp","未知","提到","problem","做","神经网","有所","相信","使","帮助","规划","操作","对","：","function","与","直观","笔者","之前","解不","stroke","0","取值","可选项","入门","复杂","nonlinreg","例如","基本原理","在","一次","定义","内容","体验","检查","单层","arugument","游乐场","合适","ista","上","sim","着眼","可加性","来","简单","摘要","arg","正是","!","你","集下","lr","ann","可加","playground","神经网络","分开","理论","/","目前","指定","pgd","展开","描述","并且","即使","推导","已经","质量","的",",","齐次","此处","forall","容易","x","进而","领域","l","快速","安装","graph","也","convex","游乐",";","不作","凸函数","凸","linreg","”","大体","向量","二乘","为了","具体","classdef","进行","类","2","如果","一番","集","代码","开始","存取","最","可视","mathbb","linear","alpha","确保","修改","以","但","kernel","lista","试验","最小","模型","上述","一点","基本","表述","in","为","相反","demo","讨论","感受","programming","知识","网络结构","算法","amp","数据","合宜","{","~","那么","world","解决","特点","ba9132","抢鲜","到","不","就是","基本功能","不断","知机","方法","机器","任何","主要","network","精确","请","唯一","操作界面","不同","推广","展示","在线","argpar","linclas","解","测度","本质","我们","生成","网络层","灵犀","如何","着眼于","用来","试验场","参数","n","解析","a","通过","成","函数参数","begin","条件","本章","下图","拟合","只是","p","能","节","真正","网络","结构","被","实验场"," ","有","hello","opt","可视化","读者","才","]","自定义","推荐","它","实验","非线性","neural","ill","#","实际","需要","mathcal","选项",")","而已","两个","para","而是","-","=","连续","。","几个","问题","这些","下","解法","、","详细","改进","即","页面","中","小小的"],"title":"本章总说","title_tokens":["总说","本章"]},{"location":"book-1-x/chapter-1/#_1","text":"摘要 本章将从线性问题入手，讨论最简单的分类与回归问题。我们将随机生成指定分布的数据，通过理论值，检查实验效果。这些简单的、解析的问题，可以提供读者一个直观的感受，并帮助读者快速上手Tensorflow的基本概念与运用。本章中，我们不会涉及任何数据存取、跟踪测度方面的概念，也不会将训练和测试分开，旨在使读者能集中心思到代码规范和Tensorflow的基本功能上。","text_tokens":["随机","检查","基本概念","任何","解析","并","使","通过","分布","帮助","提供","上","实验","基本功","本章","从","讨论","与","感受","跟踪","集中","直观","训练","的","可以","心思","测试","效果","上手","涉及","，","数据","代码","回归","功能","存取","线性","能","分类","最","简单","。","旨在","问题","摘要","理论值","这些","tensorflow","和","概念","快速","、","一个","也","到","入手","方面","测度","运用"," ","将","我们","生成","基本功能","分开","读者","理论","基本","中","规范","不会","指定"],"title":"从线性问题入门","title_tokens":["问题","线性","入门","从"]},{"location":"book-1-x/chapter-1/#_2","text":"在机器学习领域，线性问题既简单也不简单。目前神经网络主要是指多层、非凸的网络结构，常常用来解复杂的、难以推导的问题。但这并不意味着线性问题容易解决。相反，在很多情况下，线性问题是解不唯一的(undetermined)，解不稳定的(ill-posed/ill-conditioned)，条件的(constrained)。同时，为了得到一个快速收敛的、高质量的解，即使对线性问题，人们也在不断提出、改进解法。例如ISTA, AMP, PGD, LISTA, vAMP等算法，都用来解线性问题。在此不作详细展开。 我们已经知道，一个线性函数具有可加性，和一次齐次性，亦即 \\begin{align} f(x_1 + x_2) &= f(x_1) + f(x_2), \\\\ f(\\alpha x) &= \\alpha f(x). \\end{align} 因此，求解一个线性问题，我们需要将问题纯粹以 线性函数 进行描述。例如， \\begin{align} \\mathbf{y} \\sim \\mathbf{A}\\mathbf{x}. \\end{align} 具体而言， \\mathbf{x} \\mathbf{x} 是我们的已知数据， \\mathbf{y} \\mathbf{y} 是我们的未知量，我们需要找到一个合适的 \\mathbf{A} \\mathbf{A} 来确保 \\mathbf{x} \\mathbf{x} 能拟合到 \\mathbf{y} \\mathbf{y} 。如果此处 \\mathbf{y} \\in \\{0,~1\\}^p \\mathbf{y} \\in \\{0,~1\\}^p 是一个代表p类-分类的向量，那么这就是一个线性分类问题；相反，如果此处 \\mathbf{y} \\in \\mathbb{R}^p \\mathbf{y} \\in \\mathbb{R}^p 在连续p维空间取值，那么这就是一个线性回归问题。","text_tokens":["in","(","相反","对","既",".","高质","网络结构","算法","这","end","vamp","amp","多层","，","解不","人们","数据","0","{","线性","取值","~","那么","和","解决","复杂","很多","例如","1","到","；","不","将","就是","意味着","在","不断","一次","机器","同时","情况","指","f","求解","主要","合适","ista","唯一","conditioned","sim","意味","constrained","回归","可加性","^","来","简单","收敛","解","可加","我们","神经网络","posed","/","用来","目前","展开","pgd","并","a","难以","描述","即使","提出","begin","推导","条件","已经","质量","函数","_","的",",","拟合","齐次","此处","神经","容易","找到","undetermined","未知量","p","纯粹","x","能","知道","分类","具有","领域","快速","网络","也","性","代表","结构","\\","不作"," ","&","因此","而言","都","常常","等","向量","mathbf","为了","+","具体","学习","ill","}","进行","需要","类","2","如果",")","得到","已知","此","-","=","连续","r","。","mathbb","问题","alpha","确保","以","下","但","align","解法","维空间","、","空间","一个","lista","详细","是","改进","y","非凸","即","未知","神经网","稳定","高质量","亦"],"title":"漫谈线性问题","title_tokens":["问题","漫谈","线性"]},{"location":"book-1-x/chapter-1/#_3","text":"请注意，虽然我们在此处提到“ 线性问题 (Linear problem) ”，但我们指的并非“ 线性规划 (Linear programming) ”。虽然严格意义上，线性规划才是真正的线性问题，但我们在此处尚不讨论线性规划相关的内容，而是着眼于机器学习应用最普遍的两个领域， 分类 和 回归 上。实际上，这两种问题虽然求解的是线性函数，但本质上是凸问题。 例如，如果我们要求解回归问题，通常可以表述成 \\begin{equation} \\begin{aligned} \\arg \\min_{\\mathbf{A}}~& \\sum_{i=1}^N \\mathcal{L}(\\mathbf{A},~\\mathbf{x}_i,~\\mathbf{y}_i), \\\\ \\mathcal{L}(\\mathbf{A},~\\mathbf{x},~\\mathbf{y}) &= \\lVert \\mathbf{y} - \\mathbf{A}\\mathbf{x} \\rVert^2_2. \\end{aligned} \\end{equation} 虽然我们求解的模型 \\mathbf{A} \\mathbf{A} 是线性的，但我们优化的函数对象 \\mathcal{L} \\mathcal{L} 是一个 凸函数 (convex function) 。在此，我们可以将这个标量函数(同时也是凸函数)表述为 \\begin{align} \\forall~\\alpha,~\\beta,~\\mathbf{x}_1,~\\mathbf{x}_2,~\\mathcal{L}(\\alpha\\mathbf{x}_1 + \\beta\\mathbf{x}_2) \\leqslant \\alpha\\mathcal{L}(\\mathbf{x}_1) + \\beta\\mathcal{L}(\\mathbf{x}_2). \\end{align} 我们将这个问题表述为 最小二乘问题(Least-square problem) 。正是由于 \\mathbf{A} \\mathbf{A} 是线性的， \\mathcal{L} \\mathcal{L} 才能被确保为一个凸函数，进而，我们才能确保上述问题能得到精确的全局最小值解。","text_tokens":["(","规划","为","programming","讨论","function",".","对象","标量","这","end","严格","，","{","线性","~","和","例如","1","rvert","两种","不","将","在","机器","内容","同时","指","求解","上","least","精确","请","square","要求","着眼","回归","^","arg","正是","解","本质","我们","着眼于","这个","全局","应用","n","a","成","aligned","begin","才能","beta","equation","函数","_","的",",","此处","forall","由于","x","意义","分类","能","相关","“","进而","领域","l","真正","注意","也","convex","最小值","\\","被","通常"," ","凸函数","凸","&","”","才","线性规划","优化","二乘","mathbf","并非","i","+","学习","普遍","}","min","实际","可以","mathcal","如果","2",")","得到","两个","sum","此","虽然","而是","-","=","最","。","linear","问题","alpha","确保","实际上","但","align","leqslant","lvert","一个","最小","是","y","提到","problem","尚","模型","上述","表述"],"title":"线性问题与凸问题","title_tokens":["问题","线性","与","凸"]},{"location":"book-1-x/chapter-1/#tensorflow","text":"在本章接下来的内容里，我们将探讨Tensorflow如何求解一些简单的问题。对于初次上手的读者而言，在安装Tensorflow，亲自开始写一些project之前，笔者推荐你到这个游乐场“抢鲜体验”一番， Tensorflow Playground 在这个在线页面里，用户不需要有任何编程知识，可以通过直观的操作界面，建立一个简单的 多层感知机网络(有时也叫做Artificial Neural Network, ANN) ，并且实时观测网络的性能和测度。它提供了几个简单的二维数据集，供用户体验不同的数据集下，各种分类、回归问题的合宜解法。如果读者已经对神经网络的基本原理有所了解，相信能通过这个小小的实验场达到心有灵犀。我们在本章所做的project和demo，大体不跳出这个试验场的范畴，只是会略微复杂一点而已。","text_tokens":["相信","(","用户","操作","本原","对","demo","知识","直观","笔者","之前","多层","，","实时","数据","合宜","范畴","tensorflow","和","复杂","了","抢鲜","到","不","将","基本原理","在","知机","下来","感知机","内容","体验","达到","心有灵犀","游乐场","求解","任何","各种","编程","network","叫做","原理","供","操作界面","不同","观测","在线","略微","回归","会","简单","你","集下","测度","ann","感知","接下","我们","playground","探讨","神经网络","如何","对于","灵犀","这个","试验场","通过","了解","提供","并且","写","已经","本章","接下来","的",",","神经","只是","一些","能","分类","“","里","网络","安装","界面","project","建立","也","游乐","实验场"," ","有","而言","”","读者","所","大体","二维","推荐","它","实验","性能","neural","artificial","需要","可以","如果","一番","集","有时",")","跳出","而已","上手","开始","初次","。","几个","问题","解法","、","一个","试验","亲自","页面","做","神经网","一点","基本","有所","小小","小小的"],"title":"知悉Tensorflow","title_tokens":["知悉","tensorflow"]},{"location":"book-1-x/chapter-1/#_4","text":"下图展示了通过本章学习，能了解到的概念： graph LR st(Hello world!) --> linclas(线性分类) linclas --> linreg(线性回归) linreg --> nonlinreg(非线性回归) nonlinreg --> ed(非线性分类) lp[感知机] --> linclas sigma[Logsitc回归] --> linclas ce[交叉熵] --> linclas opt[优化器] --> linreg argpar[项目选项] --> linreg para[参数回归] --> nonlinreg sdlayer[自定义层] --> nonlinreg kernel[核函数] --> ed classDef styStart fill:#FAE6A9,stroke:#BA9132; class st,linclas,linreg,nonlinreg,ed styStart Hello world : 首先，在本节，读者将了解Tensorflow的安装方法，并编写通过第一个简单的Tensorflow程序。 线性分类 : 本节通过解一个简单的二分类问题，我们将引入单层感知机、Logistic回归和交叉熵的概念，并且实验结果进行可视化。 线性回归 : 本节通过解一个与上一节难度相仿的，简单的回归问题，另读者能对比不同优化器的性能、特点，并介绍如何在项目中进行arugument parsing(引入项目的可选项)。 非线性回归 : 本节将修改上一节回归问题的激活函数，将线性的回归问题推广到解析函数参数回归的范畴。同时介绍自行编写网络层(类API)的方法。 非线性分类 : 本节将通过上一节的参数回归，引入核函数的概念，将线性分类问题推广到非线性空间里。","text_tokens":["(","对比","：","sigma","一节","与","class","st","引入","，","stroke","范畴","线性","首先","tensorflow","可选项","和","world","nonlinreg","了","特点","ba9132","到","激活","将","在","知机","本","方法","定义","感知机","stystart","parsing","同时","单层","arugument","api","上","ed","交叉","不同","难度","程序","logsitc","相仿","推广","展示","回归","简单","介绍","结果","!","argpar","linclas","解","lr",":","感知","自定","我们","二","[","网络层","如何","层","第一","自行","参数","第一个","并","解析","通过","函数参数","了解","并且","本章","另","下图","函数","的",",","fill","本节","能","分类","节","器","熵","概念","里","网络","安装","graph",">","项目",";"," ","hello","linreg","opt","可视化","读者","核","优化","]","自定义","sdlayer","fae6a9","学习","logistic","实验","非线性","性能","classdef","#","进行","类","选项",")","para","-","可视","。","问题","ce","修改","kernel","编写","、","空间","一个","lp","中","可选"],"title":"本章要点","title_tokens":["要点","本章"]},{"location":"book-1-x/chapter-1/hello-world/","text":"Hello world! ¶ 摘要 本节包含一个简易的安装指导，主要提供给Windows上的GPU用户。之后，用户可以按照本节指导编写第一个测试程序。 安装Tensorflow ¶ 本节针对Windows使用GPU的用户，提供一个安装最新版Tensorflow的方法。大致的步骤符合以下两个教程： 通过pip安装Tensorflow Tensorflow的GPU支持 但是，需要指出的是，官方教程里有些部分已经不符合当前用户的实际情况，笔者经过摸索，总结以下的安装过程。 总体而言，安装Tensorflow需要用户确保以下条件 NVIDIA驱动已经达到411.31及以上 CUDA 10.0 (10.1不确定能否正常使用) CUDNN已经达到7.3.1及以上 CUPTI版本与CUDA相配（不需要专门安装，在安装CUDA的同时已经自动集成） 除此之外，涉及多GPU支持的库(NCCL和TensorRT)，这里不考虑。因此，我们主要需要确保前三条正常安装。 提示 Tensorflow官方提供的安装包是基于CUDA 9.0，CUDNN >= 7.2的基础上编译的。然而现在NVIDIA已经不再提供CUDA 9.0了。Windows用户可以安装的版本包括过时的8.1和最新的10.1。在这种情况下，官方还提供一个令用户自行从源码编译Tensorflow库的方案，但是对于Windows用户而言过于繁琐，容易出错，这里不建议按照官方教程。 更新NVIDIA驱动 ¶ 首先，我们可以开始更新我们的NVIDIA驱动。任何载有NVIDIA-GPU显卡的电脑，都应当在系统里已经预装好了 GeForce Experience 。点击如下图标开启GeForce Experience（如果是低版本的GeForce Experience，图标可能会不同）， 如左图，在主界面上，可以观察到，当驱动版本不够高时，会自动出现更新提示，依照提示更新即可。建议在更新驱动时，关闭其他所有程序，以免造成干扰。 更新NVIDIA driver 检查更新结果 如果更新完成，如右图，可以在设置界面检查到当前的版本已经达到最新。在安装过程中，由于驱动更新，屏幕可能会闪烁数次。在看到更新提示完成后建议重启。 提示 如果GeForce Experience提示无法更新驱动，可以考虑将机器恢复出厂设置，可能可以解决这一问题。 安装CUDA ¶ 驱动更新并重启后，需要安装最新版的Visual Studio(VS)，这是因为CUDA库本身对VS具有一定的支持，如果先安装CUDA，则这部分支持无法安装到位。这对我们使用Tensorflow并不造成妨害，但是对CUDA的用户并不是一个推荐的做法，所以无论如何，建议在第一步，安装VS，下面提供VS社区版（免费）的链接： Visual Studio官网 接下来，可以开始安装CUDA。进入CUDA安装包的下载链接 下载最新版CUDA CUDA官方指南 提示 须知，并非最新版就是最适合的版本。实际能使用的CUDA版本取决于后续步骤中预编译包的支持版本。就笔者写到这里时，最新的CUDA 10.1已然不匹配最新版预编译包支持的CUDA 10.0，由于版本差距很小，不确定是否会由此引发问题，但读者可以自行尝试。 现在的安装包已经支持在线安装包和离线安装包两种模式，读者可以根据自己的实际情况选择对应的版本。注意，安装CUDA的时候，CUDA可能要求我们翻新驱动版本，但通过GeForce Experience安装的驱动一般应已达到最新，新于CUDA内部提供的驱动。因此，我们需要选择定制安装模式，根据我们需要对比版本号，将驱动更新的选项取消，如下图所示 安装CUDA后，建议重启。 危险 特别需要注意的是，如果你的机器无法通过GeForce Experience更新驱动，那么在这里选择安装驱动也是枉然。并且，这种强制更新驱动的行为很可能导致系统崩溃。因此特别建议在安装CUDA之前一定要解决驱动更新的问题，哪怕是通过恢复出厂设置。 安装CUDNN ¶ 安装CUDA的同时，已经自带安装上了CUPTI。但是CUDNN并没有包含在CUDA中，因此，我们需要到以下链接下载CUDNN并查看安装说明 下载最新版CUDNN CUDNN官方指南 不同的是，CUDNN没有安装包，是以压缩包的形式下载到本地。解压后，其中应当包含如下目录及文件 . └─ cuda/ ├─ bin/ # Binary library │ └─ cudnn64_7.dll ├─ include/ # C++ Include file │ └─ cudnn.h ├─ lib/ # C++ Lib file │ └─ x64/ │ └─ cudnn.lib └─ NVIDIA_SLA_cuDNN_Support.txt # Readme file 假设我们CUDA的安装目录在 C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v10.0 ，将上述解压的 bin , include 和 lib 三个文件夹，直接拷贝覆盖到该安装目录下，即可完成CUDNN的安装。 进行完上述步骤后，我们还需要确保几个环境变量正确设置： 存在 CUDA_PATH=C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v10.0 ，是我们的安装目录。理论上在CUDA安装后，该目录已经自动设置好。 环境变量 PATH 中，存在 C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v10.0/bin , C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v10.0/extras/CUPTI/libx64 两个路径，由于CUDNN已经配置在CUDA安装目录下，我们不需要像官方文档那样，添加第三个CUDNN的安装路径。 安装Anaconda ¶ Windows用户建议使用Anaconda管理python环境。作为一个开源的项目，Anaconda发行版已经集成了我们所需要的大多数python包，其中有些包是我们自己难以安装上的，例如支持python3的PIL。我们选用python3版的Anaconda，下载路径如下： Anaconda 最新版下载链接 注意选择x64版的安装包。安装结束后，我们已经有python3.7的环境了。鉴于有些情况下我们可能需要使用更早的python版本，接下来我们可以安装python3.6的虚环境。 Anaconda可以安装在用户或系统目录下。注意，如果安装在系统目录下，如果不在虚环境下，安装任何包都需要管理员模式。不过这不影响本教程的示例，因为我们将安装虚环境。直接打开 Anaconda Prompt ，并键入以下命令： conda create -n py36 python = 3 .6 anaconda 按照引导流程安装，经过一段时间后，我们将得到python3.6版的Anaconda。以后我们可以直接从开始菜单 Anaconda Prompt (py36) 进入该虚环境，也可以在基环境中键入 activate py36 转换到虚环境中。 提示 如果用户愿意，还可以通过 conda install -c conda-forge opencv 安装 opencv 。opencv是一个强大的图像处理库，这里python版的opencv比C++版更容易上手。一般该命令安装的是conda库中最新版的opencv（截至笔者写到这里时是opencv3.4.4）。然而，这样安装的并非是支持GPU的版本。尽管conda还提供一个GPU的opencv版本，可以通过 conda install -c patricksnape opencv-gpu 安装 opencv2 ，但它的版本还停留在2.4.9，和opencv3的用法殊有不同，请读者注意这一点。 安装预编译好的Tensorflow ¶ 可以通过 pip install tensorflow-gpu == 查看Tensorflow是否有官方发行的新版。当然，使用GPU的用户要特别注意最新版是否和你预装的驱动匹配，尤其是CUDA是否匹配，否则Tensorflow可能无法正常工作。 在官方发行版不适合我们使用的时候，我们也可以查看如下第三方发行的项目： fo40225/tensorflow-windows-wheel 该项目的维护者在不断根据Tensorflow的更新，预编译出适合不同版本的Tensorflow安装包。截至笔者写到这里为止，最新支持到r1.12版。 原则上来讲，我们选择尽可能新的版本。有时候官方发行版对CUDA的支持滞后，因此我们可以选择第三方版。无论选择哪种发行方，要安装Tensorflow，我们需要选择对应的GPU版，并在虚环境下执行以下命令： 官方版 pip install --upgrade tensorflow-gpu 第三方版 pip install https://github.com/fo40225/tensorflow-windows-wheel/blob/master/1.12.0/py36/GPU/cuda100cudnn73sse2/tensorflow_gpu-1.12.0-cp36-cp36m-win_amd64.whl 第三方版(CPU AVX2加强) curl -o tensorflow_gpu-1.12.0-cp36-cp36m-win_amd64.7z.001 https://raw.githubusercontent.com/fo40225/tensorflow-windows-wheel/master/1.12.0/py36/GPU/cuda100cudnn73avx2/tensorflow_gpu-1.12.0-cp36-cp36m-win_amd64.7z.001 curl -o tensorflow_gpu-1.12.0-cp36-cp36m-win_amd64.7z.002 https://raw.githubusercontent.com/fo40225/tensorflow-windows-wheel/master/1.12.0/py36/GPU/cuda100cudnn73avx2/tensorflow_gpu-1.12.0-cp36-cp36m-win_amd64.7z.002 \"C:/Program Files/7-Zip/7z.exe\" x tensorflow_gpu-1.12.0-cp36-cp36m-win_amd64.7z.001 # Note that you need to specify where your 7-zip gets installed. pip install tensorflow_gpu-1.12.0-cp36-cp36m-win_amd64.whl 等待一段时间后，安装将会结束。 Hello world! 测试 ¶ 撰写如下代码，保存到 hello-world.py 文件， Python 1 2 3 4 5 6 7 8 9 if __name__ == '__main__' : import tensorflow as tf test_str = tf . constant ( 'Hello, world!' ) test_cal = tf . reduce_sum ( tf . random_normal ([ 1000 , 1000 ])) with tf . Session () as sess : print ( 'Current Tensorflow version is:' , tf . __version__ ) print ( 'Test string: ' , sess . run ( test_str )) print ( 'Test calculation:' , sess . run ( test_cal )) Output Current Tensorflow version is: 1 .13.1 Test string: b 'Hello, world!' Test calculation: 955 .5544 在保存目录下，执行 python hello-world.py 第一次运行可能需要等待较长的初始化时间（硬件配置）。如果能正常运行，我们将看到如下结果： 其中，显示结果之前的记录信息反映了GPU已经可以正常工作。而“Test calculation”显示的结果是 10^6 10^6 个服从 \\mathcal{N}(0,1) \\mathcal{N}(0,1) 分布的随机数之和。根据相互独立的随机正态分布互不相关的特性，我们可以推算出，该结果服从 \\mathcal{N}(0,10^3) \\mathcal{N}(0,10^3) 的正态分布。","text_tokens":["以免","其中","记录","基于","环境","cp36m","对比","─","手","库中","内部","geforce","files","将会","源码","测试","形式","win","低版本","不过","存在","涉及","初始化","后续","x64","包含","工作","exe","件夹","多数","和","部分","其他","7.2","过时","current","了","观察","1","枉然","殊有","'","压缩","专门","中预","原则上","10.0","dll","翻新","下来","本","使用","v10","同时","管理员","不够","电脑","情况","达到","c","lib","version","该项","¶","开源","尽可","编译","取消","时","以上","选用","这样","最新版","引发","停留","会","^","that","已然","avx2","结果","is","干扰","互不","9.0","nccl","第一","自行","来讲","时候","test","机数","output","命令","低版","三条","转换","_","接下来","tf","master","main","文件","5","相关","具有","简易","gets","python3","界面","\\","须知","官方","较长","而言","所","系统","如","应已","studio","拷贝","并非","10","}","下载","gpu","可以","以后","说明","得到","本身","推算","无论","4","当","系统目录","txt","否则","是","str","匹配","b","早","好","屏幕","相互","显示","开始菜单","(","vs","用户","因为","主","应当","分布","不是","愿意","从","bin","正态分布",".","哪","这","，","时间","path","大多数","首先","这部分","tensorflow","推算出","amd64","cuda","computing","两种","版本号","开启","完成","将","1.12","覆盖","教程","指南","r1","出现","撰写","对应","滞后","文档","没有","wheel","anaconda","新","specify","程序","路径","要求","尝试","patricksnape","图像处理","发行版","experience","基","cuda100cudnn73avx2","sla","这种","点击","所有","定制","特别","方案","要","配置","包是",":","取决于","接下","更新","import","设置","github","[","有些","5544","第三个","对于","三方","尽可能","显卡","右图","随机","第一个","图像","并","难以","经过","提供","载有","繁琐","写","print","先","图","一般","闪烁","blob","由于","13.1","除此","“","里","visual","注意","curl","给","及",">","无论如何","这部","项目","像","extras","过于","因此","├","都","考虑","差距","令","tensorrt","管理","7z","cupti","后","12","服从","总体","有时","cal","opencv","前","c++","sum","pil","下面","指导","那样","做法","support","pip","总体而言","方","行为","强大","编写","版本","as","955","一个","取决","发行","库","种","现在","过程","对","自己","：","崩溃","与","包都","笔者","之前","第一次","出","等待","whl","链接","有时候","0","随机数","但是","支持","由此","官网","截至","新于","cuda100cudnn73sse2","一段","例如","危险","引导","一段时间","提示","无法","很","测试程序","program","to","在","结束","官方版","一次","大多","除此之外","造成","特性","检查","符合","这一","所以","环境变量","if","上","新版","\"","activate","session","正常","基础","左图","版","create","constant","执行","摘要","重启","10.1","!","你","保存","nvidia","恢复","opencv2","文件夹","哪怕","py36","理论","/","opencv3","虚","note","string","选择","your","而","并且","进入","已经","forge","安装包","按照","大致","）","反映","的",",","prompt","com","目的","容易","变量","键入","然而","初始","x","高时","还","维护","│","免费","安装","也","一定","h","该","windows","”","强制","所示","图标","第三方","当前","之后","进行","如果","确定","出错","2","处理","摸索","是因为","根据","目录","以下","9","代码","开始","最","打开","自动","更","确保","include","以","zip","calculation","但","py","流程","假设","random","或","到位","尽管","包","上述","一点","硬件","建议","cudnn64","环境变","2.4","normal","比","githubusercontent","本地","最新","步骤","{","那么","world","解决","6","总结","压缩包","自带","到","不","正确","独立","就是","模式","不断","鉴于","方法","是否","机器","预","installed","这里","任何","关闭","菜单","cp36","主要","影响","4.4","411.31","请","1000","不同","└","即可","where","readme","library","在线","查看","cudnn","001","用法","出厂","信息","预装","driver","install","you","维护者","可能","添加","之外","原则","包括","完","能否","我们","作为","如下","如何","__","个","为止","3","fo40225","n","社区","解压","通过","toolkit","条件","依照","指出","（","针对","妨害","7.3","驱动","with","能","节","conda","导致","算出","直接","binary","看到","数次","很小"," ","hello","有","离线","段时间","读者","适合","file","就","]","示例","cpu","多","运行","推荐","它","002","upgrade","reduce","相配","集成","#","实际","需要","一步","选项","导致系统","raw","mathcal",")","尤其","两个","7","8.1","之","run","-","o","当然","8","sess","=","。","几个","第三","问题","name","则","下","三个","加强","https","不再","python","need","中","libx64","第一步"],"title":"Hello world!","title_tokens":["!"," ","hello","world"]},{"location":"book-1-x/chapter-1/hello-world/#hello-world","text":"摘要 本节包含一个简易的安装指导，主要提供给Windows上的GPU用户。之后，用户可以按照本节指导编写第一个测试程序。","text_tokens":["第一个","主要","用户","提供","上","按照","之后","gpu","的","可以","测试","程序","，","包含","节","指导","。","摘要","简易","编写","安装","一个","给","测试程序"," ","windows","本","第一"],"title":"Hello world!","title_tokens":["!"," ","hello","world"]},{"location":"book-1-x/chapter-1/hello-world/#tensorflow","text":"本节针对Windows使用GPU的用户，提供一个安装最新版Tensorflow的方法。大致的步骤符合以下两个教程： 通过pip安装Tensorflow Tensorflow的GPU支持 但是，需要指出的是，官方教程里有些部分已经不符合当前用户的实际情况，笔者经过摸索，总结以下的安装过程。 总体而言，安装Tensorflow需要用户确保以下条件 NVIDIA驱动已经达到411.31及以上 CUDA 10.0 (10.1不确定能否正常使用) CUDNN已经达到7.3.1及以上 CUPTI版本与CUDA相配（不需要专门安装，在安装CUDA的同时已经自动集成） 除此之外，涉及多GPU支持的库(NCCL和TensorRT)，这里不考虑。因此，我们主要需要确保前三条正常安装。 提示 Tensorflow官方提供的安装包是基于CUDA 9.0，CUDNN >= 7.2的基础上编译的。然而现在NVIDIA已经不再提供CUDA 9.0了。Windows用户可以安装的版本包括过时的8.1和最新的10.1。在这种情况下，官方还提供一个令用户自行从源码编译Tensorflow库的方案，但是对于Windows用户而言过于繁琐，容易出错，这里不建议按照官方教程。","text_tokens":["现在","建议","过程","(","基于","用户","从","：","与",".","最新","笔者","源码","步骤","涉及","，","tensorflow","但是","支持","和","部分","7.2","过时","了","总结","1","cuda","提示","专门","不","10.0","教程","在","本","方法","使用","除此之外","同时","情况","达到","这里","符合","主要","上","新版","411.31","编译","正常","基础","以上","最新版","cudnn","10.1","这种","之外","方案","nvidia","包括","能否","9.0","我们","nccl","有些","对于","自行","通过","经过","提供","繁琐","已经","条件","安装包","指出","按照","大致","）","三条","的","（","针对","7.3","容易","驱动","然而","节","除此","还","里","安装","及",">"," ","官方","windows","因此","过于","而言","考虑","令","tensorrt","多","当前","cupti","相配","集成","gpu","实际","需要","可以","确定","总体","出错",")","摸索","两个","前","8.1","以下","=","。","自动","pip","确保","下","总体而言","版本","一个","不再","是","库"],"title":"安装Tensorflow","title_tokens":["tensorflow","安装"]},{"location":"book-1-x/chapter-1/hello-world/#nvidia","text":"首先，我们可以开始更新我们的NVIDIA驱动。任何载有NVIDIA-GPU显卡的电脑，都应当在系统里已经预装好了 GeForce Experience 。点击如下图标开启GeForce Experience（如果是低版本的GeForce Experience，图标可能会不同）， 如左图，在主界面上，可以观察到，当驱动版本不够高时，会自动出现更新提示，依照提示更新即可。建议在更新驱动时，关闭其他所有程序，以免造成干扰。 更新NVIDIA driver 检查更新结果 如果更新完成，如右图，可以在设置界面检查到当前的版本已经达到最新。在安装过程中，由于驱动更新，屏幕可能会闪烁数次。在看到更新提示完成后建议重启。 提示 如果GeForce Experience提示无法更新驱动，可以考虑将机器恢复出厂设置，可能可以解决这一问题。","text_tokens":["建议","以免","过程","主","应当","geforce","最新","低版本","，","首先","其他","解决","了","观察","到","提示","无法","开启","完成","将","在","机器","造成","不够","电脑","出现","检查","达到","任何","关闭","这一","上","时","不同","即可","左图","程序","会","experience","出厂","预装","driver","结果","重启","干扰","点击","可能","所有","nvidia","恢复","更新","我们","设置","如下","右图","显卡","载有","已经","依照","低版","）","的","（","闪烁","驱动","由于","高时","里","安装","界面","看到","数次"," ","都","图标","如","系统","考虑","当前","后","gpu","可以","如果","-","开始","当","。","问题","自动","版本","是","好","屏幕","中"],"title":"更新NVIDIA驱动","title_tokens":["nvidia","驱动","更新"]},{"location":"book-1-x/chapter-1/hello-world/#cuda","text":"驱动更新并重启后，需要安装最新版的Visual Studio(VS)，这是因为CUDA库本身对VS具有一定的支持，如果先安装CUDA，则这部分支持无法安装到位。这对我们使用Tensorflow并不造成妨害，但是对CUDA的用户并不是一个推荐的做法，所以无论如何，建议在第一步，安装VS，下面提供VS社区版（免费）的链接： Visual Studio官网 接下来，可以开始安装CUDA。进入CUDA安装包的下载链接 下载最新版CUDA CUDA官方指南 提示 须知，并非最新版就是最适合的版本。实际能使用的CUDA版本取决于后续步骤中预编译包的支持版本。就笔者写到这里时，最新的CUDA 10.1已然不匹配最新版预编译包支持的CUDA 10.0，由于版本差距很小，不确定是否会由此引发问题，但读者可以自行尝试。 现在的安装包已经支持在线安装包和离线安装包两种模式，读者可以根据自己的实际情况选择对应的版本。注意，安装CUDA的时候，CUDA可能要求我们翻新驱动版本，但通过GeForce Experience安装的驱动一般应已达到最新，新于CUDA内部提供的驱动。因此，我们需要选择定制安装模式，根据我们需要对比版本号，将驱动更新的选项取消，如下图所示 安装CUDA后，建议重启。 危险 特别需要注意的是，如果你的机器无法通过GeForce Experience更新驱动，那么在这里选择安装驱动也是枉然。并且，这种强制更新驱动的行为很可能导致系统崩溃。因此特别建议在安装CUDA之前一定要解决驱动更新的问题，哪怕是通过恢复出厂设置。","text_tokens":["现在","建议","(","vs","用户","因为","对比","不是","对","自己","：","崩溃","内部","最新","geforce","笔者","之前","这","步骤","，","后续","链接","那么","这部分","tensorflow","但是","支持","和","部分","解决","由此","官网","新于","危险","cuda","枉然","到","无法","提示","很","中预","两种","不","版本号","10.0","就是","将","模式","在","翻新","下来","指南","是否","使用","预","机器","造成","情况","达到","这里","所以","对应","新版","编译","取消","时","版","最新版","要求","尝试","在线","引发","会","experience","已然","出厂","重启","10.1","你","可能","这种","特别","定制","要","恢复","取决于","接下","更新","我们","哪怕","设置","如下","如何","第一","自行","并","社区","时候","选择","通过","提供","并且","写","进入","已经","先","安装包","）","接下来","的","一般","图","（","妨害","驱动","由于","能","具有","导致","visual","注意","免费","安装","也","很小","一定","这部","无论如何"," ","须知","官方","离线","因此","强制","读者","所示","适合","就","差距","系统","应已","studio","并非","推荐","后","下载","实际","需要","一步","如果","可以","确定","选项",")","导致系统","本身","是因为","根据","无论","开始","下面","最","。","做法","问题","则","但","行为","版本","一个","取决","是","匹配","到位","库","包","第一步"],"title":"安装CUDA","title_tokens":["安装","cuda"]},{"location":"book-1-x/chapter-1/hello-world/#cudnn","text":"安装CUDA的同时，已经自带安装上了CUPTI。但是CUDNN并没有包含在CUDA中，因此，我们需要到以下链接下载CUDNN并查看安装说明 下载最新版CUDNN CUDNN官方指南 不同的是，CUDNN没有安装包，是以压缩包的形式下载到本地。解压后，其中应当包含如下目录及文件 . └─ cuda/ ├─ bin/ # Binary library │ └─ cudnn64_7.dll ├─ include/ # C++ Include file │ └─ cudnn.h ├─ lib/ # C++ Lib file │ └─ x64/ │ └─ cudnn.lib └─ NVIDIA_SLA_cuDNN_Support.txt # Readme file 假设我们CUDA的安装目录在 C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v10.0 ，将上述解压的 bin , include 和 lib 三个文件夹，直接拷贝覆盖到该安装目录下，即可完成CUDNN的安装。 进行完上述步骤后，我们还需要确保几个环境变量正确设置： 存在 CUDA_PATH=C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v10.0 ，是我们的安装目录。理论上在CUDA安装后，该目录已经自动设置好。 环境变量 PATH 中，存在 C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v10.0/bin , C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v10.0/extras/CUPTI/libx64 两个路径，由于CUDNN已经配置在CUDA安装目录下，我们不需要像官方文档那样，添加第三个CUDNN的安装路径。","text_tokens":["其中","cudnn64","环境","环境变","应当","─","bin","：","本地",".","最新","files","形式","步骤","存在","，","x64","链接","包含","0","path","件夹","但是","和","了","压缩包","自带","cuda","到","computing","压缩","完成","将","正确","program","不","dll","覆盖","在","指南","v10","同时","c","lib","环境变量","文档","上","新版","没有","不同","└","即可","路径","readme","最新版","library","查看","cudnn","sla","添加","nvidia","配置",":","文件夹","完","我们","设置","如下","第三个","理论","/","并","解压","toolkit","已经","安装包","_","的",",","文件","变量","由于","还","│","直接","binary","安装","及"," ","官方","像","h","extras","该","因此","├","file","拷贝","cupti","后","#","下载","gpu","进行","需要","说明","7","目录","两个","c++","以下","=","。","几个","那样","support","第三","自动","include","确保","以","下","三个","txt","假设","是","好","上述","中","libx64"],"title":"安装CUDNN","title_tokens":["安装","cudnn"]},{"location":"book-1-x/chapter-1/hello-world/#anaconda","text":"Windows用户建议使用Anaconda管理python环境。作为一个开源的项目，Anaconda发行版已经集成了我们所需要的大多数python包，其中有些包是我们自己难以安装上的，例如支持python3的PIL。我们选用python3版的Anaconda，下载路径如下： Anaconda 最新版下载链接 注意选择x64版的安装包。安装结束后，我们已经有python3.7的环境了。鉴于有些情况下我们可能需要使用更早的python版本，接下来我们可以安装python3.6的虚环境。 Anaconda可以安装在用户或系统目录下。注意，如果安装在系统目录下，如果不在虚环境下，安装任何包都需要管理员模式。不过这不影响本教程的示例，因为我们将安装虚环境。直接打开 Anaconda Prompt ，并键入以下命令： conda create -n py36 python = 3 .6 anaconda 按照引导流程安装，经过一段时间后，我们将得到python3.6版的Anaconda。以后我们可以直接从开始菜单 Anaconda Prompt (py36) 进入该虚环境，也可以在基环境中键入 activate py36 转换到虚环境中。 提示 如果用户愿意，还可以通过 conda install -c conda-forge opencv 安装 opencv 。opencv是一个强大的图像处理库，这里python版的opencv比C++版更容易上手。一般该命令安装的是conda库中最新版的opencv（截至笔者写到这里时是opencv3.4.4）。然而，这样安装的并非是支持GPU的版本。尽管conda还提供一个GPU的opencv版本，可以通过 conda install -c patricksnape opencv-gpu 安装 opencv2 ，但它的版本还停留在2.4.9，和opencv3的用法殊有不同，请读者注意这一点。","text_tokens":["建议","其中","(","环境","用户","因为","2.4","比","手","愿意","自己","：","从","库中","包都",".","最新","笔者","这","不过","，","x64","时间","链接","多数","大多数","支持","和","截至","6","了","一段","例如","引导","一段时间","殊有","到","提示","不","将","模式","结束","鉴于","下来","在","本","教程","使用","大多","管理员","c","情况","这里","任何","菜单","影响","4.4","上","新版","activate","开源","请","anaconda","时","不同","选用","版","路径","这样","最新版","patricksnape","图像处理","发行版","停留","用法","create","install","基","可能","包是","opencv2","接下","我们","作为","有些","如下","py36","opencv3","虚","3","n","图像","并","难以","选择","经过","通过","提供","命令","写","已经","进入","forge","安装包","按照","）","转换","接下来","的","prompt","一般","（","键入","容易","然而","conda","还","注意","python3","直接","安装","也","项目"," ","有","段时间","该","windows","读者","所","系统","示例","并非","它","管理","集成","后","下载","gpu","需要","可以","如果","以后",")","得到","处理","7","目录","opencv","c++","以下","9","pil","-","开始","=","。","打开","更","下","但","系统目录","强大","版本","一个","流程","python","是","发行","或","早","尽管","包","库","一点","中","开始菜单"],"title":"安装Anaconda","title_tokens":["anaconda","安装"]},{"location":"book-1-x/chapter-1/hello-world/#tensorflow_1","text":"可以通过 pip install tensorflow-gpu == 查看Tensorflow是否有官方发行的新版。当然，使用GPU的用户要特别注意最新版是否和你预装的驱动匹配，尤其是CUDA是否匹配，否则Tensorflow可能无法正常工作。 在官方发行版不适合我们使用的时候，我们也可以查看如下第三方发行的项目： fo40225/tensorflow-windows-wheel 该项目的维护者在不断根据Tensorflow的更新，预编译出适合不同版本的Tensorflow安装包。截至笔者写到这里为止，最新支持到r1.12版。 原则上来讲，我们选择尽可能新的版本。有时候官方发行版对CUDA的支持滞后，因此我们可以选择第三方版。无论选择哪种发行方，要安装Tensorflow，我们需要选择对应的GPU版，并在虚环境下执行以下命令： 官方版 pip install --upgrade tensorflow-gpu 第三方版 pip install https://github.com/fo40225/tensorflow-windows-wheel/blob/master/1.12.0/py36/GPU/cuda100cudnn73sse2/tensorflow_gpu-1.12.0-cp36-cp36m-win_amd64.whl 第三方版(CPU AVX2加强) curl -o tensorflow_gpu-1.12.0-cp36-cp36m-win_amd64.7z.001 https://raw.githubusercontent.com/fo40225/tensorflow-windows-wheel/master/1.12.0/py36/GPU/cuda100cudnn73avx2/tensorflow_gpu-1.12.0-cp36-cp36m-win_amd64.7z.001 curl -o tensorflow_gpu-1.12.0-cp36-cp36m-win_amd64.7z.002 https://raw.githubusercontent.com/fo40225/tensorflow-windows-wheel/master/1.12.0/py36/GPU/cuda100cudnn73avx2/tensorflow_gpu-1.12.0-cp36-cp36m-win_amd64.7z.002 \"C:/Program Files/7-Zip/7z.exe\" x tensorflow_gpu-1.12.0-cp36-cp36m-win_amd64.7z.001 # Note that you need to specify where your 7-zip gets installed. pip install tensorflow_gpu-1.12.0-cp36-cp36m-win_amd64.whl 等待一段时间后，安装将会结束。","text_tokens":["种","(","环境","cp36m","用户","对","：","githubusercontent",".","最新","files","笔者","win","将会","哪","出","，","等待","时间","whl","工作","有时候","0","exe","tensorflow","和","支持","amd64","截至","cuda100cudnn73sse2","一段","一段时间","cuda","到","无法","1.12","不","原则上","program","to","在","不断","结束","官方版","是否","使用","预","installed","r1","c","这里","cp36","对应","该项","滞后","新版","\"","wheel","尽可","编译","正常","不同","新","specify","版","where","最新版","查看","发行版","001","that","执行","avx2","预装","install","cuda100cudnn73avx2","you","维护者","你","可能","特别","原则","要",":","更新","我们","github","如下","py36","/","为止","三方","尽可能","虚","来讲","note","fo40225","时候","并","选择","通过","your","命令","写","安装包","_","的","com","目的","master","blob","驱动","x","gets","维护","curl","注意","安装","也","项目"," ","有","官方","段时间","windows","因此","适合","cpu","第三方","002","upgrade","7z","后","#","gpu","可以","12","需要","raw","有时",")","尤其","根据","7","以下","无论","-","o","当然","=","。","第三","zip","pip","下","方","加强","版本","https","否则","是","发行","匹配","need"],"title":"安装预编译好的Tensorflow","title_tokens":["的","tensorflow","好","安装","预","编译"]},{"location":"book-1-x/chapter-1/hello-world/#hello-world_1","text":"撰写如下代码，保存到 hello-world.py 文件， Python 1 2 3 4 5 6 7 8 9 if __name__ == '__main__' : import tensorflow as tf test_str = tf . constant ( 'Hello, world!' ) test_cal = tf . reduce_sum ( tf . random_normal ([ 1000 , 1000 ])) with tf . Session () as sess : print ( 'Current Tensorflow version is:' , tf . __version__ ) print ( 'Test string: ' , sess . run ( test_str )) print ( 'Test calculation:' , sess . run ( test_cal )) Output Current Tensorflow version is: 1 .13.1 Test string: b 'Hello, world!' Test calculation: 955 .5544 在保存目录下，执行 python hello-world.py 第一次运行可能需要等待较长的初始化时间（硬件配置）。如果能正常运行，我们将看到如下结果： 其中，显示结果之前的记录信息反映了GPU已经可以正常工作。而“Test calculation”显示的结果是 10^6 10^6 个服从 \\mathcal{N}(0,1) \\mathcal{N}(0,1) 分布的随机数之和。根据相互独立的随机正态分布互不相关的特性，我们可以推算出，该结果服从 \\mathcal{N}(0,10^3) \\mathcal{N}(0,10^3) 的正态分布。","text_tokens":["其中","(","记录","分布","normal","正态分布","：",".","第一次","之前","初始化","，","等待","时间","工作","0","{","随机数","tensorflow","推算出","和","world","current","6","了","1","到","'","将","独立","在","一次","特性","撰写","version","if","1000","session","正常","^","constant","执行","信息","结果","is","!","可能","保存","配置",":","互不","import","我们","5544","[","如下","__","个","第一","3","随机","n","string","test","机数","而","print","output","已经","）","tf","反映","_","的",",","（","main","文件","初始","with","13.1","能","5","“","相关","算出","看到","\\"," ","hello","该","较长","”","]","10","运行","reduce","}","gpu","需要","可以","2","如果","服从","mathcal",")","cal","7","目录","根据","推算","sum","4","代码","9","run","-","之","8","sess","=","。","name","calculation","下","955","as","py","random","python","是","str","b","相互","硬件","显示"],"title":"Hello world! 测试","title_tokens":[" ","hello","测试","world","!"]},{"location":"book-1-x/chapter-1/linear-classification/","text":"线性分类 ¶ 摘要 本节介绍如何使用顺序模型(sequential model)来编写一个线性分类器，使用sigmoid函数激活，并验证其效果。在本节我们将编写第一个Project，并介绍一些基本概念、和一个推荐的Tensorflow Project的编写格式。 理论 ¶ 问题描述 ¶ 考虑我们有如下的二分类数据集 (\\mathbf{x},~y_i) \\in \\mathbb{D}_i (\\mathbf{x},~y_i) \\in \\mathbb{D}_i ，并且有一个未知的常数向量 \\mathbf{a}_i \\mathbf{a}_i 和未知的常数标量 c_i c_i ，使得： \\begin{equation} y_i = \\left\\{ \\begin{aligned} 0, && \\mathbf{a}_i^T \\mathbf{x} + c_i \\leqslant 0, \\\\ 1, && \\mathbf{a}_i^T \\mathbf{x} + c_i > 0. \\end{aligned} \\right. \\end{equation} 其中， \\mathbf{a} \\mathbf{a} 可以看成是某超平面的（未标准化的）法向量，那么 \\mathbf{a}^T \\mathbf{x} + c = 0 \\mathbf{a}^T \\mathbf{x} + c = 0 是该超平面的截距式定义，亦即该平面与 x_i x_i 轴的交点可以显式表述为 x_i^{(0)} = - \\frac{c}{a_i} x_i^{(0)} = - \\frac{c}{a_i} 。由此可知，式 (1) (1) 显式定义了一个点在超平面的哪一侧。特别地，若 \\mathbf{x} \\mathbf{x} 是一个二维向量，则该超平面退化为一维平面；若 \\mathbf{x} \\mathbf{x} 是一个标量，则该超平面退化为一条直线。 若我们定义 (\\mathbf{x},~\\mathbf{y}) \\in \\mathbb{D} (\\mathbf{x},~\\mathbf{y}) \\in \\mathbb{D} ，有 \\begin{equation} \\mathbf{y} = \\begin{bmatrix} y_1 \\\\ y_2 \\\\ \\vdots \\\\ y_n \\end{bmatrix}, ~~ \\mathbf{A} = \\begin{bmatrix} \\mathbf{a}^T_1 \\\\ \\mathbf{a}^T_2 \\\\ \\vdots \\\\ \\mathbf{a}^T_n \\end{bmatrix}, ~~ \\mathbf{c} = \\begin{bmatrix} c_1 \\\\ c_2 \\\\ \\vdots \\\\ c_n \\end{bmatrix}. \\end{equation} 则我们可以认为 \\begin{align} \\mathbf{y} = \\left\\{ \\begin{bmatrix}\\hat{y}_1 > 0 & \\hat{y}_2 > 0 & \\cdots & \\hat{y}_n > 0\\end{bmatrix}^T, ~ \\left| ~ \\hat{\\mathbf{y}} = \\mathbf{A} \\mathbf{x} + \\mathbf{c} + \\boldsymbol{\\varepsilon} \\right. \\right\\}, \\end{align} 其中 \\boldsymbol{\\varepsilon} \\boldsymbol{\\varepsilon} 是一个定义噪声的向量。 我们可以把向量 \\mathbf{y} \\mathbf{y} 的元素看成是互不相关的多个超平面对向量 \\mathbf{x} \\mathbf{x} 各自独立的分类结果。即 y_i = \\{ \\hat{y}_i>0 ~ | ~ \\hat{y}_i = \\mathbf{a}_i^T \\mathbf{x} + c_i + \\varepsilon_i \\} y_i = \\{ \\hat{y}_i>0 ~ | ~ \\hat{y}_i = \\mathbf{a}_i^T \\mathbf{x} + c_i + \\varepsilon_i \\} 。由于每个超平面构成一个二分类，如果把每个二分类看作是向量是否属于这个类的测度，那么 \\mathbf{y} \\mathbf{y} 可以被看作是一个多分类的结果，尽管向量 \\mathbf{x} \\mathbf{x} 可能被同时分入多个类中。 假设我们的数据集 (\\mathbf{x},~\\mathbf{y}) \\in \\mathbb{D} (\\mathbf{x},~\\mathbf{y}) \\in \\mathbb{D} 符合 (3) (3) 定义的数据分布特征。我们的基本要求是，在我们不知道 \\mathbf{A},~\\mathbf{c} \\mathbf{A},~\\mathbf{c} 的情况下，使用大量 (\\mathbf{x}^{(k)},~\\mathbf{y}^{(k)}) \\in \\mathbb{D} (\\mathbf{x}^{(k)},~\\mathbf{y}^{(k)}) \\in \\mathbb{D} 样本训练一个线性分类器，使得当我们给定任意一个新样本 \\mathbf{x} \\mathbf{x} 的时候，分类器能推断出其对应的 \\mathbf{y} \\mathbf{y} 来（亦即是否属于该分类）。 须知 请注意我们在这里说到“线性分类器”，虽然使用“线性”一词，但准确来说，这是一个仿射变换。因为线性变换要求有齐次性，即 f(x) = \\alpha f(x) f(x) = \\alpha f(x) ，但仿射变换允许我们引入一个平移向量 \\mathbf{b} \\mathbf{b} 。当然，我们的求解的线性问题本身也是一个仿射变换。 在这个问题里，我们虽然不知道 \\mathbf{A},~\\mathbf{c} \\mathbf{A},~\\mathbf{c} ，但我们知道由 (3) (3) 确定的线性关系，因此，我们可以随机生成一组 \\mathbf{W},~\\mathbf{b} \\mathbf{W},~\\mathbf{b} ，构建线性模型： \\begin{align} \\tilde{\\mathbf{y}} = \\sigma ( \\mathbf{W} \\mathbf{x} + \\mathbf{b} ). \\end{align} 其中，可微函数 \\sigma \\sigma 是一个将实数空间 \\mathbb{R}^n \\mathbb{R}^n 映射到有限范围的实数空间 [0,~1]^n [0,~1]^n 内的函数。特别地， \\sigma(-\\infty)=0,~\\sigma(0)=0.5,~\\sigma(+\\infty)=1 \\sigma(-\\infty)=0,~\\sigma(0)=0.5,~\\sigma(+\\infty)=1 。因此，可以将 \\sigma \\sigma 看作是二分类布尔函数的插值函数。理论上，只要我们找到 \\mathbf{W}=\\mathbf{A} \\mathbf{W}=\\mathbf{A} ， \\mathbf{b}=\\mathbf{c} \\mathbf{b}=\\mathbf{c} ，则该线性分类器可以直接拟合出原分布来。 感知机 ¶ 我们将 (4) (4) 定义的线性模型称为 单层感知机 (Single-layer perceptron) 模型。它包含一个权重矩阵 \\mathbf{W} \\mathbf{W} 和一个偏置矩阵 \\mathbf{b} \\mathbf{b} 。事实上，可以将 (4) (4) 改写成如下形式 \\begin{align} \\tilde{\\mathbf{y}} = \\sigma \\left( \\begin{bmatrix} \\mathbf{W} & \\mathbf{b} \\end{bmatrix} \\begin{bmatrix} \\mathbf{x} \\\\ 1 \\end{bmatrix} \\right). \\end{align} 可见偏置本身可以看成是输入向量多了一个常数元素的等价模型。 感知机是最早的神经网络形式，它非常孱弱，只能解线性问题，但却为神经网络后来的发展开了先河。在单层感知机里，我们视输入向量 \\mathbf{x} \\mathbf{x} 的每个元素为一个“神经元”，矩阵 \\mathbf{W} \\mathbf{W} 和偏置 \\mathbf{b} \\mathbf{b} 将我们的输入映射到输出层 \\mathbf{y} \\mathbf{y} ，输出层的每个元素也视为一个神经元。在这个过程中， W_{ij} W_{ij} 作为 i i 行 j j 列的元素，代表了连接两个神经元的权重。我们用红线代表正值，蓝线代表负值，感知机可以被图示为 线性感知机的输出也是输入的线性组合，但我们可以添加激活函数，即 \\sigma(\\cdot) \\sigma(\\cdot) 将其映射到非线性空间。这要求我们添加的激活函数是一个非线性函数。 事实上，将单层感知机层叠，前一层的输出作为后一层的输入，就构建出早期的神经网络。这种网络每一层都是全连接的（两个神经元之间总是有权重，尽管值可能为0），每一层都有激活函数。理论上，任意一个两层堆叠的感知机，只要神经元数目足够多，就可以拟合出任意一个非线性函数。然而，实际测试中，这一理论的效果并不尽如人意，因此又有陆续地改进，才有了后来的深度学习。饮水思源，鉴往知来，我们也将从这个简简单单的单层模型开始，走上学习“深度学习”之旅。 Sigmoid函数 ¶ 在上述介绍中，我们没有解决的两个问题是， 如何定义插值函数 \\sigma \\sigma ？ 如何找到合适的 \\mathbf{W},~\\mathbf{b} \\mathbf{W},~\\mathbf{b} ？ 我们首先讨论第一个问题。一般地，多分类问题中，如果各个分类彼此并非相斥，且不一定要将结果分入任一类的话，我们可以用 Sigmoid 函数来定义 \\sigma \\sigma ，亦即 \\begin{align} \\sigma(\\mathbf{x}) = \\frac{1}{ 1 + e^{-\\mathbf{x}}}. \\end{align} 它同时满足 \\sigma(-\\infty)=0,~\\sigma(0)=0.5,~\\sigma(+\\infty)=1 \\sigma(-\\infty)=0,~\\sigma(0)=0.5,~\\sigma(+\\infty)=1 ，且是一个单调函数。以下代码向我们展示了这种函数的特性： Python 1 2 3 4 5 6 7 8 9 10 11 12 import numpy as np import matplotlib.pyplot as plt def test_sigmoid (): x = np . linspace ( - 5 , 5 , 100 ) y = 1 / ( 1 + np . exp ( - x ) ) plt . plot ( x , y ) plt . xlabel ( 'x' ), plt . ylabel ( 'y' ) plt . gcf () . set_size_inches ( 5 , 5 ), plt . show () if __name__ == '__main__' : test_sigmoid () Output 使用sigmoid函数的一大好处是，它的导数求解非常简单，很适合用来做神经网络这样一个复杂模型的激活函数。注意虽然 \\sigma(\\mathbf{x}) \\sigma(\\mathbf{x}) 和 \\mathbf{x} \\mathbf{x} 都是向量，这意味着导数是Jacobian矩阵，但由于 \\sigma \\sigma 是一个对 \\mathbf{x} \\mathbf{x} 各元素独立的解析函数，这个Jacobian矩阵实际上是一个对角矩阵，对角线上第j个元素的值为 \\begin{align} \\left. \\frac{ \\partial \\sigma(x) }{ \\partial x } \\right|_{x=x_j} = \\left. - e^{-x} \\left( - \\frac{1}{\\left( 1+e^{-x} \\right)^2} \\right) \\right|_{x=x_j} = - \\sigma(x_j) ( 1 - \\sigma(x_j) ). \\end{align} 可见，该函数的导数和计算函数本身的复杂度相若，可以做到快速求导。 求解问题 ¶ 接下来，我们需要解决第二个问题，亦即找到 \\mathbf{W},~\\mathbf{b} \\mathbf{W},~\\mathbf{b} 。这一问题通常可以写成反问题的形式： \\begin{align} \\arg \\min_\\limits{\\mathbf{W},~\\mathbf{b}} \\sum_{k=1}^N \\mathcal{L} \\left( \\mathbf{y}^{(k)},~ \\sigma ( \\mathbf{W} \\mathbf{x}^{(k)} + \\mathbf{b} ) \\right). \\end{align} 最简单的情况下，我们可以把 损失函数(loss function) 定义为 \\begin{align} \\mathcal{L} \\left( \\mathbf{y},~ \\tilde{\\mathbf{y}} \\right) = \\lVert \\mathbf{y} - \\tilde{\\mathbf{y}} \\rVert_2^2. \\end{align} 我们称 (8) (8) 为 逻辑斯蒂回归(logistic regression) 。有趣的是，虽然这个术语叫“回归”，但它解的其实是个分类问题。但是，既然这是一个分类问题，我们可以不使用这个损失函数，而是从概率论的角度看待这个问题。由此，我们引出一个新的损失函数：“交叉熵”。 交叉熵 ¶ 我们视sigmoid函数输出的值为一个概率，表示分类器对预测结果的确信程度，记 \\mathbf{W},~\\mathbf{b} \\in \\boldsymbol{\\Theta} \\mathbf{W},~\\mathbf{b} \\in \\boldsymbol{\\Theta} ，则 \\begin{equation} \\begin{aligned} \\mathbf{p}(y_i=1|\\mathbf{x};~\\boldsymbol{\\Theta}) &= \\sigma(\\mathbf{x};~\\boldsymbol{\\Theta}), \\\\ \\mathbf{p}(y_i=0|\\mathbf{x};~\\boldsymbol{\\Theta}) &= 1 - \\sigma(\\mathbf{x};~\\boldsymbol{\\Theta}). \\end{aligned} \\end{equation} 注意这里的概率向量的含义是，其中第i个元素表明第i个超平面分类结果的 确信程度 。 然而，这个概率只是分类器对分类结果的确信程度，却并非是分类准确度的概率，实际上，分类 准确度 的概率，应当表述为 \\begin{equation} \\begin{aligned} \\mathbf{p}(\\mathbf{y}|\\mathbf{x};~\\boldsymbol{\\Theta}) &= \\mathbf{p}(y_i=1|\\mathbf{x};~\\boldsymbol{\\Theta})^{\\mathbf{y}} \\mathbf{p}(y_i=0|\\mathbf{x};~\\boldsymbol{\\Theta})^{1-\\mathbf{y}}\\\\ &= \\sigma(\\mathbf{x};~\\boldsymbol{\\Theta})^{\\mathbf{y}} \\left(1 - \\sigma(\\mathbf{x};~\\boldsymbol{\\Theta}) \\right)^{1-\\mathbf{y}}. \\end{aligned} \\end{equation} 注意 这里 \\mathbf{x}^{\\mathbf{y}} \\mathbf{x}^{\\mathbf{y}} 表示的是对每个元素一一求取指数，即函数第i个元素的返回值应当为 {x_i}^{y_i} {x_i}^{y_i} 。 我们使用真实值 \\mathbf{y} \\mathbf{y} 作为指数给概率向量加权。当 \\mathbf{y}=1 \\mathbf{y}=1 时，乘积项的第二个因子消去，该函数退化为以预测值为1的可信度 \\mathbf{p}(y_i=1|\\mathbf{x};~\\boldsymbol{\\Theta}) \\mathbf{p}(y_i=1|\\mathbf{x};~\\boldsymbol{\\Theta}) ；反之则第一个因子消去，退化为以预测值为0的可信度 \\mathbf{p}(y_i=0|\\mathbf{x};~\\boldsymbol{\\Theta}) \\mathbf{p}(y_i=0|\\mathbf{x};~\\boldsymbol{\\Theta}) 。这就是最大似然估计方法。至此，我们可以写出似然估计函数 \\begin{align} L(\\boldsymbol{\\Theta}) = \\mathbf{p}(\\mathbf{y}^{(k)}|\\mathbf{x}^{(k)};~\\boldsymbol{\\Theta}). \\end{align} 对似然估计函数取对数，则有 \\begin{equation} \\begin{aligned} l(\\boldsymbol{\\Theta}) &= \\sum_{k=1}^N \\log \\left( \\mathbf{p}(\\mathbf{y}^{(k)}|\\mathbf{x}^{(k)};~\\boldsymbol{\\Theta}) \\right) \\\\ &= \\sum_{k=1}^N \\mathbf{y}^{(k)} \\cdot \\log\\left(\\sigma(\\mathbf{x}^{(k)};~\\boldsymbol{\\Theta})\\right) + \\left(1 - \\mathbf{y}^{(k)} \\right) \\cdot \\log\\left(1 - \\sigma(\\mathbf{x}^{(k)};~\\boldsymbol{\\Theta})\\right). \\end{aligned} \\end{equation} 我们最终的目的是要最大化似然函数，亦即 \\mathbf{W},~\\mathbf{b} = \\arg\\max\\limits_{\\boldsymbol{\\Theta}} l(\\boldsymbol{\\Theta}) \\mathbf{W},~\\mathbf{b} = \\arg\\max\\limits_{\\boldsymbol{\\Theta}} l(\\boldsymbol{\\Theta}) ，这等价于最小化 -l(\\boldsymbol{\\Theta}) -l(\\boldsymbol{\\Theta}) 。对比 (8) (8) 和 (9) (9) ，于是我们可以定义交叉熵为 \\begin{align} \\mathcal{L} \\left( \\mathbf{y},~ \\tilde{\\mathbf{y}} \\right) = - \\mathrm{mean}\\left[ \\mathbf{y} \\cdot \\log\\left( \\tilde{\\mathbf{y}} \\right) + \\left(1 - \\mathbf{y} \\right) \\cdot \\log\\left(1 - \\tilde{\\mathbf{y}} \\right) \\right]. \\end{align} 注意这里我们使用 \\mathrm{mean}\\left[ \\cdot \\right] \\mathrm{mean}\\left[ \\cdot \\right] 表示求取一个向量所有元素的平均值。实际上，Tensorflow允许我们定义损失函数的输出为一个和输出向量维度相同的向量，Tensorflow自带的交叉熵也是这样定义的。实际应用时，Tensorflow会自动在向量维度上求均值，并压缩成上述 (14) (14) 的形式。 若我们记 \\tilde{\\mathbf{y}} = \\sigma(\\tilde{\\mathbf{x}}) \\tilde{\\mathbf{y}} = \\sigma(\\tilde{\\mathbf{x}}) ，代入sigmoid函数，为了确保该损失函数的稳定性，我们可以将 (14) (14) 整理为 \\begin{align} \\mathcal{L} \\left( \\mathbf{y},~ \\tilde{\\mathbf{x}} \\right) = \\mathrm{mean}\\left[ \\max(\\tilde{\\mathbf{x}}, \\mathbf{0}) - \\tilde{\\mathbf{x}} \\cdot \\mathbf{y} + \\log\\left(1 + e^{-|\\tilde{\\mathbf{x}}|} \\right) \\right]. \\end{align} 提示 这里交叉熵整理的推导过程参见 Tensorflow-API官方文档 。 实际情况下，我们使用 (15) (15) 来求取sigmoid函数激活下的交叉熵。 解线性多分类问题 ¶ 接下来，我们将开始实战上手，编写我们的第一个Project。虽然一个Project的格式并无定法，每个人按照自己的喜好会选择不同的风格，但一个从无受过训练的人，往往写出的Project几乎完全不具有可读性。实际上，学习任何语言， 变量命名规范 、 缩进规范 以及 模块化 、 面向对象 等都被认为是编写一个具有可读性的代码所不得不知的概念。本教程所推荐的代码格式，均具有统一的风格，读者在了解每个Project和其对应的教程时，会慢慢熟悉这种风格的特点。愿读者能从这样的风格中得到启发，得到 代码可读性 的神髓。 代码规范 ¶ 建立一个具有较强可读性的Tensorflow工程需要我们活用python的模块化设计。我们通常推荐以下的结构 . ├─ data/ # where we store our data │ └─ ... ├─ tools.py # codes for post-processing and analyzing records. ├─ extension.py # codes for extending the tensorflow model. ├─ dparser.py # data parser └─ main.py # main module where we define our tensorflow model. 除了保存数据的文件夹，我们应当有三个子模块。其中 tool : 用来处理、分析生成的数据，通常与Tensorflow无关； extension : 用来扩展tensorflow，例如在这里自定义网络层和操作符； dparser : 数据处理器，用来读取并预处理送入网络的数据； main : 主模块，只定义跟Tensorflow模型有关的内容，需要引用 extension 和 dparser 。 视情况可以灵活调整结构，但建议将定义Tensorflow模型的代码单独放在主模块里，和其他外围代码分离。 撰写各个模块时，建议使用类封装各组功能相同的函数。具有良好使用习惯的coder应当注意给各个面向用户的类、函数撰写（哪怕简短的）说明文字，在一些较长的函数、方法的定义中，适当注释各部分的功能，以便读者能正确理解代码意义。 另外，在对象命名上，python有如下必须遵守或不成文的规定，和C/C++用户熟悉的蛇形命名法不同，它大致包括 类与函数多用驼峰命名法，变量可以采用驼峰或蛇形命名法。 驼峰命名法指的是用大小写区分每个单词块，例如 alphaBetaFunction () ； 蛇形命名法指的是用下划线区分每个单词块，例如 alpha_beta_function = 10 ； 宏变量使用全字大写+蛇形命名法 函数/方法，还有模块均是首字母小写，但类的首字母大写。 用单下划线 _ 表示临时存储器，或省略参数，例如一个函数 func () 有两个返回值时，可以用 _ , b = func () 表示我们只需要第二个返回值；单下划线还可以与星号连用省略多个返回值； 以单下划线开头的方法，表示模块级的私有方法，在模块以外使用 import 导入类时，不会导入这些方法，例如 def _alphaBeta ( self ): ； 以单下划线结尾的对象，用来和python的关键字区分，例如 func ( x , class_ ) ; 以双下划线开头的方法，如果不以双下划线结尾，则表示类级的私有方法，只有类内部的方法能调用这些方法，在类外部、包括继承的子类里都原则上不能调用（但其实也有办法调用），例如 def _alphaBeta ( self ): ； 以双下划线同时开头和结尾的方法，一般是用来 重写 (override) 特殊功能，例如 def __getattribute__ (): 将重写获得类属性的方法。 Tensorflow的数据概念 ¶ 在Tensorflow中，我们把变量都称为“ 张量 (Tensor) ”。这是因为我们有零维的标量，一维的向量，二维的矩阵，更高维的我们都称为张量。作为一个更大的概念，张量当然也可以用来包括标量、向量和矩阵了。在Tensorflow中，有的张量是 可以训练 (trainable) 的，有的则不是。比如一个张量的形状（指各维大小），当然可以是一个 < tf . Tensor 'Shape:0' shape = ( 1 ,) dtype = int32 > 类型的张量，但它不是变量，当然就不可训练。我们也可以人为控制某些张量可以训练或不可以训练，但本节、乃至本章所介绍的凡是我们接触到的张量，都是可以训练的。 特别地，对于神经网络而言，在网络内计算（或者说流动、传播）的一个n维数据，通常按照以下形式组织： tensor [ batch , dim1 , dim2 , ... , dimn , channel ] 其中，第一个维度 batch 一定存在，它表示的是单个batch中的某一个样本。如果一个batch只有一个样本，那么 batch 只能取0。 从 dim1 到 dimn 指的是实际的n维数据的各个维度； channel 指的是数据的通道，例如，一个二维RGB图像，每种颜色代表一个通道，因此有三个通道。 channel 通常用在卷积网络里，我们经常需要在深度卷积网络里不断增大通道数的同时，缩小数据尺寸。 在某些特殊情况下， channel 维度可以不存在，例如我们使用的是全连接层而不是卷积网络， tf.keras.layer.Flatten 可以用来将一个有通道的张量压缩成一个没有通道的一维向量（但是注意 batch 维度仍然存在，不会被压缩）。 因此，我们知道一个n维的数据，在神经网络中通常被描述为一个n+2维的矩阵，而一个一维向量，在卷积网络里是三维的： vector [ batch , length , channel ] 但是在全连接网络里，是二维的： vector [ batch , channel ] 在本节，乃至本章里，我们还不讨论卷积网络，因此我们都是使用二维张量（一维向量组）作为我们的数据。 数据生成 ¶ 在本项目里，我们不需要扩展Tensorflow。但是，我们需要以随机生成数据代替数据集。因此，首先，通过以下代码定义数据生成器 dparser.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class TestDataSet : ''' A generator of the data set for testing the linear model. ''' def __init__ ( self , scale_x , A , c ): ''' Initialize the data generator. scale_x: the scale of input vector. A, c: the linear transformation. ''' self . s_x = 2 * scale_x self . A = A self . c = c self . len_x = A . shape [ 0 ] self . config () def config ( self , train = True , batch = 100 , noise = 0.1 ): ''' Configuration train: a flag for controlling the iterator mode. batch: the number of samples in a batch noise: std. of the error added to the y. ''' self . train = bool ( train ) self . batch = batch self . noise = noise def next_train ( self ): ''' Get the next train batch: (x, y) ''' x = self . s_x * ( np . random . random ([ self . batch , self . len_x ]) - 0.5 ) y = np . matmul ( x , self . A ) + self . c if self . noise > 1e-3 : y = y + np . random . normal ( 0 , self . noise , size = y . shape ) y = np . greater ( y , 0.0 ) . astype ( np . float32 ) return x , y def next_test ( self ): ''' Get the next test batch x. ''' return self . s_x * ( np . random . random ([ self . batch , self . len_x ]) - 0.5 ) def __iter__ ( self ): while True : samp = self . __next__ () yield samp def __next__ ( self ): if self . train : return self . next_train () else : return self . next_test () 该生成器输入一组 \\mathbf{A},~\\mathbf{c} \\mathbf{A},~\\mathbf{c} ，以及相关配置，之后就可以通过 迭代器 (iterator) 或 方法 (method) 随机生成数据。这种数据集写法我们在后面还会用到， model . fit 允许我们不是馈入样本（或样本批次），而是馈入一个 生成器(generator) 。因此我们重写了 __iter__ 方法，并使其通过 yield 返回一个生成器。这样我们定义的数据集类就可以被Keras的训练函数 model . fit 使用。接下来，调用如下测试代码： dparser.py 1 2 3 4 5 6 7 8 9 10 def test_dataset (): A = np . random . normal ( 0 , 10 , [ 10 , 6 ]) c = np . random . uniform ( 1 , 3 , [ 1 , 6 ]) dataSet = TestDataSet ( 10 , A , c ) dIter = iter ( dataSet ) for i in range ( 10 ): x , y = next ( dIter ) print ( np . sum ( y , axis = 0 ) / 100 ) test_dataset () Output [ 0.47 0.57 0.58 0.56 0.5 0.38 ] [ 0.6 0.61 0.47 0.48 0.38 0.52 ] [ 0.5 0.61 0.49 0.42 0.45 0.53 ] [ 0.59 0.52 0.44 0.44 0.49 0.51 ] [ 0.54 0.59 0.48 0.5 0.51 0.47 ] [ 0.49 0.57 0.56 0.49 0.53 0.4 ] [ 0.5 0.61 0.51 0.54 0.51 0.52 ] [ 0.5 0.51 0.61 0.5 0.44 0.5 ] [ 0.44 0.46 0.53 0.45 0.56 0.52 ] [ 0.52 0.46 0.51 0.52 0.49 0.44 ] 我们随机生成了 \\mathbf{x} \\mapsto \\mathbf{y}:~\\mathbb{R}^{10} \\mapsto \\mathbb{R}^6 \\mathbf{x} \\mapsto \\mathbf{y}:~\\mathbb{R}^{10} \\mapsto \\mathbb{R}^6 的数据，每组数据100个，并且测试了10组。输出结果是各组测试中， \\mathbf{y} \\mathbf{y} 在对应维度上分类为1的概率估计。结果基本都在0.5左右，说明我们的这种数据生成模式产生的点能均匀分布在各个超平面两侧，适合进行后续测试。 定义线性顺序模型 ¶ 顺序 (sequential) 模型是一个单输入单输出模型，网络结构较为简单，也不存在跨层短接（残差连接）。在大多数情况下，已经上手的Tensorflow用户不使用这个模型，故而作为我们入门的第一个project，我们姑且用之，但我们将不再使用顺序模型来实现后续的project。一个顺序模型大致可以描述为下图的模式： graph LR st(输<br/>入) --> l1[层<br/>1] l1 --> l2[层<br/>2] l2 --> l3[层<br/>3] l3 --> ldots[层<br/>...] ldots --> ed(输<br/>出) classDef styStart fill:#FAE6A9,stroke:#BA9132; class st,ed styStart 由于我们完成的是一个线性分类器，故而我们使用单层的序列模型即可。 接下来，我们来定义一个类， class LinClsHandle : 。定义一个类的时候，我们通常需要定义的内容包括 在初始化方法 __init__ 里定义传入网络的固定参数，例如学习速率，存取路径等； 在方法 construct 里定义网络的构造和使用的优化器； 在方法 train 里定义训练网络的过程，主要需要调用 model . fit 。如果我们在数据集的定义非常完善，则这一环节不需要花费太多的功夫； 在方法 test 里定义测试网络的过程，主要需要调用 model . evaluate 。如果有必要，可以通过 model . predict 返回测试结果。 初始化方法 ¶ 首先，定义初始化方法： lin-cls.py: class LinClsHandle 1 2 3 4 5 6 7 8 9 10 def __init__ ( self , learning_rate = 0.01 , epoch = 10 , steppe = 30 ): ''' Initialization and pass fixed parameters. learning_rate: the learning rate for optimizer. epoch: training epochs. steppe: steps per epoch ''' self . lr = learning_rate self . epoch = epoch self . steppe = steppe 由于目前我们的project还非常简单，这里只需要有学习速率( learning_rate )，轮次数( epoch )和每轮迭代次数( steppe )即可。 构造方法 ¶ 接下来定义网络构造 lin-cls.py: class LinClsHandle 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def construct ( self ): ''' Construct a linear model and set the optimizer as Adam ''' # Construction self . model = tf . keras . Sequential () self . dense1 = tf . keras . layers . Dense ( LABEL_SHAPE , use_bias = True , input_shape = ( INPUT_SHAPE ,), kernel_initializer = tf . keras . initializers . RandomNormal ( 0.0 , stddev = 10.0 ), bias_initializer = tf . keras . initializers . Constant ( 2 ), activation = tf . nn . sigmoid ) self . model . add ( self . dense1 ) # Set optimizer self . model . compile ( optimizer = tf . train . AdamOptimizer ( self . lr ), loss = tf . keras . losses . BinaryCrossentropy (), metrics = [ self . accuracy , tf . keras . metrics . BinaryAccuracy ()] ) @staticmethod def accuracy ( y_true , y_pred ): return tf . keras . backend . mean ( tf . keras . backend . equal ( y_true , tf . keras . backend . round ( y_pred ))) 须知 这里 LABEL_SHAPE 和 INPUT_SHAPE 为两个宏变量，分别为输出和输入的向量维度。 我们使用 Dense 定义全连接层，它的用法请参照 这里 。由于我们已经知道 \\mathbf{A} \\mathbf{A} 和 \\mathbf{c} \\mathbf{c} 可能的取值范围，这里我们重定义了 \\mathbf{W} \\mathbf{W} 和 \\mathbf{b} \\mathbf{b} 的初始化方式。 信息: Dense API tf . keras . layers . Dense ( shape , ** kwargs ) 指全连接层，其输入一组已知形状的向量，输出一组形状为 shape 的向量。可用的API如下： shape : 正整数，输出空间维度。 activation : 激活函数。 若不指定，则不使用激活函数 (即，线性激活: a(\\mathbf{y}) = \\mathbf{y} a(\\mathbf{y}) = \\mathbf{y} )。该函数可以定义为任何元素级操作的Tensorflow函数。 use_bias : 布尔值，该层是否使用偏置向量。 True 则网络定义为 \\mathbf{y} = \\mathbf{W}\\mathbf{x} + \\mathbf{b} \\mathbf{y} = \\mathbf{W}\\mathbf{x} + \\mathbf{b} ， False 则定义为 \\mathbf{y} = \\mathbf{W}\\mathbf{x} \\mathbf{y} = \\mathbf{W}\\mathbf{x} 。 kernel_initializer : kernel 权值矩阵的初始化器，自定义的初始化器需要使用Keras后端API编写。 bias_initializer : 偏置向量的初始化器，同上。 kernel_regularizer : 运用到 kernel 权值矩阵的正则化函数，自定义的正则化函数需要使用Keras后端API编写。 bias_regularizer : 运用到偏置向的的正则化函数，同上。 activity_regularizer : 运用到层的输出的正则化函数，同上。 kernel_constraint : 运用到 kernel 权值矩阵的约束函数，只能使用Keras备选的几种方案，不能自定义。 bias_constraint : 运用到偏置向量的约束函数，同上。 信息: model.compile API model . compile ( optimizer , ** kwargs ) 在这里指的是顺序模型的编译函数，其可用的API如下： optimizer : 优化器，可以使用Tensorflow内置的优化器。 loss : 损失函数，也是目标函数。顺序模型只有一个输出，因此只能传入一个损失函数。可以使用形式为 func ( y_true , y_pred ) 的Tensorflow函数。 metrics : 测度函数，一般是一组函数，如果是一个函数则定义为 [ func ] 即可。自定义的测度函数目前还需要使用Keras后端API编写。 loss_weights : 损失的权重，顺序模型只有一个损失函数，因此只有一个权重，但要使用一维列表 [ value ] 定义。可以使用张量来控制可变权重。 sample_weight_mode : 按时间步采样权重，默认不提供。相比上面的损失权重，该选项会随着迭代次数使用不同的权重，因此输入的是二维列表。 weighted_metrics : 测度的权重，和损失权重类似，用来加给不同的测度函数。由于我们可以使用不只一个测度函数，这里的权重是个一维列表。 target_tensors : 默认情况下，Keras 将为模型的目标创建一个占位符，在训练过程中将使用目标数据。相反，如果你想使用自己的目标张量（反过来说，Keras在训练期间不会载入这些目标张量的外部 Numpy数据），您可以通过 target_tensors 参数指定它们。对于单输出的顺序模型，它应该是单个张量。 ** kwargs : 其他参量，会传递给 tf . Session . run 。 另外，注意我们这里构造网络的时候有如下技巧： Tensorflow在导入Keras模式以后，已经不再使用 (15) (15) 的形式定义 sigmoid交叉熵 ，而是采取更通用的定义 (14) (14) ； 我们使用Tensorflow重新封装过的类， 二分类交叉熵 ( BinaryCrossentropy ) 来作为Keras模型的损失函数 self.loss ，该函数与 多分类交叉熵 ( CategoricalCrossentropy ) 不同，乃是对两组对比张量的每个元素分别计算交叉熵，再求取均值，正符合本应用的需求； 我们通过静态方法，调用Keras的后端API，自己定义了预测准确度的测度函数 self.accuracy ，同时也使用另一个来自Tensorflow封装好的测度类 二分类准确度 ( BinaryAccuracy ) ，这是为了比照两个准确度的区别，以便我们更好理解该测度类； 我们将网络层的关键字 self.dense1 保留在了实例中，这是为了确保接下来我们能通过实例抽取该层的参数。 需要注意的是，由于 二分类交叉熵 ， 二分类准确度 和 多分类交叉熵 等都是类（从它们的定义都是大写字母开头也可以看出来），因此我们需要在使用的时候后面加上括号以实例化；由于这些类都定义了 __call__ 方法，我们可以像使用函数一样使用它们的实例。 训练和测试方法 ¶ 最后定义的式训练和测试方法。由于我们目前的project还比较简单，关于这两部分都直接调用现有的API即可。使用的API在之前已经说明。 model.fit 在没有额外设置的情况下，默认会返回一个 History回调器 ； model.evaluate 返回的是测试样本给出的损失函数和准确值测度。 model.predict 返回的是测试样本给出的网络输出。详情请参照 顺序模型API 。 lin-cls.py: class LinClsHandle 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def train ( self , dataSet ): ''' Use a data set to train the network. ''' return self . model . fit ( dataSet , epochs = self . epoch , steps_per_epoch = self . steppe ) def test ( self , data , labels ): ''' Use (data, label) pairs to test the results. ''' loss , accu = self . model . evaluate ( data , labels ) print ( 'Evaluated loss =' , loss ) print ( 'Evaluated accuracy =' , accu ) return self . model . predict ( data ) 信息: model.fit API model . fit ( dataSet , ** kwargs ) 是训练函数，注意这个函数虽然支持输入一组 x,~y x,~y 用来代替 dataSet ，我们还是建议在任何情况下都用dataSet馈送数据，以免内存中数据集占用过多。 dataSet : 数据集，其本身应当是一个 tf.data.Dataset 类型的类，或者是一个能不断迭代产生新数据的生成器。数据的 batch 大小由 dataSet 本身决定。 epochs : 整数，终止训练时经历的世代(轮次)数，通常一个epoch表示遍历整个数据集一回。 verbose : 0, 1或2。日志显示模式。 0=安静模式, 1=进度条, 2=每轮一行。默认是1。 callbacks : 回调器，它是 tf.keras.callbacks 模块下的类，用来在训练中进行记录保存和数据检查点更新。默认是 tf.keras.callbacks.History 。 validation_split : 在 0 和 1 之间浮动。用作验证集的训练数据的比例。模型将分出一部分不会被训练的验证数据，并将在每一轮结束时评估这些验证数据的误差和任何其他模型指标。验证数据是混洗之前 x 和 y 数据的最后一部分样本中。 validation_data : 元组 (x_val，y_val) 或元组 (x_val，y_val，val_sample_weights) ，用来评估损失，以及在每轮结束时的任何模型度量指标。模型将不会在这个数据上进行训练。这个参数会覆盖 validation_split 。 shuffle : 布尔值（是否在每轮迭代之前混洗数据）。当 steps_per_epoch 非 None 时，这个参数无效。 class_weight : 可选的字典，用来映射类索引（整数）到权重（浮点）值，用于加权损失函数（仅在训练期间）。这可能有助于告诉模型 「更多关注」来自代表性不足的类的样本。 sample_weight : 用来给损失函数添加权重，作用类似 model.compile 的同一参数。 initial_epoch : 开始训练的轮次（有助于恢复之前的训练）。 steps_per_epoch : 在声明一个轮次完成并开始下一个轮次之前的总步数（样品批次）。使用TensorFlow数据张量等输入张量进行训练时，默认值 None 等于数据集中样本的数量除以 batch 的大小，如果无法确定，则为1。 validation_steps : 只有在指定了 steps_per_epoch 时才有用。停止前要验证的总步数（批次样本）。 该函数会返回 callbacks 定义的实例。 信息 model.evaluate API model . evaluate ( x , y , ** kwargs ) 是测试函数，需要传入 label 即 y 来验证性能。 x , y : Numpy 数组，分别是输入和输出的真实参照值。 batch_size : 计算的 batch 大小，该函数会将输入的数据组拆分成许多 batch 分别计算，并组合起来，这个设定值对效果不产生影响，只影响计算过程。 verbose : 0, 1。日志显示模式。0=安静模式, 1=进度条。默认是1。 sample_weight : 用来给损失函数添加权重，作用类似 model.compile 的同一参数。 steps : 整数或 None 。 声明评估结束之前的总步数（批次样本）。默认值 None 。 该函数会返回损失函数和测度（列表）。 信息 model.predict API model . predict ( x , ** kwargs ) 是预测函数，用在只知道输入 x 的场合。 x : Numpy 数组，输入值。 batch_size : 计算的 batch 大小，该函数会将输入的数据组拆分成许多 batch 分别计算，并组合起来，这个设定值对效果不产生影响，只影响计算过程。 verbose : 0, 1。日志显示模式。0=安静模式, 1=进度条。默认是1。 steps : 整数或 None 。 声明评估结束之前的总步数（批次样本）。默认值 None 。 该函数返回预测结果。 调试 ¶ 首先，训练网络。我们随机生成 \\mathbf{x} \\mapsto \\mathbf{y}:~\\mathbb{R}^{10} \\mapsto \\mathbb{R}^6 \\mathbf{x} \\mapsto \\mathbf{y}:~\\mathbb{R}^{10} \\mapsto \\mathbb{R}^6 的仿射变换，并且设置好数据集，给定噪声扰动为 \\boldsymbol{\\varepsilon} \\sim \\mathcal{N}(0,1)^6 \\boldsymbol{\\varepsilon} \\sim \\mathcal{N}(0,1)^6 。设定20个epoch，每个epoch迭代500次，每次馈入32个样本构成的batch，然后开始训练： lin-cls.py 1 2 3 4 5 6 7 8 9 # Initialization A = np . random . normal ( 0 , 10 , [ INPUT_SHAPE , LABEL_SHAPE ]) c = np . random . uniform ( 1 , 3 , [ 1 , LABEL_SHAPE ]) dataSet = dp . TestDataSet ( 10 , A , c ) dataSet . config ( batch = 32 , noise = 0.1 ) # Construct the model and train it. h = LinClsHandle ( learning_rate = 0.01 , epoch = 20 , steppe = 500 ) h . construct () record = h . train ( iter ( dataSet )) Output Epoch 1 /20 500 /500 [==============================] - 1s 3ms/step - loss: 6 .3005 - accuracy: 0 .5884 - binary_accuracy: 0 .5884 Epoch 2 /20 500 /500 [==============================] - 1s 2ms/step - loss: 5 .4671 - accuracy: 0 .6407 - binary_accuracy: 0 .6407 Epoch 3 /20 500 /500 [==============================] - 1s 2ms/step - loss: 4 .5711 - accuracy: 0 .6957 - binary_accuracy: 0 .6957 Epoch 4 /20 500 /500 [==============================] - 1s 2ms/step - loss: 3 .6789 - accuracy: 0 .7519 - binary_accuracy: 0 .7519 Epoch 5 /20 500 /500 [==============================] - 1s 2ms/step - loss: 2 .7101 - accuracy: 0 .8127 - binary_accuracy: 0 .8127 Epoch 6 /20 500 /500 [==============================] - 1s 2ms/step - loss: 2 .0059 - accuracy: 0 .8627 - binary_accuracy: 0 .8627 Epoch 7 /20 500 /500 [==============================] - 1s 2ms/step - loss: 1 .6403 - accuracy: 0 .8894 - binary_accuracy: 0 .8894 Epoch 8 /20 500 /500 [==============================] - 1s 2ms/step - loss: 1 .3663 - accuracy: 0 .9066 - binary_accuracy: 0 .9066 Epoch 9 /20 500 /500 [==============================] - 1s 2ms/step - loss: 1 .0466 - accuracy: 0 .9274 - binary_accuracy: 0 .9274 Epoch 10 /20 500 /500 [==============================] - 1s 2ms/step - loss: 0 .8377 - accuracy: 0 .9418 - binary_accuracy: 0 .9418 Epoch 11 /20 500 /500 [==============================] - 1s 2ms/step - loss: 0 .6465 - accuracy: 0 .9546 - binary_accuracy: 0 .9546 Epoch 12 /20 500 /500 [==============================] - 1s 2ms/step - loss: 0 .4492 - accuracy: 0 .9667 - binary_accuracy: 0 .9667 Epoch 13 /20 500 /500 [==============================] - 1s 2ms/step - loss: 0 .2795 - accuracy: 0 .9779 - binary_accuracy: 0 .9779 Epoch 14 /20 500 /500 [==============================] - 1s 2ms/step - loss: 0 .1624 - accuracy: 0 .9861 - binary_accuracy: 0 .9861 Epoch 15 /20 500 /500 [==============================] - 1s 2ms/step - loss: 0 .0680 - accuracy: 0 .9926 - binary_accuracy: 0 .9926 Epoch 16 /20 500 /500 [==============================] - 1s 2ms/step - loss: 0 .0128 - accuracy: 0 .9971 - binary_accuracy: 0 .9971 Epoch 17 /20 500 /500 [==============================] - 1s 2ms/step - loss: 0 .0055 - accuracy: 0 .9981 - binary_accuracy: 0 .9981 Epoch 18 /20 500 /500 [==============================] - 1s 2ms/step - loss: 0 .0052 - accuracy: 0 .9986 - binary_accuracy: 0 .9986 Epoch 19 /20 500 /500 [==============================] - 1s 2ms/step - loss: 0 .0055 - accuracy: 0 .9981 - binary_accuracy: 0 .9981 Epoch 20 /20 500 /500 [==============================] - 1s 2ms/step - loss: 0 .0049 - accuracy: 0 .9985 - binary_accuracy: 0 .9985 接下来，从训练返回的 History 类型的回调器中抽取对loss和accuracy的记录。 lin-cls.py 1 2 3 4 5 # Show records plt . semilogy ( record . epoch , record . history [ 'loss' ]), plt . xlabel ( 'epoch' ), plt . ylabel ( 'Cross entropy' ) plt . gcf () . set_size_inches ( 5 , 5 ), plt . show () plt . plot ( record . epoch , record . history [ 'accuracy' ], label = 'self defined' ), plt . plot ( record . epoch , record . history [ 'binary_accuracy' ], label = 'from tensorflow' ), plt . xlabel ( 'epoch' ), plt . ylabel ( 'Accuracy' ), plt . legend () plt . gcf () . set_size_inches ( 5 , 5 ), plt . show () Output 结果显示，我们自定义的准确度测度和Tensorflow内置的 二分类准确度 完全相同，这说明其本身的定义就是求取所有元素阈值化后，各自分类结果是否正确的平均值。这个实验也让我们对自定义测度函数有了一定的认识。 重新设定数据集的产生方式，变为每个batch含10个样本。使用这组重新随机生成的数据测试网络输出， lin-cls.py 1 2 3 4 5 6 7 8 9 10 11 12 # Generate a group of testing samples: dataSet . config ( batch = 10 ) x , y = next ( dataSet ) # Check the testing results yp = h . test ( x , y ) _ , ( ax1 , ax2 ) = plt . subplots ( 1 , 2 ) ax1 . imshow ( y , interpolation = 'nearest' , aspect = 'auto' ) ax1 . set_title ( 'True class' ) ax2 . imshow ( yp , interpolation = 'nearest' , aspect = 'auto' ) ax2 . set_title ( 'Predicted class' ) plt . gcf () . set_size_inches ( 10 , 5 ), plt . show () Output Evaluated loss ( losses.BinaryCrossentropy ) = 0 .0023145806044340134 Evaluated accuracy ( self defined ) = 1 .0 Evaluated accuracy ( metrics.BinaryAccuracy ) = 1 .0 注意我们未对测量的结果阈值化，因此显示出来的测量结果和理想值略有差别，但从图可知，阈值化后则测量结果全部准确。 通过抽取 h.dense1 的参数，我们可以对比 \\mathbf{A} \\mathbf{A} 和 \\mathbf{W} \\mathbf{W} ，以及 \\mathbf{c} \\mathbf{c} 和 \\mathbf{b} \\mathbf{b} ， lin-cls.py 1 2 3 4 5 6 7 8 9 10 11 # Check the regressed values W , b = h . dense1 . get_weights () plt . imshow ( A , interpolation = 'nearest' , aspect = 'auto' ), plt . colorbar (), plt . gca () . set_title ( 'A' ) plt . gcf () . set_size_inches ( 6 , 5 ), plt . show () plt . imshow ( W , interpolation = 'nearest' , aspect = 'auto' ), plt . colorbar (), plt . gca () . set_title ( 'W' ) plt . gcf () . set_size_inches ( 6 , 5 ), plt . show () plt . plot ( c . T , label = 'c' ) plt . plot ( b . T , label = 'b' ) plt . legend () plt . gcf () . set_size_inches ( 5 , 5 ), plt . show () Output 可以发现，虽然我们训练的分类器十分有效，但其权值和预期的 \\mathbf{A} \\mathbf{A} , \\mathbf{c} \\mathbf{c} 并不完全相同。这是由于sigmoid函数激活的特性，使得当预测值偏向最小或最大的情况下， |\\sigma(x)| \\rightarrow 1 |\\sigma(x)| \\rightarrow 1 ，根据 (7) (7) ，可知其梯度 |\\sigma(x)(1-\\sigma(x))| \\rightarrow 0 |\\sigma(x)(1-\\sigma(x))| \\rightarrow 0 ，因此那些分类结果已经比较确信的样本，其梯度消失，对训练网络的影响忽略不计（这是合理的，因为我们不希望极端样本干扰结果，更希望对分类结果不确切的样本进行训练）。故而，我们虽然可以求解出这个分类问题，但求解到的 \\mathbf{W} \\mathbf{W} , \\mathbf{b} \\mathbf{b} 不会回归到 \\mathbf{A} \\mathbf{A} , \\mathbf{c} \\mathbf{c} 上。关于回归问题，我们会在下一节进一步讨论。","text_tokens":["42","符","以免","一层","defined","size","一节","映射","class","内部","generate","end","参见","实战","复杂度","存在","后续","包含","线性","部分","'","压缩","范围","下来","使用","不会","cdot","情况","点","initializer","面向对象","26","ed","title","perceptron","时","0.52","^","无效","0055","权值","干扰","确切","构造","互不","封装","entropy","accu","0.59","蛇形","全字","详情","类级","大小写","w","操作符","角度","负值","linclshandle","不成","找到","采用","一些","分出","样品","若","相关","权重","预测","但类","added","our","通常","超平面","partial","&","而言","31","10","发现","学习","100","yp","可以","以后","37","无定法","已知","results","定性","verbose","数据分布","record","align","过来","指各维","化后","停止","max","技巧","不足","<","(","主","不是","正","视","extending","再","大写","变换","ax1","testdataset","往往","大多数","首先","称","return","安静","use","以便","44","rvert","化","将","简简单单","结果显示","9779","称为","diter","面向用户","文档","一大","要求","一行","steps","更大","else","一一","自定","接下","import","0.48","设置","[","分别","标准","等价","第一个","greater","传播","有用","进一步","另","集中","categoricalcrossentropy","函数","一般","概率","本节","每组","熟悉","“","0.57","故而","├","类似","可读性","优化","用到","rightarrow","二维","反之","binaryaccuracy","0.1","后","不以","前","深度","均值","理器","可见","矩阵","l2","消失","一个","大写字母","存储器","关于","调用","略有","于是","法指","大小","对","configuration","自己","：","与","开头","infty","入门","提示","无法","较为简单","to","同一","还是","浮动","单层","线性变换","if","上","session","cls","...","预处理","步数","正确理解","你","0128","0.4","lr","恢复","必须","rate","神经网络","引用","轴","/","期间","首字","描述","loss","0.53","）","子",",","总","齐次","规定","定法","15","x","不成文","split","组织","推断","backend","人意","41","」","过","为了","默认值","mean","馈送","集","确定","根据","输","开始","设定","mathbb","受过","0.54","kernel","py","维度","模型","等于","controlling","第","乃是","normal","0.56","right","压缩成","每次","入","activation","length","项","from","epoch","静态方法","较为","特点","0.5","到","性关系","模式","33","十分","非","9066","subplots","求取","9274","开","多用","输出","evaluated","梯度","导数","信息","布尔","ylabel","一轮","left","误差","for","iter","的话","包括","我们","同","网络层","regression","个","表明","initial","用来","n","控制","下图","we","validation","平移","术语","能","nearest","不知","于","统一","就","推荐","有趣","仿射","预期","第二","mathcal","一步","两个","平均值","imshow","传递","一侧","分类器","每轮","基本概念","29","17","记录","─","手","27","程度","8894","至此","初始化","生成器","和","写法","其他","channel","0.01","define","连接","本","c","2ms","¶","整个","32","交叉","这样","可知","construct","回归","语言","调试","迭代","经历","划线","灵活","这个","bmatrix","时候","test","获得","了解","使得","output","任意","_","接下来","0.38","参量","神经","k","model","文件","39","分类","意义","子类","正值","建立","\\","或者说","看作","transformation","adamoptimizer","一类","54","缩成","该层","等","早期","看成","9926","叫","post","流动","实际上","确信","lvert","习惯","由","亦","格式","宏","可选","好处","frac","method","kwargs",".","这","引入","，","消","input","func","testing","adam","外围","因子","重写","激活","另外","用作","花费","覆盖","教程","平面","3005","self","第二个","左右","没有","predict","一个二维","单个","aspect","某","value","8377","特别","46","差别","要","配置","特殊","二","现有","认识","应用","每种","dim1","predicted","rgb","l3","功能","由于","信度","里","注意","learning","类时",">","项目","45","鉴往知来","因此","都","测试代码","其实","关键","23","logistic","乃至","min","需求","sum","偏置","range","r","短接","coder","特征","11","蓝线","您","0466","未知","50","做","神经网","轮次","fit","lin","parser","过程","然后","28","22","全","可读","对角","默认","无","稳定性","0.51","很","太多","9418","给出","内置","nn","在","bool","含义","最早","7101","特性","34","这一","只要","大化","增大","高维","np","姑且","似然","尺寸","列","那些","activity","constant","摘要","arg","number","任","batch","忽略","文件夹","matplotlib","只能","详情请","samp","两","理论","目前","regularizer","25","存储","组合","选择","而","省略","step","single","然而","初始","图示","per","9546","之间","快速","│","抽取","graph","也","度量","各自","一定","该","次","classdef","交点","用单","通用","单单","9971","各个","这组","存取","静态","linear","metrics","dimn","initializers","先河","假设","尽管","一词","合理","hat","上述","6403","建议","愿","混洗","2795","层叠","yield","相反","讨论","网络结构","值","还会","keras","~","epochs","后端","解决","可用","接触","之旅","jacobian","analyzing","自带","索引","不","vdots","不断","知机","仅","tools","regressed","数组","一部分","导入","1s","即可","where","展示","外部","一部","最小化","40","元素","plot","添加","由此可知","mapsto","5884","原则","测度","每","如下","只","0049","偏向","随着","int32","参数","通过","成","begin","本章","dtype","写字","只是","p","取","节","mathrm","分离","含","网络","直接","binary","0.49","有","多个","vector","processing","6957","读者","cross","办法","init","]","采取","and","两侧","@","实验","非线性","#","需要","7","之","run","=","。","name","则","这些","模块化","实数","weights","过多","next","即","彼此","乘积","optimizer","思源","其中","加","pass","18","列表","52","均","测试","ij","add","件夹","alphabeta","500","1","d","linspace","原则上","意味着","dataset","足够","感知机","比照","weight","二个","module","编译","意味","get","查点","xlabel","实例","扩展","会","张量","改写","线性关系","阈值","活用","代入","aligned","error","设定值","构造方法","colorbar","bias","9667","24","53","main","知道","关键字","孱弱","5","8127","具有","神髓","运用","官方","非常简单","处理器","较长","终止","法","steppe","红线","evaluate","pred","级","次数","float32","8627","得到","def","38","发展","当","轮","是","一条","b","区别","好","有助于","稳定","代表性","显示","计算","19","分布","因为","应当","&&","mode","对象","标量","有限","推断出","show","认为","目标","日志","命名","sigmoid","以双","完成","相比","0059","评估","几种","指","t","对应","sample","时才","路径","备选","环节","介绍","比较","这种","6465","插值","所有","可微","方案",":","感知","更新","中将","遍历","饮水","上求","override","面向","losses","经常","内存","4492","并","必要","提供","print","equation","出来","图","20","效果","线性组合","器","boldsymbol","重","project","给","varepsilon","常数","尽如","equal","分成","21","维","accuracy","49","求导","i","+","legend","来说","额外","6407","构成","0.61","43","y","进度","使","binarycrossentropy","表示","function","s","之前","pyplot","完善","0.42","其","读取","0","不可","例如","简短","staticmethod","加上","写成","log","auto","看待","0.46","内容","检查","合适","看","块","噪声","来","注释","简单","下划","理想","饮水思源","最终","良好","结尾","事实","保存","临时","4671","tensors","创建","喜好","世代","5711","有助","并且","layer","已经","按照","scale","30","的","无关","可信度","行","变量","一","还","l","采样","以外","成器","”","起来","测试方法","完全相同","向量","人","compile","它们","让","批次","类","2","陆续","处理","以下","样本","9","测量","history","最","元组","自动","以","47","16","全部","或","tool","call","基本","返回值","br","比如","告诉","用","最后","数据","{","保留","9861","启发","config","正确","独立","就是","theta","这里","任何","└","fixed","属于","用法","单独","parameters","解","跨层","括号","作为","数","占位","stddev","理解","ldots","len","说","约束","group","（","希望","回调","缩进","callbacks","方式","三维","被","堆叠","才","输入","每个","多","端","它","一样","颜色","dense1","而是","下","内","ax2","扰动","加权","改进","val","类型","布尔值","中","3ms","连用","？","变为","|","形状","trainable","对比","sigma","均匀","形式","st","显式","且","0.0","最大","多数","两组","shape","layers","了","；","相同","weighted","固定","generator","10.0","反过","神经元","同时","截距","f","视为","预测值","13","允许","除以","决定","指标","工程","flag","测试函数","结果","前要","字母","设计","noise","损失","层","第一","继承","store","更好","整数","有效","35","0.44","tf","axis","速率","fill","training","plt","cdots","round","顺序","未","步","熵","「","模块","出原","性","不计","分入","须知","仍然","助于","所","interpolation","并非","写出","大量","私有","慢慢","}","忽略不计","训练","说明","首字母","本身","dim2","上手","train","4","虽然","以单","均匀分布","leqslant","initialize","上面","1624","空间","一维","组拆","记","不能","重新","检查点","去","残差","卷积","送入","构建","返回","比较简单","用户","人为","单调","馈入","进度条","从","非常","*","哪","区分","时间","dparser","matmul","驼峰","属性","却","tensorflow","两层","9986","单词","一回","target","较强","7519","跟","uniform","stystart","对角线","规范","比例","shuffle","求解","api","撰写","alphabetafunction","新","来自","相斥","总是","numpy","组","过程中将","std","51","极端","整理","对于","随机","label","exp","图像","斯蒂","beta","传入","仿射变换","set","逻辑","randomnormal","0.47","pairs","概念","一个点","代表","数据测试","像","适当","考虑","mathbf","fae6a9","验证","可信","性能","数目","iterator","反","准确度","尽如人意","12","c++","向用","准确","完全","semilogy","调整结构","编写","as","满足","有关","tensor","定义数据","指数","14","false","占用","操作","e","做到","实现","关系","真实","出","stroke","取值","但是","支持","可变","复杂","由此","对数","gca","结束","gcf","定义","以及","大多","construction","关注","产生","check","应该","符合","sim","这是","几乎","sequential","器中","无定","缩小","集类","dense","许多","48","各组","none","各","分析","哪怕","while","constraint","指定","0052","推导","j","大致","引出","samples","inches","目的","records","of","true","又","作用","放在","initialization","地","调整",";","参照","6789","h","0.58","反过来","场合","3663","1e","之后","进行","如果","是因为","遵守","单","功夫","代码","向","星号","0.6","给定","alpha","更","确保","但","凡是","零维","标准化","最小","random","不得","the","表述","文字","in","codes","类中","data","为","双","代替","后来","某些","既然","values","一组","式","extension","浮点","那么","平均","flatten","成文","6","概率论","ba9132","指全","退化","方法","风格","是否","主要","影响","network","请","不同","通道","想","直线","序列","astype","9981","小写","字典","走上","可能","载入","后面","把","生成","如何","__","0680","还有","3","下划线","labels","a","解析","tilde","拟合","数量","it","事实上","一个多","0.45","l1","结构"," ","0023145806044340134","估计","用于","声明","适合","36","正整数","自定义","limits","或者","只有","反过来说","实际","选项",")","除了","9985","相若","-","当然","8","问题","最大化","三个","正则","、","dp","getattribute","不再","按","python"],"title":"线性分类","title_tokens":["线性","分类"]},{"location":"book-1-x/chapter-1/linear-classification/#_1","text":"摘要 本节介绍如何使用顺序模型(sequential model)来编写一个线性分类器，使用sigmoid函数激活，并验证其效果。在本节我们将编写第一个Project，并介绍一些基本概念、和一个推荐的Tensorflow Project的编写格式。","text_tokens":["基本概念","第一个","(","并","验证","推荐","函数","的",")","效果","本节","，","model","其","sequential","顺序","一些","线性","来","分类","节","。","介绍","tensorflow","摘要","和","概念","编写","分类器","sigmoid","、","一个","project","激活"," ","将","我们","在","模型","如何","本","使用","基本","第一","格式"],"title":"线性分类","title_tokens":["线性","分类"]},{"location":"book-1-x/chapter-1/linear-classification/#_2","text":"","text_tokens":[],"title":"理论","title_tokens":["理论"]},{"location":"book-1-x/chapter-1/linear-classification/#_3","text":"考虑我们有如下的二分类数据集 (\\mathbf{x},~y_i) \\in \\mathbb{D}_i (\\mathbf{x},~y_i) \\in \\mathbb{D}_i ，并且有一个未知的常数向量 \\mathbf{a}_i \\mathbf{a}_i 和未知的常数标量 c_i c_i ，使得： \\begin{equation} y_i = \\left\\{ \\begin{aligned} 0, && \\mathbf{a}_i^T \\mathbf{x} + c_i \\leqslant 0, \\\\ 1, && \\mathbf{a}_i^T \\mathbf{x} + c_i > 0. \\end{aligned} \\right. \\end{equation} 其中， \\mathbf{a} \\mathbf{a} 可以看成是某超平面的（未标准化的）法向量，那么 \\mathbf{a}^T \\mathbf{x} + c = 0 \\mathbf{a}^T \\mathbf{x} + c = 0 是该超平面的截距式定义，亦即该平面与 x_i x_i 轴的交点可以显式表述为 x_i^{(0)} = - \\frac{c}{a_i} x_i^{(0)} = - \\frac{c}{a_i} 。由此可知，式 (1) (1) 显式定义了一个点在超平面的哪一侧。特别地，若 \\mathbf{x} \\mathbf{x} 是一个二维向量，则该超平面退化为一维平面；若 \\mathbf{x} \\mathbf{x} 是一个标量，则该超平面退化为一条直线。 若我们定义 (\\mathbf{x},~\\mathbf{y}) \\in \\mathbb{D} (\\mathbf{x},~\\mathbf{y}) \\in \\mathbb{D} ，有 \\begin{equation} \\mathbf{y} = \\begin{bmatrix} y_1 \\\\ y_2 \\\\ \\vdots \\\\ y_n \\end{bmatrix}, ~~ \\mathbf{A} = \\begin{bmatrix} \\mathbf{a}^T_1 \\\\ \\mathbf{a}^T_2 \\\\ \\vdots \\\\ \\mathbf{a}^T_n \\end{bmatrix}, ~~ \\mathbf{c} = \\begin{bmatrix} c_1 \\\\ c_2 \\\\ \\vdots \\\\ c_n \\end{bmatrix}. \\end{equation} 则我们可以认为 \\begin{align} \\mathbf{y} = \\left\\{ \\begin{bmatrix}\\hat{y}_1 > 0 & \\hat{y}_2 > 0 & \\cdots & \\hat{y}_n > 0\\end{bmatrix}^T, ~ \\left| ~ \\hat{\\mathbf{y}} = \\mathbf{A} \\mathbf{x} + \\mathbf{c} + \\boldsymbol{\\varepsilon} \\right. \\right\\}, \\end{align} 其中 \\boldsymbol{\\varepsilon} \\boldsymbol{\\varepsilon} 是一个定义噪声的向量。 我们可以把向量 \\mathbf{y} \\mathbf{y} 的元素看成是互不相关的多个超平面对向量 \\mathbf{x} \\mathbf{x} 各自独立的分类结果。即 y_i = \\{ \\hat{y}_i>0 ~ | ~ \\hat{y}_i = \\mathbf{a}_i^T \\mathbf{x} + c_i + \\varepsilon_i \\} y_i = \\{ \\hat{y}_i>0 ~ | ~ \\hat{y}_i = \\mathbf{a}_i^T \\mathbf{x} + c_i + \\varepsilon_i \\} 。由于每个超平面构成一个二分类，如果把每个二分类看作是向量是否属于这个类的测度，那么 \\mathbf{y} \\mathbf{y} 可以被看作是一个多分类的结果，尽管向量 \\mathbf{x} \\mathbf{x} 可能被同时分入多个类中。 假设我们的数据集 (\\mathbf{x},~\\mathbf{y}) \\in \\mathbb{D} (\\mathbf{x},~\\mathbf{y}) \\in \\mathbb{D} 符合 (3) (3) 定义的数据分布特征。我们的基本要求是，在我们不知道 \\mathbf{A},~\\mathbf{c} \\mathbf{A},~\\mathbf{c} 的情况下，使用大量 (\\mathbf{x}^{(k)},~\\mathbf{y}^{(k)}) \\in \\mathbb{D} (\\mathbf{x}^{(k)},~\\mathbf{y}^{(k)}) \\in \\mathbb{D} 样本训练一个线性分类器，使得当我们给定任意一个新样本 \\mathbf{x} \\mathbf{x} 的时候，分类器能推断出其对应的 \\mathbf{y} \\mathbf{y} 来（亦即是否属于该分类）。 须知 请注意我们在这里说到“线性分类器”，虽然使用“线性”一词，但准确来说，这是一个仿射变换。因为线性变换要求有齐次性，即 f(x) = \\alpha f(x) f(x) = \\alpha f(x) ，但仿射变换允许我们引入一个平移向量 \\mathbf{b} \\mathbf{b} 。当然，我们的求解的线性问题本身也是一个仿射变换。 在这个问题里，我们虽然不知道 \\mathbf{A},~\\mathbf{c} \\mathbf{A},~\\mathbf{c} ，但我们知道由 (3) (3) 确定的线性关系，因此，我们可以随机生成一组 \\mathbf{W},~\\mathbf{b} \\mathbf{W},~\\mathbf{b} ，构建线性模型： \\begin{align} \\tilde{\\mathbf{y}} = \\sigma ( \\mathbf{W} \\mathbf{x} + \\mathbf{b} ). \\end{align} 其中，可微函数 \\sigma \\sigma 是一个将实数空间 \\mathbb{R}^n \\mathbb{R}^n 映射到有限范围的实数空间 [0,~1]^n [0,~1]^n 内的函数。特别地， \\sigma(-\\infty)=0,~\\sigma(0)=0.5,~\\sigma(+\\infty)=1 \\sigma(-\\infty)=0,~\\sigma(0)=0.5,~\\sigma(+\\infty)=1 。因此，可以将 \\sigma \\sigma 看作是二分类布尔函数的插值函数。理论上，只要我们找到 \\mathbf{W}=\\mathbf{A} \\mathbf{W}=\\mathbf{A} ， \\mathbf{b}=\\mathbf{c} \\mathbf{b}=\\mathbf{c} ，则该线性分类器可以直接拟合出原分布来。","text_tokens":["in","|","其中","(","构建","frac","分布","类中","因为","为","&&","对","：","right","sigma","与","映射",".","infty","标量","哪","关系","end","引入","一组","变换","式","，","数据","其","推断出","有限","显式","0","{","线性","~","那么","认为","和","由此","了","1","0.5","；","到","d","范围","不","性关系","独立","将","退化","vdots","在","平面","定义","是否","使用","同时","c","截距","情况","t","这里","f","求解","符合","对应","线性变换","只要","上","请","新","这是","允许","一个二维","直线","要求","可知","某","^","噪声","属于","来","布尔","结果","left","元素","可能","线性关系","由此可知","特别","插值","可微","测度","把","互不","我们","二","生成","[","如下","这个","标准","轴","理论","3","随机","bmatrix","n","a","时候","aligned","并且","使得","begin","说","任意","tilde","equation","w","）","_","函数","的",",","拟合","（","齐次","仿射变换","k","找到","cdots","由于","平移","x","分类","知道","能","若","相关","未","boldsymbol","“","里","一个多","地","注意","直接","出原","也","性",">","一个点","分入","\\","varepsilon","各自","看作","常数"," ","有","超平面","多个","被","须知","该","&","推断","因此","”","法","考虑","]","向量","mathbf","每个","i","+","看成","二维","大量","仿射","}","来说","训练","可以","交点","2","集","如果","类",")","确定","本身","样本","虽然","-","当然","=","r","当","mathbb","。","给定","准确","问题","则","构成","数据分布","alpha","一侧","特征","下","实数","align","leqslant","但","内","分类器","标准化","一维","一个","空间","假设","是","一条","y","即","b","未知","模型","尽管","一词","hat","由","亦","基本","表述"],"title":"问题描述","title_tokens":["问题","描述"]},{"location":"book-1-x/chapter-1/linear-classification/#_4","text":"我们将 (4) (4) 定义的线性模型称为 单层感知机 (Single-layer perceptron) 模型。它包含一个权重矩阵 \\mathbf{W} \\mathbf{W} 和一个偏置矩阵 \\mathbf{b} \\mathbf{b} 。事实上，可以将 (4) (4) 改写成如下形式 \\begin{align} \\tilde{\\mathbf{y}} = \\sigma \\left( \\begin{bmatrix} \\mathbf{W} & \\mathbf{b} \\end{bmatrix} \\begin{bmatrix} \\mathbf{x} \\\\ 1 \\end{bmatrix} \\right). \\end{align} 可见偏置本身可以看成是输入向量多了一个常数元素的等价模型。 感知机是最早的神经网络形式，它非常孱弱，只能解线性问题，但却为神经网络后来的发展开了先河。在单层感知机里，我们视输入向量 \\mathbf{x} \\mathbf{x} 的每个元素为一个“神经元”，矩阵 \\mathbf{W} \\mathbf{W} 和偏置 \\mathbf{b} \\mathbf{b} 将我们的输入映射到输出层 \\mathbf{y} \\mathbf{y} ，输出层的每个元素也视为一个神经元。在这个过程中， W_{ij} W_{ij} 作为 i i 行 j j 列的元素，代表了连接两个神经元的权重。我们用红线代表正值，蓝线代表负值，感知机可以被图示为 线性感知机的输出也是输入的线性组合，但我们可以添加激活函数，即 \\sigma(\\cdot) \\sigma(\\cdot) 将其映射到非线性空间。这要求我们添加的激活函数是一个非线性函数。 事实上，将单层感知机层叠，前一层的输出作为后一层的输入，就构建出早期的神经网络。这种网络每一层都是全连接的（两个神经元之间总是有权重，尽管值可能为0），每一层都有激活函数。理论上，任意一个两层堆叠的感知机，只要神经元数目足够多，就可以拟合出任意一个非线性函数。然而，实际测试中，这一理论的效果并不尽如人意，因此又有陆续地改进，才有了后来的深度学习。饮水思源，鉴往知来，我们也将从这个简简单单的单层模型开始，走上学习“深度学习”之旅。","text_tokens":["(","过程","构建","一层","层叠","为","视","从","sigma","right","映射",".","非常","形式","测试","后来","这","end","全","出","用","，","其","ij","值","包含","0","{","线性","却","和","两层","之旅","了","1","到","激活","不","将","简简单单","连接","在","知机","定义","足够","感知机","神经元","最早","称为","cdot","单层","这一","只要","视为","开","上","perceptron","总是","输出","要求","列","简单","饮水思源","left","改写","元素","走上","这种","添加","可能","事实","解","每","感知","我们","作为","只能","如下","神经网络","饮水","层","这个","理论","等价","bmatrix","并","组合","成","begin","layer","任意","tilde","j","w","）","single","_","的","负值","函数","拟合","（","行","效果","神经","事实上","线性组合","然而","图示","x","孱弱","“","又","权重","之间","正值","里","地","网络","也","代表","\\","被","常数"," ","有","尽如","鉴往知来","堆叠","&","因此","”","都","才","人意","就","输入","红线","向量","mathbf","早期","每个","看成","多","i","它","学习","数目","非线性","}","后","实际","可以","尽如人意","陆续",")","本身","两个","前","深度","单单","4","-","偏置","发展","开始","=","。","问题","可见","矩阵","align","但","空间","一个","蓝线","先河","是","改进","y","b","即","模型","尽管","神经网","中","思源"],"title":"感知机","title_tokens":["感知","感知机","知机"]},{"location":"book-1-x/chapter-1/linear-classification/#sigmoid","text":"在上述介绍中，我们没有解决的两个问题是， 如何定义插值函数 \\sigma \\sigma ？ 如何找到合适的 \\mathbf{W},~\\mathbf{b} \\mathbf{W},~\\mathbf{b} ？ 我们首先讨论第一个问题。一般地，多分类问题中，如果各个分类彼此并非相斥，且不一定要将结果分入任一类的话，我们可以用 Sigmoid 函数来定义 \\sigma \\sigma ，亦即 \\begin{align} \\sigma(\\mathbf{x}) = \\frac{1}{ 1 + e^{-\\mathbf{x}}}. \\end{align} 它同时满足 \\sigma(-\\infty)=0,~\\sigma(0)=0.5,~\\sigma(+\\infty)=1 \\sigma(-\\infty)=0,~\\sigma(0)=0.5,~\\sigma(+\\infty)=1 ，且是一个单调函数。以下代码向我们展示了这种函数的特性： Python 1 2 3 4 5 6 7 8 9 10 11 12 import numpy as np import matplotlib.pyplot as plt def test_sigmoid (): x = np . linspace ( - 5 , 5 , 100 ) y = 1 / ( 1 + np . exp ( - x ) ) plt . plot ( x , y ) plt . xlabel ( 'x' ), plt . ylabel ( 'y' ) plt . gcf () . set_size_inches ( 5 , 5 ), plt . show () if __name__ == '__main__' : test_sigmoid () Output 使用sigmoid函数的一大好处是，它的导数求解非常简单，很适合用来做神经网络这样一个复杂模型的激活函数。注意虽然 \\sigma(\\mathbf{x}) \\sigma(\\mathbf{x}) 和 \\mathbf{x} \\mathbf{x} 都是向量，这意味着导数是Jacobian矩阵，但由于 \\sigma \\sigma 是一个对 \\mathbf{x} \\mathbf{x} 各元素独立的解析函数，这个Jacobian矩阵实际上是一个对角矩阵，对角线上第j个元素的值为 \\begin{align} \\left. \\frac{ \\partial \\sigma(x) }{ \\partial x } \\right|_{x=x_j} = \\left. - e^{-x} \\left( - \\frac{1}{\\left( 1+e^{-x} \\right)^2} \\right) \\right|_{x=x_j} = - \\sigma(x_j) ( 1 - \\sigma(x_j) ). \\end{align} 可见，该函数的导数和计算函数本身的复杂度相若，可以做到快速求导。","text_tokens":["好处","？","第","|","(","frac","为","单调","对","size","sigma","：","讨论","right","e",".","infty","非常","做到","pyplot","这","end","用","复杂度","，","值","且","对角","0","{","show","~","首先","和","解决","复杂","6","了","sigmoid","jacobian","1","0.5","'","激活","很","linspace","不","将","独立","意味着","在","gcf","定义","使用","对角线","同时","特性","求解","合适","if","上","没有","np","意味","相斥","xlabel","一大","这样","展示","numpy","^","来","简单","导数","介绍","ylabel","结果","任","left","元素","plot","这种","插值","各","要","的话",":","matplotlib","import","我们","神经网络","如何","__","个","这个","/","第一","用来","3","第一个","exp","解析","test","output","begin","j","w","函数","_","的",",","一般","inches","plt","神经","set","main","找到","由于","x","分类","5","快速","地","注意","网络","分入","\\","一定"," ","partial","一类","非常简单","该","都","适合","向量","mathbf","并非","求导","多","+","10","它","100","}","实际","可以","12","如果","2",")","本身","两个","7","各个","def","以下","4","代码","向","9","-","虽然","8","相若","=","。","问题","name","可见","矩阵","实际上","align","但","as","一个","11","是","满足","python","y","b","即","模型","做","神经网","上述","中","彼此","亦","计算"],"title":"Sigmoid函数","title_tokens":["sigmoid","函数"]},{"location":"book-1-x/chapter-1/linear-classification/#_5","text":"接下来，我们需要解决第二个问题，亦即找到 \\mathbf{W},~\\mathbf{b} \\mathbf{W},~\\mathbf{b} 。这一问题通常可以写成反问题的形式： \\begin{align} \\arg \\min_\\limits{\\mathbf{W},~\\mathbf{b}} \\sum_{k=1}^N \\mathcal{L} \\left( \\mathbf{y}^{(k)},~ \\sigma ( \\mathbf{W} \\mathbf{x}^{(k)} + \\mathbf{b} ) \\right). \\end{align} 最简单的情况下，我们可以把 损失函数(loss function) 定义为 \\begin{align} \\mathcal{L} \\left( \\mathbf{y},~ \\tilde{\\mathbf{y}} \\right) = \\lVert \\mathbf{y} - \\tilde{\\mathbf{y}} \\rVert_2^2. \\end{align} 我们称 (8) (8) 为 逻辑斯蒂回归(logistic regression) 。有趣的是，虽然这个术语叫“回归”，但它解的其实是个分类问题。但是，既然这是一个分类问题，我们可以不使用这个损失函数，而是从概率论的角度看待这个问题。由此，我们引出一个新的损失函数：“交叉熵”。","text_tokens":["(","为","从","：","sigma","right","function",".","形式","end","既然","，","{","~","称","但是","解决","由此","概率论","1","写成","rvert","不","下来","看待","定义","使用","情况","二个","这一","第二个","交叉","新","这是","回归","^","简单","arg","left","解","把","接下","我们","regression","个","损失","这个","n","begin","loss","斯蒂","tilde","w","引出","角度","_","接下来","的",",","函数","概率","k","找到","逻辑","术语","x","分类","“","熵","l","\\","通常"," ","”","mathbf","其实","+","有趣","它","limits","logistic","}","反","第二","min","叫","需要","可以","mathcal","2",")","sum","虽然","而是","-","8","=","最","。","问题","下","align","但","lvert","一个","是","y","即","b","亦"],"title":"求解问题","title_tokens":["问题","求解"]},{"location":"book-1-x/chapter-1/linear-classification/#_6","text":"我们视sigmoid函数输出的值为一个概率，表示分类器对预测结果的确信程度，记 \\mathbf{W},~\\mathbf{b} \\in \\boldsymbol{\\Theta} \\mathbf{W},~\\mathbf{b} \\in \\boldsymbol{\\Theta} ，则 \\begin{equation} \\begin{aligned} \\mathbf{p}(y_i=1|\\mathbf{x};~\\boldsymbol{\\Theta}) &= \\sigma(\\mathbf{x};~\\boldsymbol{\\Theta}), \\\\ \\mathbf{p}(y_i=0|\\mathbf{x};~\\boldsymbol{\\Theta}) &= 1 - \\sigma(\\mathbf{x};~\\boldsymbol{\\Theta}). \\end{aligned} \\end{equation} 注意这里的概率向量的含义是，其中第i个元素表明第i个超平面分类结果的 确信程度 。 然而，这个概率只是分类器对分类结果的确信程度，却并非是分类准确度的概率，实际上，分类 准确度 的概率，应当表述为 \\begin{equation} \\begin{aligned} \\mathbf{p}(\\mathbf{y}|\\mathbf{x};~\\boldsymbol{\\Theta}) &= \\mathbf{p}(y_i=1|\\mathbf{x};~\\boldsymbol{\\Theta})^{\\mathbf{y}} \\mathbf{p}(y_i=0|\\mathbf{x};~\\boldsymbol{\\Theta})^{1-\\mathbf{y}}\\\\ &= \\sigma(\\mathbf{x};~\\boldsymbol{\\Theta})^{\\mathbf{y}} \\left(1 - \\sigma(\\mathbf{x};~\\boldsymbol{\\Theta}) \\right)^{1-\\mathbf{y}}. \\end{aligned} \\end{equation} 注意 这里 \\mathbf{x}^{\\mathbf{y}} \\mathbf{x}^{\\mathbf{y}} 表示的是对每个元素一一求取指数，即函数第i个元素的返回值应当为 {x_i}^{y_i} {x_i}^{y_i} 。 我们使用真实值 \\mathbf{y} \\mathbf{y} 作为指数给概率向量加权。当 \\mathbf{y}=1 \\mathbf{y}=1 时，乘积项的第二个因子消去，该函数退化为以预测值为1的可信度 \\mathbf{p}(y_i=1|\\mathbf{x};~\\boldsymbol{\\Theta}) \\mathbf{p}(y_i=1|\\mathbf{x};~\\boldsymbol{\\Theta}) ；反之则第一个因子消去，退化为以预测值为0的可信度 \\mathbf{p}(y_i=0|\\mathbf{x};~\\boldsymbol{\\Theta}) \\mathbf{p}(y_i=0|\\mathbf{x};~\\boldsymbol{\\Theta}) 。这就是最大似然估计方法。至此，我们可以写出似然估计函数 \\begin{align} L(\\boldsymbol{\\Theta}) = \\mathbf{p}(\\mathbf{y}^{(k)}|\\mathbf{x}^{(k)};~\\boldsymbol{\\Theta}). \\end{align} 对似然估计函数取对数，则有 \\begin{equation} \\begin{aligned} l(\\boldsymbol{\\Theta}) &= \\sum_{k=1}^N \\log \\left( \\mathbf{p}(\\mathbf{y}^{(k)}|\\mathbf{x}^{(k)};~\\boldsymbol{\\Theta}) \\right) \\\\ &= \\sum_{k=1}^N \\mathbf{y}^{(k)} \\cdot \\log\\left(\\sigma(\\mathbf{x}^{(k)};~\\boldsymbol{\\Theta})\\right) + \\left(1 - \\mathbf{y}^{(k)} \\right) \\cdot \\log\\left(1 - \\sigma(\\mathbf{x}^{(k)};~\\boldsymbol{\\Theta})\\right). \\end{aligned} \\end{equation} 我们最终的目的是要最大化似然函数，亦即 \\mathbf{W},~\\mathbf{b} = \\arg\\max\\limits_{\\boldsymbol{\\Theta}} l(\\boldsymbol{\\Theta}) \\mathbf{W},~\\mathbf{b} = \\arg\\max\\limits_{\\boldsymbol{\\Theta}} l(\\boldsymbol{\\Theta}) ，这等价于最小化 -l(\\boldsymbol{\\Theta}) -l(\\boldsymbol{\\Theta}) 。对比 (8) (8) 和 (9) (9) ，于是我们可以定义交叉熵为 \\begin{align} \\mathcal{L} \\left( \\mathbf{y},~ \\tilde{\\mathbf{y}} \\right) = - \\mathrm{mean}\\left[ \\mathbf{y} \\cdot \\log\\left( \\tilde{\\mathbf{y}} \\right) + \\left(1 - \\mathbf{y} \\right) \\cdot \\log\\left(1 - \\tilde{\\mathbf{y}} \\right) \\right]. \\end{align} 注意这里我们使用 \\mathrm{mean}\\left[ \\cdot \\right] \\mathrm{mean}\\left[ \\cdot \\right] 表示求取一个向量所有元素的平均值。实际上，Tensorflow允许我们定义损失函数的输出为一个和输出向量维度相同的向量，Tensorflow自带的交叉熵也是这样定义的。实际应用时，Tensorflow会自动在向量维度上求均值，并压缩成上述 (14) (14) 的形式。 若我们记 \\tilde{\\mathbf{y}} = \\sigma(\\tilde{\\mathbf{x}}) \\tilde{\\mathbf{y}} = \\sigma(\\tilde{\\mathbf{x}}) ，代入sigmoid函数，为了确保该损失函数的稳定性，我们可以将 (14) (14) 整理为 \\begin{align} \\mathcal{L} \\left( \\mathbf{y},~ \\tilde{\\mathbf{x}} \\right) = \\mathrm{mean}\\left[ \\max(\\tilde{\\mathbf{x}}, \\mathbf{0}) - \\tilde{\\mathbf{x}} \\cdot \\mathbf{y} + \\log\\left(1 + e^{-|\\tilde{\\mathbf{x}}|} \\right) \\right]. \\end{align} 提示 这里交叉熵整理的推导过程参见 Tensorflow-API官方文档 。 实际情况下，我们使用 (15) (15) 来求取sigmoid函数激活下的交叉熵。","text_tokens":["指数","第","in","|","其中","(","于是","14","返回","过程","返回值","应当","对比","为","对","视","表示","sigma","程度","right",".","压缩成","e","形式","真实","这","end","至此","参见","，","项","消","值","0","{","~","最大","却","tensorflow","和","平均","对数","sigmoid","因子","1","稳定性","自带","；","提示","激活","压缩","log","相同","将","就是","退化","在","theta","平面","方法","定义","含义","使用","求取","cdot","情况","这里","二个","api","第二个","预测值","文档","大化","交叉","时","似然","允许","输出","这样","^","会","来","最小化","最终","arg","结果","left","一一","元素","所有","要","我们","整理","作为","[","表明","个","上求","损失","这个","第一","等价","第一个","应用","n","并","代入","aligned","begin","推导","tilde","equation","w","函数","_","的","概率",",","可信度","目的","k","只是","然而","p","取","15","x","分类","若","信度","boldsymbol","预测","mathrm","熵","l","注意","也","给","\\",";","超平面"," ","有","官方","于","该","&","估计","缩成","]","向量","mathbf","每个","为了","并非","i","+","可信","写出","反之","limits","mean","}","第二","实际","准确度","可以","mathcal",")","均值","平均值","sum","9","-","8","定性","=","当","。","准确","则","自动","确保","以","实际上","最大化","align","下","分类器","确信","一个","记","加权","最小","维度","是","y","b","即","去","max","上述","稳定","亦","乘积","表述"],"title":"交叉熵","title_tokens":["熵","交叉"]},{"location":"book-1-x/chapter-1/linear-classification/#_7","text":"接下来，我们将开始实战上手，编写我们的第一个Project。虽然一个Project的格式并无定法，每个人按照自己的喜好会选择不同的风格，但一个从无受过训练的人，往往写出的Project几乎完全不具有可读性。实际上，学习任何语言， 变量命名规范 、 缩进规范 以及 模块化 、 面向对象 等都被认为是编写一个具有可读性的代码所不得不知的概念。本教程所推荐的代码格式，均具有统一的风格，读者在了解每个Project和其对应的教程时，会慢慢熟悉这种风格的特点。愿读者能从这样的风格中得到启发，得到 代码可读性 的神髓。","text_tokens":["愿","手","自己","从","均","对象","可读","实战","，","其","往往","认为","和","命名","特点","无","启发","不","将","教程","在","下来","本","风格","以及","规范","任何","对应","面向对象","上","时","不同","这样","几乎","会","无定","语言","这种","接下","我们","面向","第一","第一个","喜好","并","选择","了解","按照","接下来","的","变量","缩进","熟悉","定法","能","具有","概念","模块","project","神髓","被"," ","不知","都","统一","读者","可读性","所","等","人","每个","推荐","写出","学习","慢慢","训练","实际","得到","无定法","代码","虽然","开始","。","受过","完全","模块化","实际上","但","编写","、","一个","是","不得","中","格式"],"title":"解线性多分类问题","title_tokens":["问题","多","解","线性","分类"]},{"location":"book-1-x/chapter-1/linear-classification/#_8","text":"建立一个具有较强可读性的Tensorflow工程需要我们活用python的模块化设计。我们通常推荐以下的结构 . ├─ data/ # where we store our data │ └─ ... ├─ tools.py # codes for post-processing and analyzing records. ├─ extension.py # codes for extending the tensorflow model. ├─ dparser.py # data parser └─ main.py # main module where we define our tensorflow model. 除了保存数据的文件夹，我们应当有三个子模块。其中 tool : 用来处理、分析生成的数据，通常与Tensorflow无关； extension : 用来扩展tensorflow，例如在这里自定义网络层和操作符； dparser : 数据处理器，用来读取并预处理送入网络的数据； main : 主模块，只定义跟Tensorflow模型有关的内容，需要引用 extension 和 dparser 。 视情况可以灵活调整结构，但建议将定义Tensorflow模型的代码单独放在主模块里，和其他外围代码分离。 撰写各个模块时，建议使用类封装各组功能相同的函数。具有良好使用习惯的coder应当注意给各个面向用户的类、函数撰写（哪怕简短的）说明文字，在一些较长的函数、方法的定义中，适当注释各部分的功能，以便读者能正确理解代码意义。 另外，在对象命名上，python有如下必须遵守或不成文的规定，和C/C++用户熟悉的蛇形命名法不同，它大致包括 类与函数多用驼峰命名法，变量可以采用驼峰或蛇形命名法。 驼峰命名法指的是用大小写区分每个单词块，例如 alphaBetaFunction () ； 蛇形命名法指的是用下划线区分每个单词块，例如 alpha_beta_function = 10 ； 宏变量使用全字大写+蛇形命名法 函数/方法，还有模块均是首字母小写，但类的首字母大写。 用单下划线 _ 表示临时存储器，或省略参数，例如一个函数 func () 有两个返回值时，可以用 _ , b = func () 表示我们只需要第二个返回值；单下划线还可以与星号连用省略多个返回值； 以单下划线开头的方法，表示模块级的私有方法，在模块以外使用 import 导入类时，不会导入这些方法，例如 def _alphaBeta ( self ): ； 以单下划线结尾的对象，用来和python的关键字区分，例如 func ( x , class_ ) ; 以双下划线开头的方法，如果不以双下划线结尾，则表示类级的私有方法，只有类内部的方法能调用这些方法，在类外部、包括继承的子类里都原则上不能调用（但其实也有办法调用），例如 def _alphaBeta ( self ): ； 以双下划线同时开头和结尾的方法，一般是用来 重写 (override) 特殊功能，例如 def __getattribute__ (): 将重写获得类属性的方法。","text_tokens":["文字","parser","codes","建议","其中","送入","(","返回","法指","用户","大小","操作","data","应当","主","临时","返回值","─","视","表示","双","function","与","均",".","开头","extending","class","对象","内部","区分","可读","用","大写","，","数据","extension","dparser","读取","func","驼峰","件夹","属性","tensorflow","和","其他","部分","alphabeta","命名","外围","成文","单词","define","例如","analyzing","简短","以便","；","重写","较强","相同","另外","以双","正确","将","跟","原则上","在","方法","定义","使用","tools","内容","同时","不会","c","情况","面向用户","这里","二个","撰写","self","第二个","上","module","多用","alphabetafunction","导入","时","不同","块","└","where","扩展","外部","...","预处理","注释","工程","下划","单独","良好","小写","for","正确理解","结尾","各组","各","保存","原则","字母","包括",":","文件夹","自定","必须","封装","分析","我们","哪怕","生成","设计","划线","如下","import","网络层","只","__","灵活","蛇形","引用","面向","override","/","还有","用来","继承","理解","全字","参数","活用","store","下划线","存储","并","首字","获得","类级","大小写","省略","beta","）","操作符","大致","函数","_","的","子","无关",",","（","一般","规定","不成","model","main","文件","变量","采用","we","熟悉","功能","一些","records","能","意义","x","关键字","不成文","还","具有","不以","分离","放在","但类","里","模块","子类","│","注意","网络","建立","类时","也","给","调整","结构","our",";","通常","以外"," ","有","多个","处理器","较长","├","processing","都","读者","可读性","适当","法","办法","其实","每个","and","自定义","10","+","关键","推荐","它","级","私有","只有","#","第二","需要","可以","类","用单","说明","如果",")","首字母","除了","处理","两个","遵守","各个","单","c++","以下","def","代码","post","-","向用","星号","理器","=","。","以单","coder","则","alpha","这些","模块化","特殊","三个","调整结构","但","、","一个","py","习惯","不能","getattribute","python","是","或","存储器","the","b","有关","模型","tool","中","调用","宏","连用"],"title":"代码规范","title_tokens":["代码","规范"]},{"location":"book-1-x/chapter-1/linear-classification/#tensorflow","text":"在Tensorflow中，我们把变量都称为“ 张量 (Tensor) ”。这是因为我们有零维的标量，一维的向量，二维的矩阵，更高维的我们都称为张量。作为一个更大的概念，张量当然也可以用来包括标量、向量和矩阵了。在Tensorflow中，有的张量是 可以训练 (trainable) 的，有的则不是。比如一个张量的形状（指各维大小），当然可以是一个 < tf . Tensor 'Shape:0' shape = ( 1 ,) dtype = int32 > 类型的张量，但它不是变量，当然就不可训练。我们也可以人为控制某些张量可以训练或不可以训练，但本节、乃至本章所介绍的凡是我们接触到的张量，都是可以训练的。 特别地，对于神经网络而言，在网络内计算（或者说流动、传播）的一个n维数据，通常按照以下形式组织： tensor [ batch , dim1 , dim2 , ... , dimn , channel ] 其中，第一个维度 batch 一定存在，它表示的是单个batch中的某一个样本。如果一个batch只有一个样本，那么 batch 只能取0。 从 dim1 到 dimn 指的是实际的n维数据的各个维度； channel 指的是数据的通道，例如，一个二维RGB图像，每种颜色代表一个通道，因此有三个通道。 channel 通常用在卷积网络里，我们经常需要在深度卷积网络里不断增大通道数的同时，缩小数据尺寸。 在某些特殊情况下， channel 维度可以不存在，例如我们使用的是全连接层而不是卷积网络， tf.keras.layer.Flatten 可以用来将一个有通道的张量压缩成一个没有通道的一维向量（但是注意 batch 维度仍然存在，不会被压缩）。 因此，我们知道一个n维的数据，在神经网络中通常被描述为一个n+2维的矩阵，而一个一维向量，在卷积网络里是三维的： vector [ batch , length , channel ] 但是在全连接网络里，是二维的： vector [ batch , channel ] 在本节，乃至本章里，我们还不讨论卷积网络，因此我们都是使用二维张量（一维向量组）作为我们的数据。","text_tokens":["形状","其中","(","trainable","大小","因为","人为","为","不是","从","：","表示","比如","讨论",".","压缩成","形式","标量","全","这","某些","用","存在","length","，","数据","0","keras","那么","不可","tensorflow","但是","和","channel","shape","接触","flatten","了","例如","1","'","到","；","压缩","不","将","连接","在","不断","使用","同时","不会","称为","情况","指","增大","没有","高维","通道","一个二维","单个","尺寸","...","组","某","张量","缩小","介绍","更大","batch","特别","包括",":","把","特殊","我们","作为","[","只能","数","神经网络","对于","层","第一","用来","经常","int32","第一个","n","图像","每种","而","传播","描述","layer","dim1","本章","控制","按照","）","tf","dtype","的",",","（","rgb","本节","神经","变量","取","知道","“","还","概念","里","地","注意","网络","也","组织",">","代表","三维","或者说","一定","通常","被"," ","有","vector","仍然","因此","”","都","而言","维","所","缩成","就","]","向量","+","二维","它","乃至","或者","只有","训练","可以","实际","如果","颜色","需要","2",")","是因为","dim2","各个","深度","以下","样本","当然","=","。","流动","则","更","dimn","矩阵","下","但","凡是","内","三个","零维","、","一维","一个","指各维","维度","是","或","类型","tensor","神经网","中","卷积","<","计算"],"title":"Tensorflow的数据概念","title_tokens":["数据","的","tensorflow","概念"]},{"location":"book-1-x/chapter-1/linear-classification/#_9","text":"在本项目里，我们不需要扩展Tensorflow。但是，我们需要以随机生成数据代替数据集。因此，首先，通过以下代码定义数据生成器 dparser.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class TestDataSet : ''' A generator of the data set for testing the linear model. ''' def __init__ ( self , scale_x , A , c ): ''' Initialize the data generator. scale_x: the scale of input vector. A, c: the linear transformation. ''' self . s_x = 2 * scale_x self . A = A self . c = c self . len_x = A . shape [ 0 ] self . config () def config ( self , train = True , batch = 100 , noise = 0.1 ): ''' Configuration train: a flag for controlling the iterator mode. batch: the number of samples in a batch noise: std. of the error added to the y. ''' self . train = bool ( train ) self . batch = batch self . noise = noise def next_train ( self ): ''' Get the next train batch: (x, y) ''' x = self . s_x * ( np . random . random ([ self . batch , self . len_x ]) - 0.5 ) y = np . matmul ( x , self . A ) + self . c if self . noise > 1e-3 : y = y + np . random . normal ( 0 , self . noise , size = y . shape ) y = np . greater ( y , 0.0 ) . astype ( np . float32 ) return x , y def next_test ( self ): ''' Get the next test batch x. ''' return self . s_x * ( np . random . random ([ self . batch , self . len_x ]) - 0.5 ) def __iter__ ( self ): while True : samp = self . __next__ () yield samp def __next__ ( self ): if self . train : return self . next_train () else : return self . next_test () 该生成器输入一组 \\mathbf{A},~\\mathbf{c} \\mathbf{A},~\\mathbf{c} ，以及相关配置，之后就可以通过 迭代器 (iterator) 或 方法 (method) 随机生成数据。这种数据集写法我们在后面还会用到， model . fit 允许我们不是馈入样本（或样本批次），而是馈入一个 生成器(generator) 。因此我们重写了 __iter__ 方法，并使其通过 yield 返回一个生成器。这样我们定义的数据集类就可以被Keras的训练函数 model . fit 使用。接下来，调用如下测试代码： dparser.py 1 2 3 4 5 6 7 8 9 10 def test_dataset (): A = np . random . normal ( 0 , 10 , [ 10 , 6 ]) c = np . random . uniform ( 1 , 3 , [ 1 , 6 ]) dataSet = TestDataSet ( 10 , A , c ) dIter = iter ( dataSet ) for i in range ( 10 ): x , y = next ( dIter ) print ( np . sum ( y , axis = 0 ) / 100 ) test_dataset () Output [ 0.47 0.57 0.58 0.56 0.5 0.38 ] [ 0.6 0.61 0.47 0.48 0.38 0.52 ] [ 0.5 0.61 0.49 0.42 0.45 0.53 ] [ 0.59 0.52 0.44 0.44 0.49 0.51 ] [ 0.54 0.59 0.48 0.5 0.51 0.47 ] [ 0.49 0.57 0.56 0.49 0.53 0.4 ] [ 0.5 0.61 0.51 0.54 0.51 0.52 ] [ 0.5 0.51 0.61 0.5 0.44 0.5 ] [ 0.44 0.46 0.53 0.45 0.56 0.52 ] [ 0.52 0.46 0.51 0.52 0.49 0.44 ] 我们随机生成了 \\mathbf{x} \\mapsto \\mathbf{y}:~\\mathbb{R}^{10} \\mapsto \\mathbb{R}^6 \\mathbf{x} \\mapsto \\mathbf{y}:~\\mathbb{R}^{10} \\mapsto \\mathbb{R}^6 的数据，每组数据100个，并且测试了10组。输出结果是各组测试中， \\mathbf{y} \\mathbf{y} 在对应维度上分类为1的概率估计。结果基本都在0.5左右，说明我们的这种数据生成模式产生的点能均匀分布在各个超平面两侧，适合进行后续测试。","text_tokens":["controlling","42","in","29","14","17","(","method","18","使","返回","data","normal","yield","52","0.56","不是","馈入","configuration","mode","27","size","28","：",".","22","class","s","*","均匀","代替","测试","一组","，","数据","其","0.42","后续","dparser","0","matmul","testdataset","input","0.0","{","~","还会","首先","keras","tensorflow","但是","生成器","写法","testing","shape","return","6","了","0.51","1","0.5","44","'","config","重写","不","generator","to","模式","在","33","bool","本","方法","定义","以及","下来","使用","dataset","uniform","0.46","平面","产生","c","点","diter","34","对应","self","if","26","左右","上","32","np","13","0.52","get","允许","输出","这样","扩展","组","^","flag","astype","集类","40","else","number","batch","48","std","结果","for","这种","51","iter","mapsto","迭代","各组","0.4","46","配置",":","后面","接下","我们","0.48","生成","[","如下","samp","__","noise","while","0.59","个","/","3","随机","25","greater","a","并","test","通过","len","print","output","error","35","0.53","并且","0.44","scale","30","）","_","samples","的",",","函数","接下来","20","（","axis","0.38","每组","概率","24","53","39","set","model","15","of","true","x","分类","能","器","5","相关","0.47","0.57","为","里","0.45","added",">","\\","项目","45","transformation","被"," ","0.49","vector","超平面","成器","0.58","该","21","因此","54","31","估计","都","适合","41","init","输入","]","49","1e","36","就","mathbf","测试代码","用到","两侧","10","+","i","23","100","iterator","}","0.1","之后","批次","进行","float32","需要","12","2","集","37","可以",")","训练","说明","7","def","各个","以下","38","4","代码","9","train","-","样本","8","而是","0.6","=","range","r","。","linear","0.54","mathbb","以","0.61","分布","initialize","47","sum","均匀分布","16","py","一个","11","43","next","random","是","维度","y","或","the","50","中","基本","调用","定义数据","fit","19"],"title":"数据生成","title_tokens":["数据","生成"]},{"location":"book-1-x/chapter-1/linear-classification/#_10","text":"顺序 (sequential) 模型是一个单输入单输出模型，网络结构较为简单，也不存在跨层短接（残差连接）。在大多数情况下，已经上手的Tensorflow用户不使用这个模型，故而作为我们入门的第一个project，我们姑且用之，但我们将不再使用顺序模型来实现后续的project。一个顺序模型大致可以描述为下图的模式： graph LR st(输<br/>入) --> l1[层<br/>1] l1 --> l2[层<br/>2] l2 --> l3[层<br/>3] l3 --> ldots[层<br/>...] ldots --> ed(输<br/>出) classDef styStart fill:#FAE6A9,stroke:#BA9132; class st,ed styStart 由于我们完成的是一个线性分类器，故而我们使用单层的序列模型即可。 接下来，我们来定义一个类， class LinClsHandle : 。定义一个类的时候，我们通常需要定义的内容包括 在初始化方法 __init__ 里定义传入网络的固定参数，例如学习速率，存取路径等； 在方法 construct 里定义网络的构造和使用的优化器； 在方法 train 里定义训练网络的过程，主要需要调用 model . fit 。如果我们在数据集的定义非常完善，则这一环节不需要花费太多的功夫； 在方法 test 里定义测试网络的过程，主要需要调用 model . evaluate 。如果有必要，可以通过 model . predict 返回测试结果。","text_tokens":["(","过程","返回","用户","为","br","：",".","class","非常","网络结构","实现","入","测试","这","st","出","用","存在","初始化","，","数据","完善","后续","stroke","线性","较为","多数","大多数","tensorflow","和","入门","例如","1","ba9132","；","太多","固定","不","将","完成","较为简单","连接","花费","模式","在","下来","方法","定义","使用","stystart","大多","内容","情况","单层","主要","predict","ed","姑且","即可","输出","路径","序列","sequential","...","construct","环节","来","简单","结果","lr","跨层","包括",":","构造","接下","我们","作为","[","__","层","这个","/","第一","3","参数","ldots","第一个","时候","必要","test","通过","描述","已经","）","大致","下图","接下来","的",",","速率","（","fill","传入","linclshandle","l3","model","一","顺序","由于","初始","分类","器","故而","里","网络","graph","也","project","l1",">","结构",";","通常"," ","有","优化","init","输入","]","等","evaluate","fae6a9","学习","classdef","#","训练","可以","类","2","需要","如果","集",")","上手","单","输","train","功夫","之","-","存取","短接","。","则","l2","下","但","分类器","一个","不再","是","模型","残差","调用","<","fit"],"title":"定义线性顺序模型","title_tokens":["定义","线性","模型","顺序"]},{"location":"book-1-x/chapter-1/linear-classification/#_11","text":"首先，定义初始化方法： lin-cls.py: class LinClsHandle 1 2 3 4 5 6 7 8 9 10 def __init__ ( self , learning_rate = 0.01 , epoch = 10 , steppe = 30 ): ''' Initialization and pass fixed parameters. learning_rate: the learning rate for optimizer. epoch: training epochs. steppe: steps per epoch ''' self . lr = learning_rate self . epoch = epoch self . steppe = steppe 由于目前我们的project还非常简单，这里只需要有学习速率( learning_rate )，轮次数( epoch )和每轮迭代次数( steppe )即可。","text_tokens":["lin","(","pass","：",".","class","非常","初始化","，","epoch","epochs","首先","和","0.01","6","1","'","方法","定义","这里","self","即可","cls","fixed","steps","简单","parameters","for","迭代","lr",":","我们","rate","__","只","目前","3","30","_","的",",","速率","training","linclshandle","初始","由于","5","per","还","initialization","learning","project"," ","有","非常简单","init","steppe","and","10","学习","次数","需要","2",")","7","def","4","9","-","8","=","。","py","轮","每轮","the","optimizer"],"title":"初始化方法","title_tokens":["初始","方法","初始化"]},{"location":"book-1-x/chapter-1/linear-classification/#_12","text":"接下来定义网络构造 lin-cls.py: class LinClsHandle 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def construct ( self ): ''' Construct a linear model and set the optimizer as Adam ''' # Construction self . model = tf . keras . Sequential () self . dense1 = tf . keras . layers . Dense ( LABEL_SHAPE , use_bias = True , input_shape = ( INPUT_SHAPE ,), kernel_initializer = tf . keras . initializers . RandomNormal ( 0.0 , stddev = 10.0 ), bias_initializer = tf . keras . initializers . Constant ( 2 ), activation = tf . nn . sigmoid ) self . model . add ( self . dense1 ) # Set optimizer self . model . compile ( optimizer = tf . train . AdamOptimizer ( self . lr ), loss = tf . keras . losses . BinaryCrossentropy (), metrics = [ self . accuracy , tf . keras . metrics . BinaryAccuracy ()] ) @staticmethod def accuracy ( y_true , y_pred ): return tf . keras . backend . mean ( tf . keras . backend . equal ( y_true , tf . keras . backend . round ( y_pred ))) 须知 这里 LABEL_SHAPE 和 INPUT_SHAPE 为两个宏变量，分别为输出和输入的向量维度。 我们使用 Dense 定义全连接层，它的用法请参照 这里 。由于我们已经知道 \\mathbf{A} \\mathbf{A} 和 \\mathbf{c} \\mathbf{c} 可能的取值范围，这里我们重定义了 \\mathbf{W} \\mathbf{W} 和 \\mathbf{b} \\mathbf{b} 的初始化方式。 信息: Dense API tf . keras . layers . Dense ( shape , ** kwargs ) 指全连接层，其输入一组已知形状的向量，输出一组形状为 shape 的向量。可用的API如下： shape : 正整数，输出空间维度。 activation : 激活函数。 若不指定，则不使用激活函数 (即，线性激活: a(\\mathbf{y}) = \\mathbf{y} a(\\mathbf{y}) = \\mathbf{y} )。该函数可以定义为任何元素级操作的Tensorflow函数。 use_bias : 布尔值，该层是否使用偏置向量。 True 则网络定义为 \\mathbf{y} = \\mathbf{W}\\mathbf{x} + \\mathbf{b} \\mathbf{y} = \\mathbf{W}\\mathbf{x} + \\mathbf{b} ， False 则定义为 \\mathbf{y} = \\mathbf{W}\\mathbf{x} \\mathbf{y} = \\mathbf{W}\\mathbf{x} 。 kernel_initializer : kernel 权值矩阵的初始化器，自定义的初始化器需要使用Keras后端API编写。 bias_initializer : 偏置向量的初始化器，同上。 kernel_regularizer : 运用到 kernel 权值矩阵的正则化函数，自定义的正则化函数需要使用Keras后端API编写。 bias_regularizer : 运用到偏置向的的正则化函数，同上。 activity_regularizer : 运用到层的输出的正则化函数，同上。 kernel_constraint : 运用到 kernel 权值矩阵的约束函数，只能使用Keras备选的几种方案，不能自定义。 bias_constraint : 运用到偏置向量的约束函数，同上。 信息: model.compile API model . compile ( optimizer , ** kwargs ) 在这里指的是顺序模型的编译函数，其可用的API如下： optimizer : 优化器，可以使用Tensorflow内置的优化器。 loss : 损失函数，也是目标函数。顺序模型只有一个输出，因此只能传入一个损失函数。可以使用形式为 func ( y_true , y_pred ) 的Tensorflow函数。 metrics : 测度函数，一般是一组函数，如果是一个函数则定义为 [ func ] 即可。自定义的测度函数目前还需要使用Keras后端API编写。 loss_weights : 损失的权重，顺序模型只有一个损失函数，因此只有一个权重，但要使用一维列表 [ value ] 定义。可以使用张量来控制可变权重。 sample_weight_mode : 按时间步采样权重，默认不提供。相比上面的损失权重，该选项会随着迭代次数使用不同的权重，因此输入的是二维列表。 weighted_metrics : 测度的权重，和损失权重类似，用来加给不同的测度函数。由于我们可以使用不只一个测度函数，这里的权重是个一维列表。 target_tensors : 默认情况下，Keras 将为模型的目标创建一个占位符，在训练过程中将使用目标数据。相反，如果你想使用自己的目标张量（反过来说，Keras在训练期间不会载入这些目标张量的外部 Numpy数据），您可以通过 target_tensors 参数指定它们。对于单输出的顺序模型，它应该是单个张量。 ** kwargs : 其他参量，会传递给 tf . Session . run 。 另外，注意我们这里构造网络的时候有如下技巧： Tensorflow在导入Keras模式以后，已经不再使用 (15) (15) 的形式定义 sigmoid交叉熵 ，而是采取更通用的定义 (14) (14) ； 我们使用Tensorflow重新封装过的类， 二分类交叉熵 ( BinaryCrossentropy ) 来作为Keras模型的损失函数 self.loss ，该函数与 多分类交叉熵 ( CategoricalCrossentropy ) 不同，乃是对两组对比张量的每个元素分别计算交叉熵，再求取均值，正符合本应用的需求； 我们通过静态方法，调用Keras的后端API，自己定义了预测准确度的测度函数 self.accuracy ，同时也使用另一个来自Tensorflow封装好的测度类 二分类准确度 ( BinaryAccuracy ) ，这是为了比照两个准确度的区别，以便我们更好理解该测度类； 我们将网络层的关键字 self.dense1 保留在了实例中，这是为了确保接下来我们能通过实例抽取该层的参数。 需要注意的是，由于 二分类交叉熵 ， 二分类准确度 和 多分类交叉熵 等都是类（从它们的定义都是大写字母开头也可以看出来），因此我们需要在使用的时候后面加上括号以实例化；由于这些类都定义了 __call__ 方法，我们可以像使用函数一样使用它们的实例。","text_tokens":["符","形状","加","17","18","列表","对比","class","形式","初始化","0.0","线性","add","两组","和","其他","shape","layers","了","1","'","；","weighted","范围","10.0","连接","下来","本","反过","使用","比照","weight","同时","不会","c","情况","initializer","交叉","编译","13","实例","construct","会","张量","权值","迭代","字母","构造","封装","损失","层","更好","时候","整数","w","tf","_","接下来","参量","linclshandle","bias","model","round","顺序","分类","知道","关键字","若","5","权重","步","预测","熵","\\","运用","adamoptimizer","须知","该层","等","10","pred","级","}","次数","训练","可以","以后","已知","def","train","4","上面","过来","空间","一维","不能","是","重新","b","区别","好","技巧","宏","计算","19","(","正","mode","从","kwargs",".","*","再","大写","，","时间","input","func","tensorflow","adam","目标","return","use","sigmoid","以便","激活","target","化","另外","相比","将","几种","指","api","self","sample","来自","单个","备选","numpy","过程中将","value","方案","要",":","自定","接下","中将","二","[","分别","对于","losses","label","应用","提供","另","出来","categoricalcrossentropy","函数","一般","20","传入","set","由于","randomnormal","器","重","注意","给","equal","像","21","因此","类似","都","accuracy","优化","mathbf","关键","+","二维","binaryaccuracy","来说","后","需求","准确度","12","均值","偏置","准确","矩阵","as","编写","一个","11","您","大写字母","y","调用","lin","过程","14","false","操作","binarycrossentropy","对","自己","：","与","开头","22","全","其","取值","默认","可变","staticmethod","加上","内置","nn","在","定义","construction","应该","符合","上","看","session","这是","cls","sequential","来","activity","constant","dense","你","lr","只能","constraint","tensors","目前","指定","regularizer","期间","创建","loss","已经","）","的",",","变量","15","初始","true","x","还","抽取","也","参照","采样","该","backend","反过来","过","向量","compile","它们","为了","mean","类","2","如果","通用","单","9","向","静态","linear","metrics","更","确保","以","initializers","但","kernel","16","py","维度","the","模型","call","乃是","为","相反","activation","一组","数据","{","keras","静态方法","后端","保留","可用","6","指全","到","不","模式","方法","是否","求取","这里","任何","请","导入","不同","即可","输出","想","外部","用法","信息","布尔","元素","可能","载入","测度","后面","括号","我们","作为","同","如下","占位","网络层","只","个","__","stddev","用来","随着","理解","3","参数","a","通过","约束","控制","写字","（","能","网络","方式"," ","有","输入","]","采取","正整数","每个","and","自定义","多","端","它","@","只有","一样","#","反过来说","需要","选项",")","7","两个","dense1","run","-","而是","8","=","。","则","这些","传递","下","weights","正则","按","不再","即","布尔值","中","optimizer"],"title":"构造方法","title_tokens":["构造","方法","构造方法"]},{"location":"book-1-x/chapter-1/linear-classification/#_13","text":"最后定义的式训练和测试方法。由于我们目前的project还比较简单，关于这两部分都直接调用现有的API即可。使用的API在之前已经说明。 model.fit 在没有额外设置的情况下，默认会返回一个 History回调器 ； model.evaluate 返回的是测试样本给出的损失函数和准确值测度。 model.predict 返回的是测试样本给出的网络输出。详情请参照 顺序模型API 。 lin-cls.py: class LinClsHandle 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def train ( self , dataSet ): ''' Use a data set to train the network. ''' return self . model . fit ( dataSet , epochs = self . epoch , steps_per_epoch = self . steppe ) def test ( self , data , labels ): ''' Use (data, label) pairs to test the results. ''' loss , accu = self . model . evaluate ( data , labels ) print ( 'Evaluated loss =' , loss ) print ( 'Evaluated accuracy =' , accu ) return self . model . predict ( data ) 信息: model.fit API model . fit ( dataSet , ** kwargs ) 是训练函数，注意这个函数虽然支持输入一组 x,~y x,~y 用来代替 dataSet ，我们还是建议在任何情况下都用dataSet馈送数据，以免内存中数据集占用过多。 dataSet : 数据集，其本身应当是一个 tf.data.Dataset 类型的类，或者是一个能不断迭代产生新数据的生成器。数据的 batch 大小由 dataSet 本身决定。 epochs : 整数，终止训练时经历的世代(轮次)数，通常一个epoch表示遍历整个数据集一回。 verbose : 0, 1或2。日志显示模式。 0=安静模式, 1=进度条, 2=每轮一行。默认是1。 callbacks : 回调器，它是 tf.keras.callbacks 模块下的类，用来在训练中进行记录保存和数据检查点更新。默认是 tf.keras.callbacks.History 。 validation_split : 在 0 和 1 之间浮动。用作验证集的训练数据的比例。模型将分出一部分不会被训练的验证数据，并将在每一轮结束时评估这些验证数据的误差和任何其他模型指标。验证数据是混洗之前 x 和 y 数据的最后一部分样本中。 validation_data : 元组 (x_val，y_val) 或元组 (x_val，y_val，val_sample_weights) ，用来评估损失，以及在每轮结束时的任何模型度量指标。模型将不会在这个数据上进行训练。这个参数会覆盖 validation_split 。 shuffle : 布尔值（是否在每轮迭代之前混洗数据）。当 steps_per_epoch 非 None 时，这个参数无效。 class_weight : 可选的字典，用来映射类索引（整数）到权重（浮点）值，用于加权损失函数（仅在训练期间）。这可能有助于告诉模型 「更多关注」来自代表性不足的类的样本。 sample_weight : 用来给损失函数添加权重，作用类似 model.compile 的同一参数。 initial_epoch : 开始训练的轮次（有助于恢复之前的训练）。 steps_per_epoch : 在声明一个轮次完成并开始下一个轮次之前的总步数（样品批次）。使用TensorFlow数据张量等输入张量进行训练时，默认值 None 等于数据集中样本的数量除以 batch 的大小，如果无法确定，则为1。 validation_steps : 只有在指定了 steps_per_epoch 时才有用。停止前要验证的总步数（批次样本）。 该函数会返回 callbacks 定义的实例。 信息 model.evaluate API model . evaluate ( x , y , ** kwargs ) 是测试函数，需要传入 label 即 y 来验证性能。 x , y : Numpy 数组，分别是输入和输出的真实参照值。 batch_size : 计算的 batch 大小，该函数会将输入的数据组拆分成许多 batch 分别计算，并组合起来，这个设定值对效果不产生影响，只影响计算过程。 verbose : 0, 1。日志显示模式。0=安静模式, 1=进度条。默认是1。 sample_weight : 用来给损失函数添加权重，作用类似 model.compile 的同一参数。 steps : 整数或 None 。 声明评估结束之前的总步数（批次样本）。默认值 None 。 该函数会返回损失函数和测度（列表）。 信息 model.predict API model . predict ( x , ** kwargs ) 是预测函数，用在只知道输入 x 的场合。 x : Numpy 数组，输入值。 batch_size : 计算的 batch 大小，该函数会将输入的数据组拆分成许多 batch 分别计算，并组合起来，这个设定值对效果不产生影响，只影响计算过程。 verbose : 0, 1。日志显示模式。0=安静模式, 1=进度条。默认是1。 steps : 整数或 None 。 声明评估结束之前的总步数（批次样本）。默认值 None 。 该函数返回预测结果。","text_tokens":["以免","记录","列表","size","映射","class","测试","生成器","和","部分","其他","了","1","；","'","dataset","使用","weight","不会","情况","整个","时","13","查点","实例","除以","决定","会","指标","张量","测试函数","结果","无效","迭代","前要","经历","accu","损失","这个","详情","test","整数","设定值","tf","_","linclshandle","model","顺序","分出","样品","知道","5","权重","预测","「","模块","通常","助于","终止","等","steppe","evaluate","10","训练","说明","本身","def","train","4","虽然","results","verbose","当","组拆","是","检查点","停止","有助于","由","不足","代表性","显示","计算","可选","(","比较简单","返回","应当","进度条","kwargs",".","*","这","，","tensorflow","return","日志","安静","use","一回","用作","完成","将","覆盖","评估","比例","shuffle","api","self","sample","没有","predict","新","来自","时才","numpy","一行","steps","比较",":","更新","设置","分别","遍历","现有","内存","label","并","有用","print","集中","函数","传入","效果","set","由于","器","pairs","注意","project","给","代表","分成","类似","都","accuracy","验证","性能","12","额外","准确","一个","11","y","关于","轮次","调用","fit","lin","过程","14","进度","占用","大小","对","表示","之前","真实","其","0","默认","支持","无法","给出","to","在","结束","定义","以及","同一","关注","还是","浮动","产生","检查","上","cls","来","简单","许多","batch","步数","none","保存","恢复","详情请","两","目前","指定","期间","世代","组合","有助","loss","已经","）","的",",","总","x","per","作用","还","之间","split","度量","参照","成器","该","起来","场合","测试方法","」","compile","默认值","馈送","批次","进行","类","2","集","如果","确定","样本","9","history","开始","设定","元组","更","py","或","the","模型","等于","建议","混洗","data","为","代替","告诉","一组","用","式","最后","数据","值","浮点","epoch","keras","~","epochs","6","到","索引","不","模式","不断","仅","方法","是否","非","数组","一部分","任何","影响","network","即可","输出","evaluated","一部","信息","布尔","一轮","误差","字典","可能","添加","测度","每","我们","生成","数","initial","只","用来","3","参数","labels","a","（","数量","回调","validation","能","callbacks","网络","直接","被"," ","用于","声明","输入","多","它","或者","只有","需要",")","7","-","8","=","。","则","这些","下","weights","过多","加权","每轮","val","即","类型","布尔值","中"],"title":"训练和测试方法","title_tokens":["训练","和","测试","方法","测试方法"]},{"location":"book-1-x/chapter-1/linear-classification/#_14","text":"首先，训练网络。我们随机生成 \\mathbf{x} \\mapsto \\mathbf{y}:~\\mathbb{R}^{10} \\mapsto \\mathbb{R}^6 \\mathbf{x} \\mapsto \\mathbf{y}:~\\mathbb{R}^{10} \\mapsto \\mathbb{R}^6 的仿射变换，并且设置好数据集，给定噪声扰动为 \\boldsymbol{\\varepsilon} \\sim \\mathcal{N}(0,1)^6 \\boldsymbol{\\varepsilon} \\sim \\mathcal{N}(0,1)^6 。设定20个epoch，每个epoch迭代500次，每次馈入32个样本构成的batch，然后开始训练： lin-cls.py 1 2 3 4 5 6 7 8 9 # Initialization A = np . random . normal ( 0 , 10 , [ INPUT_SHAPE , LABEL_SHAPE ]) c = np . random . uniform ( 1 , 3 , [ 1 , LABEL_SHAPE ]) dataSet = dp . TestDataSet ( 10 , A , c ) dataSet . config ( batch = 32 , noise = 0.1 ) # Construct the model and train it. h = LinClsHandle ( learning_rate = 0.01 , epoch = 20 , steppe = 500 ) h . construct () record = h . train ( iter ( dataSet )) Output Epoch 1 /20 500 /500 [==============================] - 1s 3ms/step - loss: 6 .3005 - accuracy: 0 .5884 - binary_accuracy: 0 .5884 Epoch 2 /20 500 /500 [==============================] - 1s 2ms/step - loss: 5 .4671 - accuracy: 0 .6407 - binary_accuracy: 0 .6407 Epoch 3 /20 500 /500 [==============================] - 1s 2ms/step - loss: 4 .5711 - accuracy: 0 .6957 - binary_accuracy: 0 .6957 Epoch 4 /20 500 /500 [==============================] - 1s 2ms/step - loss: 3 .6789 - accuracy: 0 .7519 - binary_accuracy: 0 .7519 Epoch 5 /20 500 /500 [==============================] - 1s 2ms/step - loss: 2 .7101 - accuracy: 0 .8127 - binary_accuracy: 0 .8127 Epoch 6 /20 500 /500 [==============================] - 1s 2ms/step - loss: 2 .0059 - accuracy: 0 .8627 - binary_accuracy: 0 .8627 Epoch 7 /20 500 /500 [==============================] - 1s 2ms/step - loss: 1 .6403 - accuracy: 0 .8894 - binary_accuracy: 0 .8894 Epoch 8 /20 500 /500 [==============================] - 1s 2ms/step - loss: 1 .3663 - accuracy: 0 .9066 - binary_accuracy: 0 .9066 Epoch 9 /20 500 /500 [==============================] - 1s 2ms/step - loss: 1 .0466 - accuracy: 0 .9274 - binary_accuracy: 0 .9274 Epoch 10 /20 500 /500 [==============================] - 1s 2ms/step - loss: 0 .8377 - accuracy: 0 .9418 - binary_accuracy: 0 .9418 Epoch 11 /20 500 /500 [==============================] - 1s 2ms/step - loss: 0 .6465 - accuracy: 0 .9546 - binary_accuracy: 0 .9546 Epoch 12 /20 500 /500 [==============================] - 1s 2ms/step - loss: 0 .4492 - accuracy: 0 .9667 - binary_accuracy: 0 .9667 Epoch 13 /20 500 /500 [==============================] - 1s 2ms/step - loss: 0 .2795 - accuracy: 0 .9779 - binary_accuracy: 0 .9779 Epoch 14 /20 500 /500 [==============================] - 1s 2ms/step - loss: 0 .1624 - accuracy: 0 .9861 - binary_accuracy: 0 .9861 Epoch 15 /20 500 /500 [==============================] - 1s 2ms/step - loss: 0 .0680 - accuracy: 0 .9926 - binary_accuracy: 0 .9926 Epoch 16 /20 500 /500 [==============================] - 1s 2ms/step - loss: 0 .0128 - accuracy: 0 .9971 - binary_accuracy: 0 .9971 Epoch 17 /20 500 /500 [==============================] - 1s 2ms/step - loss: 0 .0055 - accuracy: 0 .9981 - binary_accuracy: 0 .9981 Epoch 18 /20 500 /500 [==============================] - 1s 2ms/step - loss: 0 .0052 - accuracy: 0 .9986 - binary_accuracy: 0 .9986 Epoch 19 /20 500 /500 [==============================] - 1s 2ms/step - loss: 0 .0055 - accuracy: 0 .9981 - binary_accuracy: 0 .9981 Epoch 20 /20 500 /500 [==============================] - 1s 2ms/step - loss: 0 .0049 - accuracy: 0 .9985 - binary_accuracy: 0 .9985 接下来，从训练返回的 History 类型的回调器中抽取对loss和accuracy的记录。 lin-cls.py 1 2 3 4 5 # Show records plt . semilogy ( record . epoch , record . history [ 'loss' ]), plt . xlabel ( 'epoch' ), plt . ylabel ( 'Cross entropy' ) plt . gcf () . set_size_inches ( 5 , 5 ), plt . show () plt . plot ( record . epoch , record . history [ 'accuracy' ], label = 'self defined' ), plt . plot ( record . epoch , record . history [ 'binary_accuracy' ], label = 'from tensorflow' ), plt . xlabel ( 'epoch' ), plt . ylabel ( 'Accuracy' ), plt . legend () plt . gcf () . set_size_inches ( 5 , 5 ), plt . show () Output 结果显示，我们自定义的准确度测度和Tensorflow内置的 二分类准确度 完全相同，这说明其本身的定义就是求取所有元素阈值化后，各自分类结果是否正确的平均值。这个实验也让我们对自定义测度函数有了一定的认识。 重新设定数据集的产生方式，变为每个batch含10个样本。使用这组重新随机生成的数据测试网络输出， lin-cls.py 1 2 3 4 5 6 7 8 9 10 11 12 # Generate a group of testing samples: dataSet . config ( batch = 10 ) x , y = next ( dataSet ) # Check the testing results yp = h . test ( x , y ) _ , ( ax1 , ax2 ) = plt . subplots ( 1 , 2 ) ax1 . imshow ( y , interpolation = 'nearest' , aspect = 'auto' ) ax1 . set_title ( 'True class' ) ax2 . imshow ( yp , interpolation = 'nearest' , aspect = 'auto' ) ax2 . set_title ( 'Predicted class' ) plt . gcf () . set_size_inches ( 10 , 5 ), plt . show () Output Evaluated loss ( losses.BinaryCrossentropy ) = 0 .0023145806044340134 Evaluated accuracy ( self defined ) = 1 .0 Evaluated accuracy ( metrics.BinaryAccuracy ) = 1 .0 注意我们未对测量的结果阈值化，因此显示出来的测量结果和理想值略有差别，但从图可知，阈值化后则测量结果全部准确。 通过抽取 h.dense1 的参数，我们可以对比 \\mathbf{A} \\mathbf{A} 和 \\mathbf{W} \\mathbf{W} ，以及 \\mathbf{c} \\mathbf{c} 和 \\mathbf{b} \\mathbf{b} ， lin-cls.py 1 2 3 4 5 6 7 8 9 10 11 # Check the regressed values W , b = h . dense1 . get_weights () plt . imshow ( A , interpolation = 'nearest' , aspect = 'auto' ), plt . colorbar (), plt . gca () . set_title ( 'A' ) plt . gcf () . set_size_inches ( 6 , 5 ), plt . show () plt . imshow ( W , interpolation = 'nearest' , aspect = 'auto' ), plt . colorbar (), plt . gca () . set_title ( 'W' ) plt . gcf () . set_size_inches ( 6 , 5 ), plt . show () plt . plot ( c . T , label = 'c' ) plt . plot ( b . T , label = 'b' ) plt . legend () plt . gcf () . set_size_inches ( 5 , 5 ), plt . show () Output 可以发现，虽然我们训练的分类器十分有效，但其权值和预期的 \\mathbf{A} \\mathbf{A} , \\mathbf{c} \\mathbf{c} 并不完全相同。这是由于sigmoid函数激活的特性，使得当预测值偏向最小或最大的情况下， |\\sigma(x)| \\rightarrow 1 |\\sigma(x)| \\rightarrow 1 ，根据 (7) (7) ，可知其梯度 |\\sigma(x)(1-\\sigma(x))| \\rightarrow 0 |\\sigma(x)(1-\\sigma(x))| \\rightarrow 0 ，因此那些分类结果已经比较确信的样本，其梯度消失，对训练网络的影响忽略不计（这是合理的，因为我们不希望极端样本干扰结果，更希望对分类结果不确切的样本进行训练）。故而，我们虽然可以求解出这个分类问题，但求解到的 \\mathbf{W} \\mathbf{W} , \\mathbf{b} \\mathbf{b} 不会回归到 \\mathbf{A} \\mathbf{A} , \\mathbf{c} \\mathbf{c} 上。关于回归问题，我们会在下一节进一步讨论。","text_tokens":["变为","|","17","记录","18","对比","defined","size","sigma","一节","8894","class","测试","generate","最大","和","shape","0.01","了","500","1","'","相同","下来","dataset","使用","不会","c","情况","预测值","2ms","32","title","13","get","xlabel","可知","construct","回归","^","会","结果","0055","权值","干扰","确切","迭代","entropy","阈值","noise","这个","test","output","使得","有效","w","colorbar","_","接下来","linclshandle","plt","9667","model","分类","5","未","8127","预测","不计","\\","steppe","interpolation","10","9926","发现","}","yp","忽略不计","训练","可以","说明","8627","本身","train","4","虽然","results","当","record","1624","确信","化后","重新","b","好","显示","19","(","返回","因为","馈入","从",".","这","变换","，","ax1","show","input","testdataset","首先","tensorflow","testing","9986","sigmoid","激活","化","7519","0059","结果显示","9779","uniform","3005","t","求解","self","aspect","比较","8377","6465","所有","差别",":","自定","接下","极端","设置","二","[","losses","随机","认识","label","4492","并","进一步","出来","函数","图","predicted","20","仿射变换","set","由于","boldsymbol","故而","注意","learning","数据测试","varepsilon","因此","accuracy","mathbf","rightarrow","binaryaccuracy","legend","0.1","准确度","12","均值","6407","r","准确","完全","构成","semilogy","消失","11","y","0466","关于","略有","lin","14","binarycrossentropy","对","：","然后","出","其","0","gca","9418","auto","内置","在","gcf","定义","以及","产生","7101","特性","check","上","np","sim","这是","cls","器中","噪声","那些","理想","batch","0128","忽略","rate","4671","/","5711","0052","并且","loss","已经","step","）","samples","的",",","inches","15","records","of","x","true","9546","initialization","抽取","也","各自","一定","6789","h","3663","完全相同","让","次","进行","2","集","根据","9971","测量","样本","9","history","设定","开始","这组","给定","mathbb","metrics","更","但","16","py","全部","最小","random","或","the","合理","6403","2795","normal","为","讨论","每次","values","数据","from","值","epoch","{","~","平均","6","9861","到","config","正确","不","就是","十分","是否","regressed","9066","subplots","求取","9274","影响","1s","输出","evaluated","梯度","ylabel","9981","元素","plot","iter","mapsto","5884","测度","我们","生成","个","0049","0680","偏向","3","参数","n","a","通过","group","（","希望","回调","it","含","网络","binary","方式","nearest"," ","有","0023145806044340134","6957","cross","]","每个","and","自定义","实验","仿射","预期","#","mathcal","一步",")","9985","7","平均值","dense1","-","imshow","8","=","。","问题","则","下","weights","ax2","dp","分类器","扰动","next","类型","3ms"],"title":"调试","title_tokens":["调试"]},{"location":"book-1-x/chapter-1/linear-regression/","text":"线性回归 ¶ 摘要 本节介绍如何使用类模型(Model)来编写一个线性回归器，以拟合出一个线性模型。本节将第一次介绍如何编写一个带用户参数(选项)的Project，并且允许用户选择不同的优化器、对比验证不同优化算法的效果。 理论 ¶ 一般回归问题 ¶ 设存在一个多输出方程 \\mathbf{y} = \\mathcal{F}(x) \\mathbf{y} = \\mathcal{F}(x) ，当然 \\mathcal{F} \\mathcal{F} 可以是非线性函数，那么我们可以考虑使用一个带可调参数的模型 \\mathbf{D}_{\\boldsymbol{\\Theta}}(\\mathbf{x}) \\mathbf{D}_{\\boldsymbol{\\Theta}}(\\mathbf{x}) 来模拟它，其中 \\boldsymbol{\\Theta} \\boldsymbol{\\Theta} 是可调的参数。于是，该问题可以被表述为 \\begin{equation} \\begin{aligned} \\arg \\min_\\limits{\\boldsymbol{\\Theta}} &\\sum_{k=1}^N \\mathcal{L} \\left( \\mathbf{y}_k,~ \\mathbf{D}_{\\boldsymbol{\\Theta}}(\\mathbf{x}_k) \\right),\\\\ \\mathrm{s.t.}~&\\mathbf{y}_k = \\mathcal{F}(\\mathbf{x}_k). \\end{aligned} \\end{equation} 在我们不知道 \\mathcal{F} \\mathcal{F} 的情况下，我们的目的是使用大量的 \\mathbf{x}_k,~\\mathbf{y}_k \\mathbf{x}_k,~\\mathbf{y}_k 样本，来调整出一个最优的近似模型 \\mathbf{D}_{\\boldsymbol{\\Theta}} \\mathbf{D}_{\\boldsymbol{\\Theta}} 。由于 \\mathcal{F} \\mathcal{F} 是非线性的，这要求我们的 \\mathbf{D}_{\\boldsymbol{\\Theta}} \\mathbf{D}_{\\boldsymbol{\\Theta}} 也可以是非线性的。实际情况下，这样的问题往往不容易求解，尤其是信号的非线性性极强时，该问题很容易陷入局部最优解，从而对求得一个可接受的解造成很大的障碍。 这里 \\mathcal{L} \\mathcal{L} 是损失函数。在回归问题中，很多情况下我们都只能选择 均方误差 (Mean squared error, MSE) 作为损失函数，这是因为回归问题的目的是模拟出一组信号来，而这些信号的分布范围可能是任意的。在一些特别的应用里，例如，如果我们的信号全部为正值，那么我们可以考虑使用 信噪比 (Signal-to-noise ratio, SNR) 来作为我们的损失函数。 线性回归 ¶ 继上一节的学习，我们知道如何解一个定义为 \\begin{align} \\mathbf{y} = \\left\\{ \\begin{bmatrix}\\hat{y}_1 > 0 & \\hat{y}_2 > 0 & \\cdots & \\hat{y}_n > 0\\end{bmatrix}^T, ~ \\left| ~ \\hat{\\mathbf{y}} = \\mathbf{A} \\mathbf{x} + \\mathbf{c} + \\boldsymbol{\\varepsilon} \\right. \\right\\}, \\end{align} 的分类模型。在本节，让我们考虑一个更简单的模型： \\begin{align} \\mathbf{y} = \\mathbf{A} \\mathbf{x} + \\mathbf{c} + \\boldsymbol{\\varepsilon}. \\end{align} 现在， \\mathbf{y} \\mathbf{y} 是关乎 \\mathbf{A} \\mathbf{A} 和 \\mathbf{c} \\mathbf{c} 的一个仿射函数，并且我们仍然保留噪声函数 \\boldsymbol{\\varepsilon} \\boldsymbol{\\varepsilon} 。由于这是一个线性模型，我们可以想象到，存在一个线性回归器， \\mathbf{W},~\\mathbf{b} \\mathbf{W},~\\mathbf{b} ，使得预测结果为 \\begin{align} \\tilde{\\mathbf{y}} = \\mathbf{W} \\mathbf{x} + \\mathbf{b}. \\end{align} 类似上一节，假设我们的数据集 (\\mathbf{x},~\\mathbf{y}) \\in \\mathbb{D} (\\mathbf{x},~\\mathbf{y}) \\in \\mathbb{D} 符合 (3) (3) 定义的数据分布特征。我们的基本要求是，在我们不知道 \\mathbf{A},~\\mathbf{c} \\mathbf{A},~\\mathbf{c} 的情况下，使用大量 (\\mathbf{x}_k,~\\mathbf{y}_k) \\in \\mathbb{D} (\\mathbf{x}_k,~\\mathbf{y}_k) \\in \\mathbb{D} 样本训练一个线性分类器，使得当我们给定任意一个新样本 \\mathbf{x} \\mathbf{x} 的时候，分类器能推断出其对应的 \\mathbf{y} \\mathbf{y} 。 故而，该问题可以描述为 \\begin{equation} \\begin{aligned} \\arg \\min_\\limits{\\mathbf{W},~\\mathbf{b}} &\\sum_{k=1}^N \\mathcal{L} \\left( \\mathbf{y}_k,~ \\mathbf{W} \\mathbf{x}_k + \\mathbf{b} \\right), \\\\ \\mathcal{L} \\left( \\mathbf{y},~ \\tilde{\\mathbf{y}} \\right) &= \\lVert \\mathbf{y} - \\tilde{\\mathbf{y}} \\rVert_2^2. \\end{aligned} \\end{equation} 在本例中， \\mathbf{y} \\mathbf{y} 有正有负，因此我们使用均方误差来作为损失函数。 求解问题 ¶ 作为线性问题，该问题实际上可以写出其解析解。未免读者感到过于突兀，我们先从一个简单的问题开始入手： 例子：一次函数的线性回归 如果我们的矩阵 \\mathbf{A} \\mathbf{A} 退化为标量 a a ，向量 \\mathbf{c} \\mathbf{c} 退化为标量c，那么 (3) (3) 可以重新写为： \\begin{align} y = a x + c + \\varepsilon. \\end{align} 考虑我们拥有N个样本点 (x_k,~y_k) (x_k,~y_k) ，上述问题实际上可以求得解析解。设由这N个点构成了样本向量 \\mathbf{x}_d,~\\mathbf{y}_d \\mathbf{x}_d,~\\mathbf{y}_d (注意与前述的向量区分开来)，则问题可以写成 \\begin{align} \\arg \\min_\\limits{a,~c} \\lVert \\mathbf{y}_d - a \\mathbf{x}_d - c \\mathbf{1} \\rVert^2_2. \\end{align} 这就是附图所示的，拟合到直线的一次函数回归问题。将该损失函数展开，有 \\begin{equation} \\begin{aligned} \\mathcal{L}(a,~c) &= ( \\mathbf{y}_d - a \\mathbf{x}_d - c \\mathbf{1} )^T ( \\mathbf{y}_d - a \\mathbf{x}_d - c \\mathbf{1} )\\\\ &= \\mathbf{y}_d^T\\mathbf{y}_d + a^2 \\mathbf{x}_d^T \\mathbf{x}_d + c^2 + 2ac \\mathbf{1}^T \\mathbf{x}_d - 2 a \\mathbf{y}_d^T \\mathbf{x}_d - 2c \\mathbf{1}^T \\mathbf{y}_d. \\end{aligned} \\end{equation} 令 \\dfrac{\\partial \\mathcal{L}(a,~c)}{\\partial a}=0,~\\dfrac{\\partial \\mathcal{L}(a,~c)}{\\partial c}=0 \\dfrac{\\partial \\mathcal{L}(a,~c)}{\\partial a}=0,~\\dfrac{\\partial \\mathcal{L}(a,~c)}{\\partial c}=0 ，则我们得到一组二元一次方程组 \\begin{equation} \\left\\{ \\begin{aligned} a \\mathbf{x}_d^T \\mathbf{x}_d + c \\mathbf{1}^T \\mathbf{x}_d &= \\mathbf{y}_d^T \\mathbf{x}_d. \\\\ c + a \\mathbf{1}^T \\mathbf{x}_d &= \\mathbf{1}^T \\mathbf{y}_d. \\end{aligned} \\right. \\end{equation} 解之，得 \\begin{equation} \\left\\{ \\begin{aligned} a &= \\frac{ \\mathbf{y}_d^T \\mathbf{x}_d - ( \\mathbf{1}^T \\mathbf{y}_d ) ( \\mathbf{1}^T \\mathbf{x}_d ) }{ \\mathbf{x}_d^T \\mathbf{x}_d - (\\mathbf{1}^T \\mathbf{x}_d)^2 } = \\frac{ \\sum_k x_k y_k - \\sum_k y_k \\sum_k x_k }{ \\sum_k (x_k)^2 - \\left(\\sum_k x_k\\right)^2 }. \\\\ c &= \\mathbf{1}^T \\mathbf{y}_d - a ( \\mathbf{1}^T \\mathbf{x}_d ) = \\sum_k y_k - a \\left( \\sum_k x_k \\right). \\end{aligned} \\right. \\end{equation} 这个式子在诸多教材上都会出现，作为学生解回归问题的入门话题。可见，我们在本节讨论的问题并不是一个陌生的问题，相反，我们过去非常熟悉的一个问题，是这个问题的退化到标量下的特殊情况。另，计算该问题的相关系数，我们常使用 \\begin{align} \\rho = \\frac{ \\sum_k \\left(x_k - \\overline{x}\\right) \\left(y_k - \\overline{y}\\right) }{ \\sqrt{ \\sum_k \\left(x_k - \\overline{x}\\right)^2 \\sum_k \\left(y_k - \\overline{y}\\right)^2 } }, \\end{align} 其中 \\overline{x} = \\sum_k x_k ,~ \\overline{y} = \\sum_k y_k \\overline{x} = \\sum_k x_k ,~ \\overline{y} = \\sum_k y_k 。 有了解上述例子的基础，我们自然可以写出， \\begin{equation} \\begin{aligned} \\mathcal{L}(\\mathbf{A},~\\mathbf{c}) &= \\sum_k ( \\mathbf{y}_k - \\mathbf{A} \\mathbf{x}_k - \\mathbf{c} )^T ( \\mathbf{y}_k - \\mathbf{A} \\mathbf{x}_k - \\mathbf{c} )\\\\ &= \\sum_k \\left[ \\mathbf{y}_k^T\\mathbf{y}_k + \\mathbf{x}_k^T \\mathbf{A}^T\\mathbf{A} \\mathbf{x}_k + \\mathbf{c}^T \\mathbf{c} + 2 \\mathbf{c}^T \\mathbf{A} \\mathbf{x}_k - 2 \\mathbf{y}_k^T \\mathbf{A} \\mathbf{x}_k - 2 \\mathbf{y}_k^T \\mathbf{c} \\right]. \\end{aligned} \\end{equation} 提示 接下来的求导主要涉及单值对矩阵求导（导数仍是矩阵），单值对向量求导（导数仍是向量）。可以参考 The Matrix Cookbook 查到对应情况下的求导结果。 同理，令 \\dfrac{\\partial \\mathcal{L}(\\mathbf{A},~\\mathbf{c})}{\\partial \\mathbf{A}}=0,~\\dfrac{\\partial \\mathcal{L}(\\mathbf{A},~\\mathbf{c})}{\\partial \\mathbf{c}}=0 \\dfrac{\\partial \\mathcal{L}(\\mathbf{A},~\\mathbf{c})}{\\partial \\mathbf{A}}=0,~\\dfrac{\\partial \\mathcal{L}(\\mathbf{A},~\\mathbf{c})}{\\partial \\mathbf{c}}=0 ，则我们得到一组二元一次方程组 \\begin{equation} \\left\\{ \\begin{aligned} \\sum_k \\left[ \\mathbf{A} \\mathbf{x}_k \\mathbf{x}_k^T + \\mathbf{c} \\mathbf{x}_k^T \\right] &= \\sum_k \\left[ \\mathbf{y}_k \\mathbf{x}_k^T \\right]. \\\\ \\sum_k \\left[ \\mathbf{c} + \\mathbf{A} \\mathbf{x}_k \\right] &= \\sum_k \\left[ \\mathbf{y}_k \\right]. \\end{aligned} \\right. \\end{equation} 解之，得 \\begin{equation} \\left\\{ \\begin{aligned} \\mathbf{A} &= \\left[ N \\sum_k \\left[ \\mathbf{y}_k \\mathbf{x}_k^T \\right] - \\sum_k \\left[ \\mathbf{y}_k \\right] \\sum_k \\left[ \\mathbf{x}_k^T \\right] \\right] \\left[ N \\sum_k \\left[ \\mathbf{x}_k \\mathbf{x}_k^T \\right] - \\sum_k \\left[ \\mathbf{x}_k \\right] \\sum_k \\left[ \\mathbf{x}_k^T \\right] \\right]^{-1} \\\\ \\mathbf{c} &= \\frac{1}{N} \\sum_k \\left[ \\mathbf{y}_k - \\mathbf{A} \\mathbf{x}_k \\right]. \\end{aligned} \\right. \\end{equation} 可见，当上式中的逆不存在时（即低秩的情况），该方程还是有可能解不唯一。 同时，相关系数的计算可以表示为 \\begin{align} \\rho = \\mathrm{mean} \\left[ \\frac{ \\sum_k \\left(\\mathbf{x}_k - \\overline{\\mathbf{x}}\\right) \\cdot \\left(\\mathbf{y}_k - \\overline{\\mathbf{y}}\\right) }{ \\sqrt{ \\sum_k \\left[ \\left(\\mathbf{x}_k - \\overline{\\mathbf{x}}\\right) \\cdot \\left(\\mathbf{x}_k - \\overline{\\mathbf{x}}\\right) \\right] \\sum_k \\left[ \\left(\\mathbf{y}_k - \\overline{\\mathbf{y}}\\right) \\cdot \\left(\\mathbf{y}_k - \\overline{\\mathbf{y}}\\right) \\right] } } \\right]. \\end{align} 这就是 皮尔森相关系数 (Pearson's correlation) 。其中 \\overline{\\mathbf{x}} = \\sum_k \\mathbf{x}_k ,~ \\overline{\\mathbf{y}} = \\sum_k \\mathbf{y}_k \\overline{\\mathbf{x}} = \\sum_k \\mathbf{x}_k ,~ \\overline{\\mathbf{y}} = \\sum_k \\mathbf{y}_k ， \\cdot \\cdot 表示的是两个向量按元素各自相乘。它是式 (11) (11) 在多变量问题上的推广。相当于对向量的每一个元素，分别从统计上求取皮尔森相关系数，然后对向量每个元素对应的皮尔森相关系数求取平均值。 优化算法 ¶ 接下来，我们要介绍几种最常见的优化算法。关于更多这方面的内容，可以查考Google团队编写的在线电子书 Deep Learning 。笔者打算在未来为此开辟专题写文，因此这里只是介绍几种常见的 一阶梯度下降 算法。传统优化领域里，单靠一阶梯度下降往往难以满足对准确度的需求，但深度学习(Deep learning)往往必须使用这些简单的一阶梯度下降算法，就连使用一阶梯度近似二阶梯度的算法 共轭梯度下降 ，在很多情况下都被认为是费用(cost)过高。这是由于一个深度网络，往往具有大量的参数需要训练，因此一个Model的参数少则数十MB，多则上GB。一阶梯度下降算法所需的计算量小，能确保我们一次迭代的过程能迅速完成，因而备受青睐。为了提升其性能，深度学习领域内也对其进行了诸多改进。 注意 其实，论到优化算法，往往不得不提到 反向传播 。不过实际上，一个Tensorflow的入门者，其实完全不需要学习如何推导反向传播的过程。下面我们的叙述也完全不会提及反向传播相关的内容。关于为何我们不需要了解反向传播，在下一节我们会论到。但是，在本教程后期，介绍高级技巧的时候，我们会详细展开。事实上，笔者认为，一个Tensorflow的用户，如果只是为了编写代码，反向传播与ta其实无关痛痒；但只有真正掌握反向传播，我们才算是真正入门了神经网络的理论。 我们在这里说到优化算法，是用在训练网络上的。事实上，只有几种个别的机器学习应用，需要我们在测试阶段执行 迭代算法 (iterative algorithm) 。一般来说，深度学习的训练过程可以被普遍地描述为：已知一个带可调参数 \\boldsymbol{\\Theta} \\boldsymbol{\\Theta} 的模型 \\mathcal{D}_{\\boldsymbol{\\Theta}} \\mathcal{D}_{\\boldsymbol{\\Theta}} ，已知一组数据集 (\\mathbf{x}_i,~\\mathbf{y}_i) \\in \\mathbb{D} (\\mathbf{x}_i,~\\mathbf{y}_i) \\in \\mathbb{D} ，则我们的训练目标为 \\begin{equation} \\begin{aligned} \\arg \\min_\\limits{\\boldsymbol{\\Theta}} \\mathbb{E}_{(\\mathbf{x}_i,~\\mathbf{y}_i) \\in \\mathbb{D}} \\left[ \\mathcal{L} \\left( \\mathbf{y}_i,~ \\mathcal{D}_{\\boldsymbol{\\Theta}} (\\mathbf{x}_i) \\right) \\right]. \\end{aligned} \\end{equation} 实际情况下，一般用均值估计来代替上式的期望函数。联系我们上一节的优化问题 (1) (1) 和本节的优化问题 (5) (5) ，都可以描述成上式的形式。也就是说，线性分类/回归器，是神经网络在解线性问题时的特例。 引入动量的优化算法 ¶ 接下来，让我们看看第一个算法， 随机梯度下降 (stochastic gradient descent, SGD) 。 随机梯度下降 记学习率为 \\epsilon \\epsilon ，则在每次迭代中 随机抽取（或从随机排列的数据集中按顺序抽取）m个样本 (\\mathbf{x}_k,~\\mathbf{y}_k) (\\mathbf{x}_k,~\\mathbf{y}_k) ，称这m个样本为一个batch； 计算梯度 \\mathbf{g} = \\frac{1}{m} \\nabla_{\\boldsymbol{\\Theta}} \\sum\\limits_{k=1}^m \\mathcal{L} \\left( \\mathbf{y}_k,~ \\mathcal{D}_{\\boldsymbol{\\Theta}} (\\mathbf{x}_k) \\right) \\mathbf{g} = \\frac{1}{m} \\nabla_{\\boldsymbol{\\Theta}} \\sum\\limits_{k=1}^m \\mathcal{L} \\left( \\mathbf{y}_k,~ \\mathcal{D}_{\\boldsymbol{\\Theta}} (\\mathbf{x}_k) \\right) ； 更新参数 \\boldsymbol{\\Theta} \\leftarrow \\boldsymbol{\\Theta} - \\epsilon \\mathbf{g} \\boldsymbol{\\Theta} \\leftarrow \\boldsymbol{\\Theta} - \\epsilon \\mathbf{g} 。 注意学习率一般需要设为一个较小的值，视情况而定。 由于梯度的期望满足 \\begin{equation} \\begin{aligned} \\mathbb{E} \\left[ \\mathbf{g} \\right] &= \\frac{1}{m} \\sum\\limits_{k=1}^m \\mathbb{E} \\left[ \\nabla_{\\boldsymbol{\\Theta}} \\mathcal{L} \\left( \\mathbf{y}_k,~ \\mathcal{D}_{\\boldsymbol{\\Theta}} (\\mathbf{x}_k) \\right) \\right] \\\\ &= \\mathbb{E} \\left[ \\nabla_{\\boldsymbol{\\Theta}} \\mathcal{L} \\left( \\mathbf{y},~ \\mathcal{D}_{\\boldsymbol{\\Theta}} (\\mathbf{x}) \\right) \\right] = \\nabla_{\\boldsymbol{\\Theta}} \\mathbb{E} \\left[ \\mathcal{L} \\left( \\mathbf{y},~ \\mathcal{D}_{\\boldsymbol{\\Theta}} (\\mathbf{x}) \\right) \\right]. \\end{aligned} \\end{equation} 可知随机抽取m个样本计算的梯度，在统计学上的期望等于全局梯度的期望。因此，这是一个有效的算法。 随机梯度下降存在明显的弊端，就是在收敛到（全局或局部）最优解的前提下，全局梯度为0，但通过随机选取batch得到的梯度（一般）可能不为0；并且，迭代受到个别极端样本梯度的影响较大，因此，我们有了第一个改进，即 带动量的随机梯度下降 (SGD with momentum) 。 带动量的随机梯度下降 参考文献 提出该算法的文章，可以在这里参考： On the momentum term in gradient descent learning algorithms. Neural Networks 记学习率为 \\epsilon \\epsilon ，惯性常数为 \\alpha \\alpha ，初始化动量 \\mathbf{v}=\\mathbf{v}_0 \\mathbf{v}=\\mathbf{v}_0 （不考虑继续训练的情况下 \\mathbf{v}_0 = \\mathbf{0} \\mathbf{v}_0 = \\mathbf{0} ），则在每次迭代中 随机抽取（或从随机排列的数据集中按顺序抽取）m个样本 (\\mathbf{x}_k,~\\mathbf{y}_k) (\\mathbf{x}_k,~\\mathbf{y}_k) ，称这m个样本为一个batch； 计算梯度 \\mathbf{g} = \\frac{1}{m} \\nabla_{\\boldsymbol{\\Theta}} \\sum\\limits_{k=1}^m \\mathcal{L} \\left( \\mathbf{y}_k,~ \\mathcal{D}_{\\boldsymbol{\\Theta}} (\\mathbf{x}_k) \\right) \\mathbf{g} = \\frac{1}{m} \\nabla_{\\boldsymbol{\\Theta}} \\sum\\limits_{k=1}^m \\mathcal{L} \\left( \\mathbf{y}_k,~ \\mathcal{D}_{\\boldsymbol{\\Theta}} (\\mathbf{x}_k) \\right) ； 计算带动量的更新值 \\mathbf{v} \\rightarrow \\alpha \\mathbf{v} - \\epsilon \\mathbf{g} \\mathbf{v} \\rightarrow \\alpha \\mathbf{v} - \\epsilon \\mathbf{g} ； 更新参数 \\boldsymbol{\\Theta} \\leftarrow \\boldsymbol{\\Theta} + \\mathbf{v} \\boldsymbol{\\Theta} \\leftarrow \\boldsymbol{\\Theta} + \\mathbf{v} 。 显然，我们不难计算出， \\begin{equation} \\begin{aligned} \\mathbb{E} \\left[ \\mathbf{v} \\right] &= \\alpha \\mathbb{E} \\left[ \\mathbf{v} \\right] - \\epsilon \\mathbb{E} \\left[ \\mathbf{g} \\right]. \\\\ \\mathbb{E} \\left[ \\mathbf{v} \\right] &= - \\frac{\\epsilon}{1 - \\alpha} \\mathbb{E} \\left[ \\mathbf{g} \\right]. \\end{aligned} \\end{equation} 注意惯性通常需要设为 \\alpha \\in (0,~1) \\alpha \\in (0,~1) 。 这种改进的带来的好处是， 每次更新梯度时，上一次的梯度都会以指数衰减的形式残留在本次迭代中，从而确保新的梯度会被旧的梯度部分中和，避免极端梯度对更新参数影响过大； 当求解得到的梯度陷入局部最优时，如果该局部最优处的曲率较小，可以依靠动量的惯性，越过该局部最优解。 附图说明了使用这种算法的好处。黑色路径为SGD的更新轨迹，而红色路径为本算法的更新轨迹，可以看出随着迭代次数的增加，算法收敛的效果强于SGD。 有人从Nesterov在1983年的论文得到启发，提出了一个修正后的带动量随机梯度下降法，即 带Nesterov动量的随机梯度下降 (SGD with Nesterov momentum) 。 带Nesterov动量的随机梯度下降 参考文献 提出该算法的文章，可以在这里参考： A method for unconstrained convex minimization problem with the rate of convergence o\\left( \\frac{1}{k_2} \\right) o\\left( \\frac{1}{k_2} \\right) 记学习率为 \\epsilon \\epsilon ，惯性常数为 \\alpha \\alpha ，初始化动量 \\mathbf{v}=\\mathbf{v}_0 \\mathbf{v}=\\mathbf{v}_0 （不考虑继续训练的情况下 \\mathbf{v}_0 = \\mathbf{0} \\mathbf{v}_0 = \\mathbf{0} ），则在每次迭代中 随机抽取（或从随机排列的数据集中按顺序抽取）m个样本 (\\mathbf{x}_k,~\\mathbf{y}_k) (\\mathbf{x}_k,~\\mathbf{y}_k) ，称这m个样本为一个batch； 计算惯性目标点的位置： \\boldsymbol{\\Theta}^{\\dagger} \\leftarrow \\boldsymbol{\\Theta} + \\alpha \\mathbf{v} \\boldsymbol{\\Theta}^{\\dagger} \\leftarrow \\boldsymbol{\\Theta} + \\alpha \\mathbf{v} ； 计算梯度 \\mathbf{g} = \\frac{1}{m} \\nabla_{\\boldsymbol{\\Theta}} \\sum\\limits_{k=1}^m \\mathcal{L} \\left( \\mathbf{y}_k,~ \\mathcal{D}_{\\boldsymbol{\\Theta}^{\\dagger}} (\\mathbf{x}_k) \\right) \\mathbf{g} = \\frac{1}{m} \\nabla_{\\boldsymbol{\\Theta}} \\sum\\limits_{k=1}^m \\mathcal{L} \\left( \\mathbf{y}_k,~ \\mathcal{D}_{\\boldsymbol{\\Theta}^{\\dagger}} (\\mathbf{x}_k) \\right) ； 计算带动量的更新值 \\mathbf{v} \\rightarrow \\alpha \\mathbf{v} - \\epsilon \\mathbf{g} \\mathbf{v} \\rightarrow \\alpha \\mathbf{v} - \\epsilon \\mathbf{g} ； 更新参数 \\boldsymbol{\\Theta} \\leftarrow \\boldsymbol{\\Theta}^{\\dagger} - \\epsilon \\mathbf{g} \\boldsymbol{\\Theta} \\leftarrow \\boldsymbol{\\Theta}^{\\dagger} - \\epsilon \\mathbf{g} 。 其实，该方法的更新量期望与前一种方法一样， 显然，我们不难计算出， \\begin{equation} \\begin{aligned} \\mathbb{E} \\left[ \\mathbf{v} \\right] &= - \\frac{\\epsilon}{1 - \\alpha} \\mathbb{E} \\left[ \\mathbf{g} \\right]\\\\ &= \\frac{\\epsilon}{1 - \\alpha} \\nabla_{\\boldsymbol{\\Theta}} \\mathbb{E} \\left[ \\mathcal{L} \\left( \\mathbf{y},~ \\mathcal{D}_{\\boldsymbol{\\Theta} + \\alpha \\mathbf{v}} (\\mathbf{x}) \\right) \\right]. \\end{aligned} \\end{equation} 当收敛到最优解时， \\mathbf{v} \\rightarrow 0 \\mathbf{v} \\rightarrow 0 ，同时有 \\boldsymbol{\\Theta} + \\alpha \\mathbf{v} \\rightarrow \\boldsymbol{\\Theta} \\boldsymbol{\\Theta} + \\alpha \\mathbf{v} \\rightarrow \\boldsymbol{\\Theta} 。我们在此不展开证明这个算法是能收敛的。但Nesterov的文献表明，它能将上面提到的带动量梯度下降算法的误差从 O\\left(\\frac{1}{K}\\right) O\\left(\\frac{1}{K}\\right) 下降到 O\\left(\\frac{1}{K^2}\\right) O\\left(\\frac{1}{K^2}\\right) 。其中 K K 为迭代次数。下图展示了这种方法的改进原理。它的梯度是在更新动量的惯性部分之后才计算出来的，因此新的梯度和之前的惯性是首尾相接的。实际实现时，按照上面的算法，每次迭代需要更新两次参数，计算一次梯度。合理调整算法的计算次序，可以改进为每次迭代更新一次参数，计算一次梯度。 引入可变学习率的优化算法 ¶ 上述几种算法共同的特点是，具有一个“学习率”。实际上，这个学习率非常不好处理，值过小时，收敛速度很慢；值过大时，在最优解附近又难以收敛。为了解决这一思路，我们可以令学习率可变。最简单的思路是，将学习率设为指数衰减的（当然也可以设置下界），这样当开始学习的时候，学习率较大；而即将收敛时，学习率又会较小。 但是，以上做法不过是一些小小的花招(trick)罢了，接下来介绍的几种算法，是根据当前计算出的梯度来自适应调整学习率的。理论上，使用这种算法，用户不再需要特别关注学习率对训练的影响，我们尽可以设置一个偏大的学习率，在训练过程中，它能被自适应调整到一个合适的区间上。 首先，我们来介绍一种初步的改进， Adagrad (Adaptive Subgradient) ， Adgrad 参考文献 提出该算法的文章，可以在这里参考： Adaptive Subgradient Methods for Online Learning and Stochastic Optimization 记学习率为 \\epsilon \\epsilon ，小量 \\delta \\delta ，初始化学习率参数对角矩阵为 \\mathbf{r} = \\mathrm{diag}(\\mathbf{0}) \\mathbf{r} = \\mathrm{diag}(\\mathbf{0}) ，则在每次迭代中 随机抽取（或从随机排列的数据集中按顺序抽取）m个样本 (\\mathbf{x}_k,~\\mathbf{y}_k) (\\mathbf{x}_k,~\\mathbf{y}_k) ，称这m个样本为一个batch； 计算梯度 \\mathbf{g} = \\frac{1}{m} \\nabla_{\\boldsymbol{\\Theta}} \\sum\\limits_{k=1}^m \\mathcal{L} \\left( \\mathbf{y}_k,~ \\mathcal{D}_{\\boldsymbol{\\Theta}} (\\mathbf{x}_k) \\right) \\mathbf{g} = \\frac{1}{m} \\nabla_{\\boldsymbol{\\Theta}} \\sum\\limits_{k=1}^m \\mathcal{L} \\left( \\mathbf{y}_k,~ \\mathcal{D}_{\\boldsymbol{\\Theta}} (\\mathbf{x}_k) \\right) ； 更新学习率为： \\mathbf{r} \\leftarrow \\mathbf{r} + \\mathrm{diag}(\\mathbf{g})^2 \\mathbf{r} \\leftarrow \\mathbf{r} + \\mathrm{diag}(\\mathbf{g})^2 ； 更新参数 \\boldsymbol{\\Theta} \\leftarrow \\boldsymbol{\\Theta} - \\dfrac{\\epsilon}{\\delta + \\sqrt{\\mathbf{r}}} \\mathbf{g} \\boldsymbol{\\Theta} \\leftarrow \\boldsymbol{\\Theta} - \\dfrac{\\epsilon}{\\delta + \\sqrt{\\mathbf{r}}} \\mathbf{g} 。 注意文献中常用向量点积 \\odot \\odot 来表示学习率，这样学习率就不是对角矩阵而是向量了。我们这里不定义额外的符号，以便不熟悉相关定义的读者理解。 这一方法的思想是，学习率随着梯度的累计增大而逐渐减小，类似我们使用指数衰减的策略。所不同的是，在梯度小的地方，我们认为梯度平缓，所以学习率减小得慢，以便算法迅速地通过这一片区域；在梯度大地地方，由于梯度陡峭，为了防止我们因为学习率过大漏过该区域，学习率减小得快，以适应梯度的大小。 这个方法没有从根本上解决迭代次数过多时，梯度过小的问题。不难看出该算法学习率以 O\\left(\\frac{1}{\\mathbf{g}^T\\mathbf{g}}\\right) O\\left(\\frac{1}{\\mathbf{g}^T\\mathbf{g}}\\right) 的比率衰减，经验指出，这个算法在很多情况下是不好用的，只能解决一些比较特定的模型。 在这里，我们依然不给出收敛性的证明（或许在未来我们会在专题中讨论这一问题）。读者不必为这些算法的原理感到压力，我们只需要对其有一个直观的了解就好。 考虑到Adagrad学习率减小的速度未免太快了，我们可以考虑它的改进， RMSprop (root mean square proportion) ，注意它是另一个算法Adadelta的特例，不过在本节我们不会讨论Adadelta，有兴趣的读者可以自己去寻找参考资料。 RMSprop 参考文献 提出该算法的文章，可以在这里参考： Overview of mini-batch gradient descent 记学习率为 \\epsilon \\epsilon ，小量 \\delta \\delta ，衰减参数 \\rho \\rho ，初始化学习率参数对角矩阵为 \\mathbf{r} = \\mathrm{diag}(\\mathbf{0}) \\mathbf{r} = \\mathrm{diag}(\\mathbf{0}) ，则在每次迭代中 随机抽取（或从随机排列的数据集中按顺序抽取）m个样本 (\\mathbf{x}_k,~\\mathbf{y}_k) (\\mathbf{x}_k,~\\mathbf{y}_k) ，称这m个样本为一个batch； 计算梯度 \\mathbf{g} = \\frac{1}{m} \\nabla_{\\boldsymbol{\\Theta}} \\sum\\limits_{k=1}^m \\mathcal{L} \\left( \\mathbf{y}_k,~ \\mathcal{D}_{\\boldsymbol{\\Theta}} (\\mathbf{x}_k) \\right) \\mathbf{g} = \\frac{1}{m} \\nabla_{\\boldsymbol{\\Theta}} \\sum\\limits_{k=1}^m \\mathcal{L} \\left( \\mathbf{y}_k,~ \\mathcal{D}_{\\boldsymbol{\\Theta}} (\\mathbf{x}_k) \\right) ； 更新学习率为： \\mathbf{r} \\leftarrow \\rho \\mathbf{r} + (1 - \\rho) \\mathrm{diag}(\\mathbf{g})^2 \\mathbf{r} \\leftarrow \\rho \\mathbf{r} + (1 - \\rho) \\mathrm{diag}(\\mathbf{g})^2 ； 更新参数 \\boldsymbol{\\Theta} \\leftarrow \\boldsymbol{\\Theta} - \\dfrac{\\epsilon}{\\delta + \\sqrt{\\mathbf{r}}} \\mathbf{g} \\boldsymbol{\\Theta} \\leftarrow \\boldsymbol{\\Theta} - \\dfrac{\\epsilon}{\\delta + \\sqrt{\\mathbf{r}}} \\mathbf{g} 。 和上一个算法相比，它唯一的改变就是引入了一个衰减参数 \\rho \\rho ，以指数衰减将之前收集的学习率遗忘。如此就可以控制指数过大的问题，这个trick真是令人一言难尽。但是有趣的是，实际经验中，这个方法真的是卓有成效，是现在常用的神经网络优化算法之一。 最后让我们来介绍当前最实用的算法（之一）， Adam (adaptive momentum estimation) 。顾名思义，它的基本原理是基于对动量的可变估计。实际上，在上一节的Project中，我们选用的优化器就是Adam，Tensorflow的官方教程中，也将Adam作为默认推荐的优化器。 Adam 参考文献 提出该算法的文章，可以在这里参考： Adam: a Method for Stochastic Optimization 特别需要注意的是，Adam的收敛性证明已经被后来者推翻，指出其中存在一个错误。改正后的版本称为AMSGrad，Tensorflow的Keras API支持我们在设置Adam的时候开启AMSGrad模式。关于AMSGrad，我们不在此展开讨论，有兴趣的读者可以参考： On the Convergence of Adam and Beyond 记 k k 为迭代次数，学习率为 \\epsilon \\epsilon ，小量 \\delta \\delta ，衰减参数 \\rho_1,~\\rho_2 \\rho_1,~\\rho_2 ，初始化动量为 \\mathbf{s} = \\mathbf{0} \\mathbf{s} = \\mathbf{0} ，学习率参数对角矩阵为 \\mathbf{r} = \\mathrm{diag}(\\mathbf{0}) \\mathbf{r} = \\mathrm{diag}(\\mathbf{0}) ，则在每次迭代中 随机抽取（或从随机排列的数据集中按顺序抽取）m个样本 (\\mathbf{x}_k,~\\mathbf{y}_k) (\\mathbf{x}_k,~\\mathbf{y}_k) ，称这m个样本为一个batch； 计算梯度 \\mathbf{g} = \\frac{1}{m} \\nabla_{\\boldsymbol{\\Theta}} \\sum\\limits_{k=1}^m \\mathcal{L} \\left( \\mathbf{y}_k,~ \\mathcal{D}_{\\boldsymbol{\\Theta}} (\\mathbf{x}_k) \\right) \\mathbf{g} = \\frac{1}{m} \\nabla_{\\boldsymbol{\\Theta}} \\sum\\limits_{k=1}^m \\mathcal{L} \\left( \\mathbf{y}_k,~ \\mathcal{D}_{\\boldsymbol{\\Theta}} (\\mathbf{x}_k) \\right) ； 更新动量为： \\mathbf{s} \\leftarrow \\rho_1 \\mathbf{s} + (1 - \\rho_1) \\mathbf{g} \\mathbf{s} \\leftarrow \\rho_1 \\mathbf{s} + (1 - \\rho_1) \\mathbf{g} ； 更新学习率为： \\mathbf{r} \\leftarrow \\rho_2 \\mathbf{r} + (1 - \\rho_2) \\mathrm{diag}(\\mathbf{g})^2 \\mathbf{r} \\leftarrow \\rho_2 \\mathbf{r} + (1 - \\rho_2) \\mathrm{diag}(\\mathbf{g})^2 ； 调整参数大小： \\hat{\\mathbf{s}} \\leftarrow \\dfrac{\\mathbf{s}}{1 - \\rho_1^k} \\hat{\\mathbf{s}} \\leftarrow \\dfrac{\\mathbf{s}}{1 - \\rho_1^k} , \\hat{\\mathbf{r}} \\leftarrow \\dfrac{\\mathbf{r}}{1 - \\rho_2^k} \\hat{\\mathbf{r}} \\leftarrow \\dfrac{\\mathbf{r}}{1 - \\rho_2^k} ； 更新参数 \\boldsymbol{\\Theta} \\leftarrow \\boldsymbol{\\Theta} - \\epsilon \\dfrac{ \\hat{\\mathbf{s}} }{\\delta + \\sqrt{\\hat{\\mathbf{r}}}} \\boldsymbol{\\Theta} \\leftarrow \\boldsymbol{\\Theta} - \\epsilon \\dfrac{ \\hat{\\mathbf{s}} }{\\delta + \\sqrt{\\hat{\\mathbf{r}}}} 。 Adam不仅估计了学习率的可变性，还引入了可变的动量。这是迄今为止，我们见到的第一个将动量和可变学习率结合起来的算法。我们当然期望它能带来双份的 快乐 好处，可是…… 为什么会这样呢？ ，已经有文献指出，Adam存在原理上的失误，并提出了改正的算法AMSGrad，这正是我们未来将要在专题中讨论的内容。现在读者只需要知道，Adam的思路其实就是结合动量和可变学习率就行了。 注意 无论是我们没提到的Adadelta还是提到的Adam，其实都引入了动量的概念。那么一个自然而然的idea就是，使用Nesterov动量代替普通的动量。当然，毫无意外的是，已经有人做过了。例如，Adam的Nesterov动量版本叫Nadam，有兴趣的读者不妨去了解一下。 解线性回归问题 ¶ 代码规范 ¶ 重申我们之前提到的，我们建议一个完整的工程应当包括 . ├─ data/ # where we store our data │ └─ ... ├─ tools.py # codes for post-processing and analyzing records. ├─ extension.py # codes for extending the tensorflow model. ├─ dparser.py # data parser └─ main.py # main module where we define our tensorflow model. 除了保存数据的文件夹，我们应当有三个子模块。其中 tool : 用来处理、分析生成的数据，通常与Tensorflow无关； extension : 用来扩展tensorflow，例如在这里自定义网络层和操作符； dparser : 数据处理器，用来读取并预处理送入网络的数据； main : 主模块，只定义跟Tensorflow模型有关的内容，需要引用 extension 和 dparser 。 视情况可以灵活调整结构，但建议将定义Tensorflow模型的代码单独放在主模块里，和其他外围代码分离。 在上一节中，我们没有定义 tool.py 和 extension.py ，这是因为我们的工程还很简单，不需要扩展Tensoflow模型，也不需要专门的数据处理代码。相应地，我们把数据的后处理代码直接集成在了主模块 lin-cls.py 里。在这一节，我们要开始构造一个真正严格按照这四部分分离的工程，并且在接下来的各个例子实现里，都会遵照这个模式，读者应当熟悉类似我们所推荐的、这样一个高度分离的模块化设计的思路。 扩展模块 ¶ 此次是我们第一次写扩展模块，编写扩展模块的目的是，提供一个更复杂的支持库，以便我们能轻松地使用Tensorflow。因此，扩展模块编写地原则应当包括： 可适用性 : 它应当与我们某一个Project完全无关，就像我们自己基于Tensorflow编写一个扩展库一样，以后我们在任何项目都应该可以使用同一个扩展模块文件； 低依赖性 : 它应当最低限度地需要依赖库。 tensorflow 库本身当然是需要的，而 numpy ， matplotlib 甚或是读写数据的模块，都不宜出现在这里，以确保我们的扩展模块被其他任何模块调用时，依赖关系都是树状的； 强一致性 : 它的使用风格，应当尽可能和Tensorflow本身的API一致，使得一个之前不怎么接触它的人，也能快速上手。 在这个工程里，我们扩展的内容其实很简单，就是允许模型调用一个指定的优化器。让我们直接看以下代码： extension.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class AdvNetworkBase : ''' Base object of the advanced network APIs. ''' @staticmethod def optimizer ( name = 'adam' , l_rate = 0.01 , decay = 0.0 ): ''' Define the optimizer by default parameters except learning rate. Note that most of optimizers do not suggest users to modify their speically designed parameters. name: the name of optimizer (default='adam') (available: 'adam', 'amsgrad', 'adamax', 'nadam', 'adadelta', 'rms', 'adagrad', 'nmoment', 'sgd') l_rate: learning rate (default=0.01) decay: decay ratio ('adadeltaDA' do not support this option) ''' name = name . casefold () if name == 'adam' : return tf . keras . optimizers . Adam ( l_rate , decay = decay ) elif name == 'amsgrad' : return tf . keras . optimizers . Adam ( l_rate , decay = decay , amsgrad = True ) elif name == 'adamax' : return tf . keras . optimizers . Adamax ( l_rate , decay = decay ) elif name == 'nadam' : return tf . keras . optimizers . Nadam ( l_rate , schedule_decay = decay ) elif name == 'adadelta' : return tf . keras . optimizers . Adadelta ( l_rate , decay = decay ) elif name == 'rms' : return tf . keras . optimizers . RMSprop ( l_rate , decay = decay ) elif name == 'adagrad' : return tf . keras . optimizers . Adagrad ( l_rate , decay = decay ) elif name == 'nmoment' : return tf . keras . optimizers . SGD ( lr = l_rate , momentum = 0.6 , decay = decay , nesterov = True ) else : return tf . keras . optimizers . SGD ( l_rate , decay = decay ) 我们在这里几乎罗列了所有可能使用的优化器，全部来自Keras API。但我们也可以使用Tensorflow旧版API定义的优化器。目前Tensorflow允许使用两种API中的任意一种来定义，但是实验发现，旧版API系列的优化器要么已经在Keras中能找到对应的版本，要么就水土不服，无法正常调用。因此，上文提到的几种优化器，我们基本上全部在这里用Keras API定义出来。 优化器的参数尽可能应当选择默认参数，并且应当封装起来，不宜让用户自行操作。尤其是Adadelta，Adam这些优化器的 \\rho \\rho 变量，在 Keras文档 中，建议我们遵从默认值。 任何继承该类的子类，都可以通过 self . optimizer ( self . optimizerName , self . learning_rate ) 来将封装好的优化器API调用到主模块中。 项目选项：argparse ¶ 本节将第一次引入 argparse 模块。该模块是python本身具有的原生模块，用来给代码提供启动选项。作为一个完整的Project，我们不希望为了调整参数而频繁地修改代码，因此 argparse 对我们是不可或缺的。在后面所有的Project中，我们都会通过 argparse 模块支持项目选项。 argparse 的官方文档可以在此查阅： argparse — Parser for command-line options, arguments and sub-commands 调用 argparse 的一开始，我们需要定义如下内容： Codes 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import argparse def str2bool ( v ): if v . casefold () in ( 'yes' , 'true' , 't' , 'y' , '1' ): return True elif v . casefold () in ( 'no' , 'false' , 'f' , 'n' , '0' ): return False else : raise argparse . ArgumentTypeError ( 'Unsupported value encountered.' ) parser = argparse . ArgumentParser ( description = 'A demo for linear regression.' , formatter_class = argparse . ArgumentDefaultsHelpFormatter ) Output usage: tools.py [ -h ] A demo for linear regression. optional arguments: -h, --help show this help message and exit 我们首先定义了 str2bool 函数，用来支持用户提供布尔类型的选项；之后，我们初始化了 parser ，一般地初始化 parser 时，我们主要定义三个参数： description : 项目描述，展示在参数用法之前的一段字符串； formatter_class : 格式化器 ，我们一般调用的都是 ArgumentDefaultsHelpFormatter ，因为它能支持自动换行，并在每个参数用法后展示该参数的默认值； epilog : 后记 ，这一段说明文字出现在所有参数用法之后。我们一般不太需要这个功能，但是有时候我们可以使用该功能提供一些用法范例给用户。 现在，我们来介绍几种典型的 argparse 可以提供的参数类型。 字符串选项 1 2 3 4 5 6 7 parser . add_argument ( '-o' , '--optimizer' , default = 'adam' , metavar = 'str' , help = ''' \\ The optimizer we use to train the model (available: 'adam', 'amsgrad', 'adamax', 'nadam', 'adadelta', 'rms', 'adagrad', 'nmoment', 'sgd') ''' ) 在这里我们定义了一个字符串选项，这是最常用的一类选项。用户可以像 python codes.py -o amsgrad 或者 python codes.py --optimizer amsgrad 一样，通过添加参数来覆盖默认值(定义在 default 字段下)。 数值选项 1 2 3 4 5 6 parser . add_argument ( '-lr' , '--learningRate' , default = 0.001 , type = float , metavar = 'float' , help = ''' \\ The learning rate for training the model. ''' ) 这里添加的参数类型是一个浮点数，虽然用户在输入参数的时候输入的是一个字符串，但 metavar 字段告诉了用户应该输入浮点数， type 决定了用户输入的字符串会被自动转换为浮点数。类似地，将两个字段的 float 改为 int ，我们就能提供一个整数作为参数选项 布尔选项 1 2 3 4 5 6 parser . add_argument ( '-if' , '--importFlag' , type = str2bool , nargs = '?' , const = True , default = False , metavar = 'bool' , help = ''' \\ The flag of importing pre-trained model. ''' ) 这里添加的是一个二值选项，它的默认值是 False ，用户可以通过输入 ( 'yes' , 'true' , 't' , 'y' , '1' ) 中的任何一个来指定该选项为真，或通过 ( 'no' , 'false' , 'f' , 'n' , '0' ) 中的任何一个指定该选项为假，不区分大小写。该功能由我们之前定义的 str2bool 函数提供。 特别值得注意的是，这个布尔选项还可以有这样的用法，例如： python codes.py -if -o amsgrad 我们如果指派了 -if ，在不指定它任何值的情况下，该选项就会被开启（值为真）了；如果我们去掉这一行的 -if ，则该选项关闭（值为假）。 多值选项 1 2 3 4 5 6 parser . add_argument ( '-ml' , '--mergedLabel' , default = None , type = int , nargs = '+' , metavar = 'int' , help = ''' \\ The merged label settings. ''' ) 上面的设置提供了一个可以输入任意多个 int 型值的选项，用法如下： python codes.py -ml 1 3 4 0 2 -o amsgrad 上述的输入会被解析成一个值为 [ 1 , 3 , 4 , 0 , 2 ] 的列表。当然，我们也可以输入任意多的值，但是特别值得注意的是，由于在 nargs 字段指定了 + ，一旦我们指派该选项，就要至少输入一个值方可。 上面的几种范例，并不是每一种都需要用在Project中。实际设置选项的时候，应当参照实际情况来处理。例如，本例中，就只使用 字符串选项 和 数值选项 两种。更多关于 add_argument 的用法，请参阅官方文档： argparse — add_argument() 在所有参数都设置好后，调用 args = parser . parse_args () 即可使参数选项生效。用户输入的参数选项将返回到 args 中，例如，如果用户制定了 -o ( --optimizer )，那么我们可以调用 args.optimizer 来取出该字段的值。 数据生成 ¶ 本节的数据也是自动生成出来的。参考上一节的数据生成器，重新定义数据生成类的迭代器： dparser.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class TestDataRegSet ( TestDataSet ): ''' A generator of the data set for testing the linear regression model. ''' def next_train ( self ): ''' Get the next train batch: (x, y) ''' x = self . s_x * ( np . random . random ([ self . batch , self . len_x ]) - 0.5 ) y = np . matmul ( x , self . A ) + self . c if self . noise > 1e-3 : y = y + np . random . normal ( 0 , self . noise , size = y . shape ) else : np . random . normal ( 0 , self . noise , size = y . shape ) return x , y 提示 这里我们在没有噪声的情况下，仍然调用随机噪声函数，这是为了确保噪声函数被调用，使得随机数无论开关噪声，都能保持一致性。 该生成器同样是输入一组 \\mathbf{A},~\\mathbf{c} \\mathbf{A},~\\mathbf{c} ，以及相关配置，之后就可以通过 迭代器 (iterator) 或 方法 (method) 随机生成数据。与上一节不同的是，我们在本节可以尝试更进一步，令 \\mathbf{A} \\mathbf{A} 的 SVD分解 写作如下形式 \\begin{align} \\mathbf{A} = \\mathbf{U} \\boldsymbol{\\Sigma} \\mathbf{V}^T. \\end{align} 其中， \\boldsymbol{\\Sigma} \\boldsymbol{\\Sigma} 是一个对角矩阵，对角线上的元素顺次排列，对应为矩阵 \\mathbf{A} \\mathbf{A} 的各个特征值。Numpy的库已经集成了 SVD分解 。我们知道，一个 M \\times N M \\times N 的矩阵经过SVD分解后，应当有 \\mathbf{U}_{M \\times M} \\mathbf{U}_{M \\times M} 和 \\mathbf{V}^T_{N \\times N} \\mathbf{V}^T_{N \\times N} 两个方阵。故而，矩阵 \\boldsymbol{\\Sigma}_{M \\times N} \\boldsymbol{\\Sigma}_{M \\times N} 并非方阵。由于它只有对角线上有元素，所以必定有多出来的空行或空列。因此，若我们设 K = \\min(M,~N) K = \\min(M,~N) ，则我们可以知道，SVD分解其实不需要矩阵 \\mathbf{U} \\mathbf{U} 和 \\mathbf{V}^T \\mathbf{V}^T 两个方阵都是方阵，因为当我们取矩阵 \\boldsymbol{\\Sigma}_{K \\times K} \\boldsymbol{\\Sigma}_{K \\times K} 这一对角部分后，可以只取部分行/列构成的矩阵 \\mathbf{U}_{M \\times K} \\mathbf{U}_{M \\times K} 和 \\mathbf{V}^T_{K \\times N} \\mathbf{V}^T_{K \\times N} 。这相当于我们略去了 \\boldsymbol{\\Sigma} \\boldsymbol{\\Sigma} 上的空行/空列，但是SVD分解仍然能保证恢复出原矩阵来。 在本例中，我们保留 \\boldsymbol{\\Sigma} \\boldsymbol{\\Sigma} 中的前 r r 个特征值，其后的特征值都丢弃，我们把这样的做法称为矩阵的低秩近似，于是有 dparser.py 1 2 3 4 5 6 7 8 9 10 11 12 def gen_lowrank ( A , r ): ''' Generate a low rank approximation to matrix A. A: input matrix. r: output rank. ''' sze = A . shape r_min = np . amin ( sze ) assert r <= r_min and r > 0 , 'r should in the range of [1, {0}]' . format ( r_min ) u , s , v = np . linalg . svd ( A , full_matrices = False ) s = np . diag ( s [: r ]) return np . matmul ( np . matmul ( u [:,: r ], s ), v [: r ,:]) 一个低秩近似的矩阵，其定义的仿射变换 (3) (3) 满足不同的 \\mathbf{x} \\mathbf{x} 对应同一个值 \\mathbf{y} \\mathbf{y} ；反之， \\mathbf{y} \\mathbf{y} 将会对应多个不同的解 \\mathbf{x} \\mathbf{x} 。如果我们训练的线性分类器模拟的是 (3) (3) 的逆过程，可能我们会无法模拟出合适的解来；但是，由于我们定义的 (4) (4) 仍是在拟合正过程，故而我们仍然可以把这个问题看成是有解的。在后续的内容中，我们会适当地讨论当问题 解不唯一 时，我们可以进行哪些工作来处理这类问题。 接下来，我们即可测试低秩近似的效果， dparser.py 1 2 3 4 5 6 7 8 9 def test_lowrank (): A = np . random . normal ( 0 , 10 , [ 10 , 6 ]) for r in range ( 1 , 7 ): A_ = gen_lowrank ( A , r ) RMS = np . sqrt ( np . mean ( np . square ( A - A_ ))) R = np . linalg . matrix_rank ( A_ ) print ( 'Rank = {0}, RMS={1}' . format ( R , RMS )) test_lowrank () Output Rank = 1 , RMS = 6.8600432267325955 Rank = 2 , RMS = 4.677152938185369 Rank = 3 , RMS = 3.216810970685858 Rank = 4 , RMS = 1.8380598782932136 Rank = 5 , RMS = 0.9348520972791058 Rank = 6 , RMS = 9.736224609164252e-15 可见，对于一个标准差为10的矩阵，低秩近似的残差仍然是不超过随机高斯矩阵本身的标准差的。这里的秩是我们在调用低秩近似函数后，使用 np.linalg.matrix_rank 测量的结果。 定义类模型 ¶ 类模型 (Model class) ，在官方文档中也称为函数式API，是Tensorflow-Keras的用户大多数情况下应当使用的模型。它支持一些灵活的操作，使得我们可以 多输入多输出 : 类模型的输入和输出层，都是通过函数定义的。类模型在构建的时候，只需要给定输入和输出即可； 跨层短接 : 由于类模型的各层都由函数定义，可以轻松将不同的层连接起来，通常通过 融合层 完成这一工作； 多优化器 : 可以通过复用同一层对应的对象，构建多个不同的类模型，并分别对它们使用不同的训练数据、损失函数、优化器，以实现多优化目标。 一个顺序模型大致可以描述为下图的模式： graph LR st1(输<br/>入<br/>1) --> l11[层<br/>1-1] l11 --> l21[层<br/>1-2] l21 --> l31[层<br/>1-3] l31 --> ldots1[层<br/>...] st2(输<br/>入<br/>2) --> l12[层<br/>2-1] l12 --> l22[层<br/>2-2] l22 --> l32[层<br/>2-3] l32 --> ldots2[层<br/>...] ldots1 --> l3[层<br/>3] ldots2 --> l3 l3 --> l4[层<br/>4] l4 --> ed1(输<br/>出<br/>1) l4 --> ed2(输<br/>出<br/>2) l22 --> ed3(输出3) l21 --> l3 classDef styStart fill:#FAE6A9,stroke:#BA9132; class st1,ed1,st2,ed2,ed3 styStart 在本节中，尽管我们开始使用类模型，但我们定义的仍然是一个单线路的线性回归模型，换言之，这样的模型完全可以通过 顺序模型 实现出来。我们从这一节开始，不再使用顺序模型，其一，是因为顺序模型都可以写成类模型的形式，其二，是希望读者能够熟悉、灵活运用类模型的优势。 我们定义一个继承自 extension.py 的类， class LinRegHandle ( ext . AdvNetworkBase ): 。与上一节的情况相若，这里我们不再赘述需要定义哪些方法。并且，我们也不会介绍一些改动不大、或者不重要的方法，详情请读者参阅源码。 初始化方法 ¶ 首先，定义初始化方法： lin-cls.py: class LinRegHandle 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def __init__ ( self , learning_rate = 0.01 , epoch = 10 , steppe = 30 , optimizerName = 'adam' ): ''' Initialization and pass fixed parameters. learning_rate: the learning rate for optimizer. epoch: training epochs. steppe: steps per epoch optimizerName: the name of optimizer (available: 'adam', 'amsgrad', 'adamax', 'nadam', 'adadelta', 'rms', 'adagrad', 'nmoment', 'sgd') ''' self . lr = learning_rate self . epoch = epoch self . steppe = steppe self . optimizerName = optimizerName 与上一节相比，这里我们增加了一个参数， opmizerName ，用来指定我们选用的优化器名称，默认值为 adam 。 构造方法 ¶ 接下来定义网络构造 lin-cls.py: class LinRegHandle 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 def construct ( self ): ''' Construct a linear model and set the optimizer as Adam ''' # Construction input = tf . keras . Input ( shape = ( INPUT_SHAPE ,), dtype = tf . float32 ) dense1 = tf . keras . layers . Dense ( LABEL_SHAPE , use_bias = True , kernel_initializer = tf . keras . initializers . RandomNormal ( 0.0 , stddev = 10.0 ), bias_initializer = tf . keras . initializers . Constant ( 2 ), activation = None , name = 'dense1' )( input ) self . model = tf . keras . Model ( inputs = input , outputs = dense1 ) # Set optimizer self . model . compile ( optimizer = self . optimizer ( self . optimizerName , self . lr ), loss = tf . keras . losses . MeanSquaredError (), metrics = [ self . relation ] ) @staticmethod def relation ( y_true , y_pred ): m_y_true = tf . keras . backend . mean ( y_true , axis = 0 ) m_y_pred = tf . keras . backend . mean ( y_pred , axis = 0 ) s_y_true = tf . keras . backend . sqrt ( tf . keras . backend . mean ( tf . keras . backend . square ( y_true ), axis = 0 ) - tf . keras . backend . square ( m_y_true )) s_y_pred = tf . keras . backend . sqrt ( tf . keras . backend . mean ( tf . keras . backend . square ( y_pred ), axis = 0 ) - tf . keras . backend . square ( m_y_pred )) return tf . keras . backend . mean (( tf . keras . backend . mean ( y_true * y_pred , axis = 0 ) - m_y_true * m_y_pred ) / ( s_y_true * s_y_pred )) 使用类模型时，我们每定义一层，都调用对应的网络层函数，并返回层的输出结果。这就是为何它又叫“函数式API”。我们直接使用均方误差作为我们的损失函数，同时，我们还自行定义了一个评价函数， 皮尔森相关系数 ，该系数专门用来反映两组数据之间是否线性相关，上文我们已经叙述过它的定义。 注意 理想情况下，相关系数应当使用整个数据集来求取。但实际情况下做不到这一点，因此我们求取的相关系数只能看作是一个通过batch得到的估计。故此，我们可以发现，求相关系数要求我们每次输入的样本至少有2个。样本数目越多，相关系数的估计越准确。 注意 从式中可以发现，我们定义的皮尔森相关系数时，完全使用的时Tensorflow-Keras API，因此它当然可以用作我们的训练损失函数。但实际情况下，我们并不使用它。考虑一个反例，当两组数据的分布之间唯一的不同只是均值时，亦即 \\mathbf{y}_2 = \\mathbf{y}_1 + C \\mathbf{y}_2 = \\mathbf{y}_1 + C ，这种情况下皮尔森相关系数仍然为1。虽然我们可以考虑用 余弦相似度函数 (Cosine similarity) 来代替它，但经验显示，余弦相似度最大化到一定程度以后，其对应的均方误差反而上升。考虑另一个反例， \\mathbf{y}_2 = \\alpha \\mathbf{y}_1 \\mathbf{y}_2 = \\alpha \\mathbf{y}_1 ，显然 \\mathbf{y}_1 \\mathbf{y}_1 和 \\mathbf{y}_2 \\mathbf{y}_2 的余弦相似度是1。因此，实际应用中，无论是皮尔森相关系数还是余弦相似度，都适合用作评价函数而不是损失函数。 与上一节不同的是，由于这是一个线性回归器，我们不给它提供激活函数。 训练和测试方法 ¶ 类模型的 compile 、 fit 、 evaluate 、 predict 等API与顺序模型完全相同，详情请查看： Model类 (函数式API) - Keras中文文档 调试 ¶ 上一节中，我们每次训练后，就当场显示分析结果。在本节中，我们会“再进一步”。即使用 tools.py 专门进行实验结果分析（后处理）。相对地，训练后，我们会讲 原始输出 (raw output) 保存到文件里。这是一种编写代码的思想，是为了便于我们批量分析测试数据。在后面的Project中，我们会看到，我们既会编写当场显示分析结果的测试代码，也会编写保存输出后使用 tools.py 分析的代码。究竟使用哪种方式分析数据，视具体情况而定。一般地，测试少量数据时，我们当场分析；批量测试大量数据时，或者需要比较不同选项（例如不同噪声）对结果的影响时，我们在 tools.py 中分析。本实验的情况属于后者。 使实验结果可复现 ¶ 由于我们本次实验需要对比不同设置下的回归器性能，我们希望随机生成的矩阵 \\mathbf{A} \\mathbf{A} ，向量 \\mathbf{c} \\mathbf{c} 应当可复现；换言之，我们希望我们的结果是可复现的。 关于这一问题，Keras的文档给出的建议可以在这里查阅： 如何在 Keras 开发过程中获取可复现的结果？ - Keras中文文档 我们只需要使 argparse 添加一个选项 -sd ( --seed )，并通过该选项控制： 1 2 3 4 5 6 def setSeed ( seed ): np . random . seed ( seed ) random . seed ( seed + 12345 ) tf . set_random_seed ( seed + 1234 ) if args . seed is not None : # Set seed for reproductable results setSeed ( args . seed ) 其中， np.random.seed ， random.seed ， tf.set_random_seed 分别来自Numpy，python原生的random库，以及Tensorflow。将这三个库的 随机种子 (seed) 设为三个不同的值，即可保证我们每次指定 -sd 后，从程序运行开始，得到的所有随机数都是固定的随机序列。当然， Keras文档 指出，即使如此，我们还不能保证我们的结果完完全全是可复现的。因为多线程算法并发的先后顺序随机性、GPU运算带来的先后顺序随机性等干扰因素，均会导致我们每次得到的结果有细微的偏差。但这些因素对于本实验验证可复现数据的要求几乎没有什么影响。 使实验代码保存输出 ¶ 首先，训练网络。我们同样随机生成 \\mathbf{x} \\mapsto \\mathbf{y}:~\\mathbb{R}^{10} \\mapsto \\mathbb{R}^6 \\mathbf{x} \\mapsto \\mathbf{y}:~\\mathbb{R}^{10} \\mapsto \\mathbb{R}^6 的仿射变换，将该变换中的线性变换矩阵采用秩为4的低秩近似，并且设置好数据集，给定噪声扰动由用户决定。默认值下，噪声为 \\boldsymbol{\\varepsilon} \\sim \\mathcal{N}(0,10)^6 \\boldsymbol{\\varepsilon} \\sim \\mathcal{N}(0,10)^6 ，epoch为20个，每个epoch迭代500次，每次馈入32个样本构成的batch。我们将上一节的主函数输出部分修改成如下形式，并进行不加参数的调试： lin-cls.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 # Initialization A = dp . gen_lowrank ( np . random . normal ( 0 , 10 , [ INPUT_SHAPE , LABEL_SHAPE ]), RANK ) c = np . random . uniform ( 1 , 3 , [ 1 , LABEL_SHAPE ]) dataSet = dp . TestDataRegSet ( 10 , A , c ) dataSet . config ( noise = args . noise ) # Generate a group of testing samples. if args . seed is not None : setSeed ( args . seed + 1000 ) dataSet . config ( batch = args . testBatchNum ) x , y = next ( dataSet ) # Set the data set for training. dataSet . config ( batch = args . trainBatchNum ) # Construct the model and train it. h = LinRegHandle ( learning_rate = args . learningRate , epoch = args . epoch , steppe = args . steppe , optimizerName = args . optimizer ) h . construct () print ( 'Begin to train:' ) print ( '---------------' ) record = h . train ( iter ( dataSet )) # Check the testing results print ( 'Begin to test:' ) print ( '---------------' ) yp , loss_p , corr_p = h . test ( x , y ) # Check the regressed values W , b = h . model . get_layer ( name = 'dense1' ) . get_weights () # Save if args . outputData is not None : np . savez_compressed ( args . outputData , epoch = record . epoch , loss = record . history [ 'loss' ], corr = record . history [ 'relation' ], test_x = x , test_y = y , pred_y = yp , pred_loss = loss_p , pred_corr = corr_p , W = W , b = b , A = A , c = c ) Output Begin to train: --------------- Epoch 1 /20 500 /500 [==============================] - 1s 2ms/step - loss: 29084 .6994 - relation: 0 .3472 Epoch 2 /20 500 /500 [==============================] - 1s 2ms/step - loss: 15669 .9579 - relation: 0 .5597 Epoch 3 /20 500 /500 [==============================] - 1s 2ms/step - loss: 8145 .8705 - relation: 0 .7134 Epoch 4 /20 500 /500 [==============================] - 1s 2ms/step - loss: 4000 .0838 - relation: 0 .8130 Epoch 5 /20 500 /500 [==============================] - 1s 2ms/step - loss: 1856 .1477 - relation: 0 .8801 Epoch 6 /20 500 /500 [==============================] - 1s 2ms/step - loss: 799 .4556 - relation: 0 .9354 Epoch 7 /20 500 /500 [==============================] - 1s 2ms/step - loss: 336 .8600 - relation: 0 .9700 Epoch 8 /20 500 /500 [==============================] - 1s 2ms/step - loss: 166 .5899 - relation: 0 .9813 Epoch 9 /20 500 /500 [==============================] - 1s 2ms/step - loss: 113 .2465 - relation: 0 .9831 Epoch 10 /20 500 /500 [==============================] - 1s 2ms/step - loss: 102 .0431 - relation: 0 .9834 Epoch 11 /20 500 /500 [==============================] - 1s 2ms/step - loss: 99 .6678 - relation: 0 .9838 Epoch 12 /20 500 /500 [==============================] - 1s 2ms/step - loss: 99 .8547 - relation: 0 .9833 Epoch 13 /20 500 /500 [==============================] - 1s 2ms/step - loss: 100 .1278 - relation: 0 .9834 Epoch 14 /20 500 /500 [==============================] - 1s 2ms/step - loss: 99 .6048 - relation: 0 .9835 Epoch 15 /20 500 /500 [==============================] - 1s 2ms/step - loss: 101 .1930 - relation: 0 .9832 Epoch 16 /20 500 /500 [==============================] - 1s 2ms/step - loss: 101 .6636 - relation: 0 .9835 Epoch 17 /20 500 /500 [==============================] - 1s 2ms/step - loss: 100 .6665 - relation: 0 .9834 Epoch 18 /20 500 /500 [==============================] - 1s 2ms/step - loss: 101 .2459 - relation: 0 .9832 Epoch 19 /20 500 /500 [==============================] - 1s 2ms/step - loss: 100 .9701 - relation: 0 .9836 Epoch 20 /20 500 /500 [==============================] - 1s 2ms/step - loss: 100 .7719 - relation: 0 .9836 Begin to test: --------------- 10 /10 [==============================] - 0s 5ms/sample - loss: 94 .8883 - relation: 0 .9897 Evaluated loss ( losses.MeanSquaredError ) = 94 .88829040527344 Evaluated metric ( Pearson ' s correlation ) = 0 .9897396 以上结果是不加任何参数的前提下，直接以默认参数运行程序得到的。结果显明，MSE最后收敛在100左右，因为我们馈入的label添加了标准差为10的白噪声，对应的方差为100。可知，实验结果与预期一致。另一方面，我们可以看到，相关系数在这里可以充当类似准确度的作用，考虑到我们默认的噪声为10，这一相关系数的收敛结果是符合我们的预期的。 我们还可以注意到，这段代码中，生成测试集的代码被提前了，这是为了确保每次运行程序，只要指定了种子，生成的测试集总是一致的。 现在，我们可以导出生成数据了，首先，我们改变不同的优化器，其他参数全部一致，例如，学习率均为0.01（Adadelta除外，其初始参数一般推荐为1.0）。调用代码时的参数设置如下 python lin-reg.py -e 25 -sd 1 -do test/algorithm/ { optimizer } -o { optimizer } 其中我们用 {optimizer} 来指代我们选用的优化算法。同时，我们固定测试的epoch数量为25，这是因为有些算法的收敛速度不足以保证20个epoch收敛。 接下来，我们固定优化器为Adam，改变不同的噪声，分别令标准差为0, 1, 5, 10, 50, 100，产生多组结果。 python lin-reg.py -sd 1 -do test/noise/ { noise } -is { noise } 在 tools.py 中分析比较结果 ¶ 首先，在 tools.py 中定义数据解析函数 tools.py 1 2 3 4 5 6 7 8 9 10 11 12 def parseData ( path , keys ): keys_list = dict (( k , []) for k in keys ) name_list = [] for f in os . scandir ( path ): if f . is_file (): name , _ = os . path . splitext ( f . name ) name_list . append ( name . replace ( '_' , ' ' )) data = np . load ( os . path . join ( path , f . name )) for key in keys : keys_list [ key ] . append ( data [ key ]) epoch = data [ 'epoch' ] return name_list , epoch , keys_list 该函数的作用是，给定保存输出文件的文件夹路径，能够自动读取文件夹下所有数据文件，并将不同文件的结果列在列表的不同元素中。 keys 关键字能帮助我们指派我们关心的数据字段。 接下来，我们通过如下代码，对比不同优化器条件下的损失函数和测度函数，对比不同噪声条件下的损失函数和测度函数，输出的曲线反映了对训练过程的跟踪。 tools.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def showCurves ( path , prefix = '{0}' , converter = str ): ''' Show curves from different tests in a same folder. ''' name_list , epoch , keys_list = parseData ( path , [ 'loss' , 'corr' ]) loss_list = keys_list [ 'loss' ] corr_list = keys_list [ 'corr' ] if ( not loss_list ) or ( not corr_list ): raise FileExistsError ( 'No data found, could not draw curves.' ) for i in range ( len ( loss_list )): plt . semilogy ( loss_list [ i ], label = prefix . format ( converter ( name_list [ i ])), marker = MARKERS [ i % 9 ], markevery = 3 ) plt . legend () plt . xlabel ( 'epoch' ), plt . ylabel ( 'MSE' ) plt . gcf () . set_size_inches ( 5 , 5 ), plt . tight_layout (), plt . show () for i in range ( len ( corr_list )): plt . plot ( corr_list [ i ], label = prefix . format ( converter ( name_list [ i ])), marker = MARKERS [ i % 9 ], markevery = 3 ) plt . legend () plt . xlabel ( 'epoch' ), plt . ylabel ( 'Pearson \\' s correlation' ) plt . gcf () . set_size_inches ( 5 , 5 ), plt . tight_layout (), plt . show () showCurves ( './test/algorithm' ) showCurves ( './test/noise' , prefix = 'ε=N(0,{0})' , converter = int ) Output (优化器) 损失函数 (MSE) 测度函数 (相关系数) Output (噪声) 损失函数 (MSE) 测度函数 (相关系数) 可见，损失曲线反映了训练的进度，而测度曲线反映了当前的准确度。我们可以得到如下结论： 令人意外的是，SGD和Nesterov动量法收敛速度最快。这是由于这两种方法没有引入对学习率的调整。我们使用的损失函数初始点梯度非常大，这使得简单的方法，形如SGD和动量法在一开头就取得了非常迅速的下降；而对那些需要调整学习率的算法而言，初始梯度在很大的情况下，会导致初始学习率被降到较小的水准。这就是为何Adagrad几乎不收敛的原因，因为一开始这一算法的学习率就被大梯度抑制到将近0的水平了，导致训练无法为继； 在调整学习率的算法里，收敛速度有 RMSprop > Adam = NAdam > Adamax = AMSgrad > Adadelta。从AMSgrad以上的这些算法都可资利用，Adadelta的原理和RMSprop几乎相同但效果相差甚巨，这是由于参数不同引起的，我们虽然将Adadelta的学习率特地设为 1.0 ，仍然远远不如RMSprop，可见一个合适的参数对算法的重要性。 噪声的输出结果并不令人意外，所有噪声条件下的MSE最后都收敛到对应的噪声方差上。 为了检查测试集的情况，我们通过以下函数来绘制比较不同样本在不同优化器、不同噪声条件下的RMSE（均方根误差）， tools.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def showBars ( path , prefix = '{0}' , converter = str , ylim = None ): ''' Show bar graphs for RMSE for each result ''' name_list , epoch , keys_list = parseData ( path , [ 'test_y' , 'pred_y' ]) #print(keys_list) ytrue_list = keys_list [ 'test_y' ] ypred_list = keys_list [ 'pred_y' ] def RMSE ( y_true , y_pred ): return np . sqrt ( np . mean ( np . square ( y_true - y_pred ), axis = 1 )) N = ytrue_list [ 0 ] . shape [ 0 ] NG = len ( ytrue_list ) for i in range ( NG ): plt . bar ([ 0.6 + j + 0.8 * i / NG + 0.4 / NG for j in range ( - 1 , 9 , 1 )], RMSE ( ytrue_list [ i ], ypred_list [ i ]), width = 0.8 / NG , label = prefix . format ( converter ( name_list [ i ]))) plt . legend ( ncol = 5 ) plt . xlabel ( 'sample' ), plt . ylabel ( 'RMSE' ) if ylim is not None : plt . ylim ([ 0 , ylim ]) plt . gcf () . set_size_inches ( 12 , 5 ), plt . tight_layout (), plt . show () showBars ( './test/algorithm' , ylim = 70 ) showBars ( './test/noise' , prefix = 'ε=N(0,{0})' , converter = int ) Output (优化器) Output (噪声) 上述结果反映了 测试结果和训练情况相仿，这是由于我们的训练集和测试机完全独立同分布； Adadelta和Adagrad还没有训练好，它们的误差明显大于其他算法。且Adagrad已经无法收敛，可见这种算法不实用。 再接下来，我们要分别展示不同测试下的输出。下面列举的所有输出由该函数所产生： tools.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 def saveResults ( path , opath , oprefix , datakeys , title = '' , xlabel = None , ylabel = None , onlyFirst = False , plot = False , prefix = ' ({0})' , converter = str ): ''' Save result graphs to a folder. ''' name_list , _ , data_list = parseData ( path , datakeys ) if plot : # show curves c_list = data_list [ 'c' ] b_list = data_list [ 'b' ] NG = len ( b_list ) for i in range ( NG ): plt . plot ( c_list [ i ] . T , label = 'c' ) plt . plot ( b_list [ i ] . T , label = 'b' ) plt . legend () plt . gca () . set_title ( title + prefix . format ( converter ( name_list [ i ]))) if xlabel is not None : plt . xlabel ( xlabel ) if ylabel is not None : plt . ylabel ( ylabel ) plt . gcf () . set_size_inches ( 5 , 5 ) if onlyFirst : formatName = '' else : formatName = name_list [ i ] . replace ( ' ' , '_' ) plt . savefig ( os . path . join ( opath , oprefix + '{0}.svg' . format ( formatName ))) plt . close ( plt . gcf ()) if onlyFirst : return else : # show images data_list = data_list [ datakeys [ 0 ]] NG = len ( data_list ) for i in range ( NG ): plt . imshow ( data_list [ i ], interpolation = 'nearest' , aspect = 'auto' ), plt . colorbar (), plt . gca () . set_title ( title + prefix . format ( converter ( name_list [ i ]))) if xlabel is not None : plt . xlabel ( xlabel ) if ylabel is not None : plt . ylabel ( ylabel ) plt . gcf () . set_size_inches ( 6 , 5 ) if onlyFirst : formatName = '' else : formatName = name_list [ i ] . replace ( ' ' , '_' ) plt . savefig ( os . path . join ( opath , oprefix + '{0}.png' . format ( formatName ))) plt . close ( plt . gcf ()) if onlyFirst : return 测试代码 1 2 3 4 5 6 7 8 9 10 11 12 13 def saveAllResults (): saveResults ( './test/algorithm' , './record/algorithm' , 'alg-A-' , [ 'A' ], title = 'A' , prefix = '' , onlyFirst = True ) saveResults ( './test/algorithm' , './record/algorithm' , 'alg-yt-' , [ 'test_y' ], title = 'True values' , prefix = '' , onlyFirst = True ) saveResults ( './test/algorithm' , './record/algorithm' , 'alg-y-' , [ 'pred_y' ], title = 'Predicted values' ) saveResults ( './test/algorithm' , './record/algorithm' , 'alg-W-' , [ 'W' ], title = 'W' ) saveResults ( './test/algorithm' , './record/algorithm' , 'alg-cb-' , [ 'c' , 'b' ], title = 'Biases' , plot = True ) saveResults ( './test/noise' , './record/noise' , 'noi-A-' , [ 'A' ], title = 'A' , prefix = '' , onlyFirst = True ) saveResults ( './test/noise' , './record/noise' , 'noi-yt-' , [ 'test_y' ], title = 'True values' , prefix = ' (ε=N(0,{0}))' , converter = int ) saveResults ( './test/noise' , './record/noise' , 'noi-y-' , [ 'pred_y' ], title = 'Predicted values' , prefix = ' (ε=N(0,{0}))' , converter = int ) saveResults ( './test/noise' , './record/noise' , 'noi-W-' , [ 'W' ], title = 'W' , prefix = ' (ε=N(0,{0}))' , converter = int ) saveResults ( './test/noise' , './record/noise' , 'noi-cb-' , [ 'c' , 'b' ], title = 'Biases' , plot = True , prefix = ' (ε=N(0,{0}))' , converter = int ) saveAllResults () 首先考虑不同优化器的测试，在这些测试里，我们确保 \\mathbf{A},~\\mathbf{c} \\mathbf{A},~\\mathbf{c} 对所有测试相同，且产生的随机数据真值 \\mathbf{y}_{\\mathrm{true}} \\mathbf{y}_{\\mathrm{true}} 对所有测试也相同，亦即： \\mathbf{A} \\mathbf{A} \\mathbf{y} \\mathbf{y} 的真实值 于是我们可得到所有的数据 优化器 \\mathbf{y} \\mathbf{y} 的预测值 \\mathbf{W} \\mathbf{W} \\mathbf{b} \\mathbf{b} 与 \\mathbf{c} \\mathbf{c} Adadelta Adagrad Adam Adamax AMSgrad Nesterov Adam Nesterov Moment RMSprop SGD 接下来考虑不同噪声的测试，在这些测试里，我们确保 \\mathbf{A},~\\mathbf{c} \\mathbf{A},~\\mathbf{c} 对所有测试相同，但由于噪声大小的不同，随机数据真值 \\mathbf{y}_{\\mathrm{true}} \\mathbf{y}_{\\mathrm{true}} 会有所偏差： \\mathbf{A} \\mathbf{A} 于是我们可得到所有的数据 \\boldsymbol{\\varepsilon} \\sim N(0,~?) \\boldsymbol{\\varepsilon} \\sim N(0,~?) \\mathbf{y} \\mathbf{y} 的真实值 \\mathbf{y} \\mathbf{y} 的预测值 \\mathbf{W} \\mathbf{W} \\mathbf{b} \\mathbf{b} 与 \\mathbf{c} \\mathbf{c} 0 1 5 10 50 100 我们最为看重的，其实是是否拟合出 \\mathbf{A} \\mathbf{A} 和 \\mathbf{c} \\mathbf{c} 。一系列实验表明， \\mathbf{W} \\mathbf{W} 和 \\mathbf{b} \\mathbf{b} 的拟合效果甚好。由于我们建立的仿射变换模型和原始仿射变换模型有着完全一致的结构，优化结果反映这一问题的解相当准确。至此，我们已经掌握了一个完整的Project应当具有的模块结构，以及对不同的优化器有了理论和实际的体验。在后续的章节里，除非有特别的应用，我们不再探讨不同的优化器对结果的影响，在绝大多数情况下，我们都将使用AMSgrad。","text_tokens":["42","基于","一层","size","一节","key","class","root","generate","end","不过","存在","涉及","成上","强于","99","fileexistserror","后续","94","依赖性","线性","部分","ext","看出","'","范围","images","下来","使用","不会","cdot","rmsprop","情况","点","int","options","initializer","具体情况","26","写为","title","meansquarederror","时","encountered","相对","原始","rmse","^","low","that","收敛","snr","干扰","旧","构造","封装","重要性","红色","全局","saveresults","amsgrad","详情","字符串","help","大小写","svd","optimizers","w","操作符","成效","完整","结论","至少","找到","采用","一些","提及","若","相关","optimizername","预测","lowrank","oprefix","algorithm","将要","our","通常","partial","&","余弦","31","而言","10","发现","学习","29084","100","降到","yp","不得不","可以","以后","336","dict","37","pearson","已知","无论","results","列举","少量","甚巨","数据分布","值得","青睐","record","align","savez","load","批量","技巧","1278","树状","不足","<","(","主","正","不是","视","未免","extending","再","变换","path","testdataset","往往","这方面","称","首先","大多数","较","join","return","use","以便","需","44","rvert","将","0431","称为","文档","type","要求","分解","尝试","rms","一行","适用","真值","steps","else","绝大","费用","7134","v","参考文献","101","8883","自定","接下","import","设置","9.736224609164252","[","分别","2465","标准","第一个","难以","传播","进一步","methods","argumentdefaultshelpformatter","另","0.8","集中","函数","一般","本节","format","熟悉","接受","“","高度","故而","st1","过大","1477","1856","类似","├","点数","3.216810970685858","优化","rightarrow","接起","8130","反之","后","文章","有时","前","均值","深度","descent","理器","共轭","gen","数值","可见","带来","矩阵","有人","方","版本","一个","关于","调用","单值","message","于是","后处理","大小","导出","原因","对","性极","自己","：","different","与","开头","amin","解不","88829040527344","有时候","入门","典型","生效","特征值","假","提示","无法","m","to","一次","同一","启动","还是","ratio","值过","获取","体验","所以","线性变换","if","上","l31","正常","cls","...","预处理","不足以","执行","正是","顾名思义","解时","0.4","lr","恢复","必须","就要","ldots1","参考","rate","开发","神经网络","引用","此次","/","描述","即使","loss","负","）","反映","度","子",",","推翻","依赖","15","x","l32","最低","推断","backend","所示","卓有成效","41","过","为了","0s","默认值","mean","集","有着","根据","except","备受","输","开始","mathbb","kernel","逐渐","做过","py","ncol","量","其一","parse","模型","等于","squared","normal","right","遗忘","每次","入","activation","%","unsupported","from","epoch","远不如","folder","特点","0.5","到","opath","模式","集来","33","layout","另一方面","设","求取","关闭","9833","思路","输出","evaluated","学生","梯度","dfrac","导数","布尔","ylabel","left","误差","for","真是","继上","iter","包括","我们","同","网络层","表明","个","regression","参数设置","adadeltada","用来","皮尔森","n","过多时","因素","控制","指出","下图","we","能","无关痛痒","nearest","迅速","diag","法在","yt","就","可调","复现","带动","有趣","推荐","仿射","基本上","累计","预期","mathcal","一步","同理","处","两个","平均值","痛痒","多值","率设","充当","imshow","113","线性相关","分类器","开来","29","17","─","手","27","程度","关心","l4","至此","alg","初始化","生成器","和","其他","0.01","define","专门","证明","绘制","连接","本","relation","c","2ms","¶","整个","32","大漏","尽可","单靠","8705","上升","选用","networks","这样","settings","排列","可知","construct","回归","真的","compressed","一系列","特地","调试","参考资料","查考","迭代","l22","灵活","这个","自行","ε","策略","bmatrix","时候","机数","test","了解","使得","nadam","output","任意","转换","_","接下来","神经","赘述","防止","k","model","文件","39","分类","子类","正值","原生","讲","建立","开辟","\\","看作","传统","一类","等","adaptive","看成","统计","附图","普遍","formatname","叫","this","此","post","最快","其后","rho","15669","方根","变性","实际上","lvert","先后","首尾","ed1","由","亦","格式","评价","好处","frac","method","水准","比率","importflag","ed3","跟踪",".","点积","这","卓有","迄今为止","引入","，","符号","input","testing","adam","外围","很多","强时","激活","同样","用作","开启","l11","覆盖","教程","metavar","只取","gb","self","左右","没有","角","predict","casefold","importing","leftarrow","aspect","种子","某","减小","value","思想","收集","特别","46","入手","要","配置","方阵","如此","特殊","有些","overview","该类","could","应用","corr","显然","先","值为","值得注意","predicted","line","一对","例子","l3","idea","estimation","功能","由于","信号","一言难尽","里","高斯","注意","叙述","先后顺序","learning",">","9831","项目","45","收敛性","…","因此","都","不加","后来者","6994","测试代码","其实","关键","23","suggest","min","需求","经验","onlyfirst","大于","sum","range","r","短接","多线程","特征","0838","11","程序运行","50","做","神经网","scandir","特定","有所","fit","lin","现在","一般来说","parser","双份","过程","帮助","丢弃","增加","子书","前述","28","然后","22","笔者","参阅","对角","当于","默认","一段","本例","2ac","很","给出","在","bool","型值","测试数据","造成","epilog","3472","34","这一","799","只要","年","增大","大化","这方","np","重要","exit","inputs","最为","列","那些","constant","similarity","摘要","arg","batch","后期","常","二元","opmizername","nargs","文件夹","matplotlib","no","没","只能","详情请","理论","展开","目前","mini","25","秩","选择","adgrad","8145","而","最优","寻找","savefig","step","reg","必定","遵从","电子书","可资利用","较大","容易","不难","然而","初始","per","之间","快速","│","outputdata","抽取","令人","graph","也","各自","一定","拥有","该","同一个","overline","相关系数","次","反例","查","classdef","器有","各个","共同","4000","linear","metrics","修改","seed","initializers","未免太","假设","moment","本次","过高","合理","尽管","hat","上述","空列","same","建议","见到","相反","讨论","算法","范例","值","keras","~","epochs","解来","罗列","局部","解决","接触","analyzing","os","不","避免","其二","模拟","tensoflow","tools","regressed","中能","自","1000","keys","0.9348520972791058","1s","即可","而定","where","展示","在线","求","结合","查看","由该","40","元素","plot","添加","当上","mapsto","原则","测度","每","前提","linalg","dagger","如下","只","随着","自然","参数","下界","通过","成","begin","dtype","掌握","拟出","继","重申","their","只是","连","取","p","节","联系","导致","mathrm","分离","真正","网络","直接","should","打算","感到","有","多个","ml","多则","processing","读者","init","]","and","查阅","快","@","实验","就是说","非线性","neural","一致","集成","随机性","#","需要","raw","尤其","7","曲率","换行","=","times","。","name","则","这些","advanced","修正","模块化","0.001","weights","详细","next","即","相当于","mb","optimizer","偏差","一种","不宜","其中","加","9832","pass","18","列表","datakeys","odot","率为","均","一下","源码","测试","计算出来","附近","工作","add","件夹","罢了","cb","500","1","d","l12","g","testbatchnum","l21","dataset","1930","module","ytrue","get","full","xlabel","square","扩展","—","不怎么","改为","const","个点","会","普通","花招","ylim","探讨","曲线","parsedata","1234","aligned","error","提出","5ms","构造方法","colorbar","一言","bias","24","main","知道","关键字","5","具有","去掉","运用","官方","处理器","陡峭","法","schedule","steppe","evaluate","诸多","教材","available","pred","明显","水平","float","8801","次数","float32","得到","nmoment","def","38","优势","动量","当","压力","将近","9838","是","str","b","12345","好","快乐","浮点数","显示","小小","计算","elif","19","格式化","9836","从而","option","期望","测试阶段","分布","因为","reproductable","应当","系数","matrix","形如","对象","标量","严格","commands","most","推断出","show","4.677152938185369","认为","目标","ed2","6048","甚","完成","相比","rank","呢","完全一致","几种","yes","段","出现","ypred","t","对应","sample","专题","原理","algorithms","程序","路径","方程","介绍","argumenttypeerror","比较","空行","这种","所有",":","更新","optimization","水土不服","losses","尽可能","adagrad","残留","并","经过","提供","print","tight","写","来者","会论","equation","出来","改变","matrices","为什么","20","远远","效果","replace","器","便于","boldsymbol","大","converter","project","给","1983","显明","保证","varepsilon","常数","args","均会","21","指代","6.8600432267325955","上文","令","9897","求导","i","+","数据处理","legend","来说","额外","地方","8600","7719","correlation","一旦","可是","超过","构成","字段","43","y","提到","库","不妨","进度","使","表示","强","s","直观","论文","想象","之前","有成","不太","其","读取","0","不可","svg","例如","staticmethod","写成","基本原理","auto","相当","反而","内容","不如","另一方","秩是","检查","合适","看","166","1.0","ldots2","噪声","来","简单","理想","default","str2bool","解之","写文","事实","保存","为何","8547","一次函数","?","真","均方","saveallresults","png","并且","layer","已经","怎么","选取","按照","近似","30","graphs","的","无关","行","变量","一","不难看出","线路","object","cosine","还","l","领域","章节","成器","很大","”","起来","器为","测试方法","完全相同","向量","让","人","它们","compile","具体","当前","cookbook","类","2","处理","旧版","提升","以下","样本","9","测量","history","70","最","ta","自动","以","水土","each","16","不到","全部","过去","或","prefix","一方","tool","result","一点","基本","字","从根本上","展开讨论","首尾相接","br","demo","区间","告诉","用","最后","数据","之一","尽","{","保留","ng","by","并发","sqrt","启发","config","系列","独立","就是","102","小时","theta","command","机器","根本","这里","任何","append","率","除外","apis","唯一","绝大多数","受到","└","越","nabla","推广","6636","次序","fixed","属于","用法","单独","parameters","究竟","解","限度","跨层","metric","作为","论","数据文件","stddev","为止","term","理解","advnetworkbase","要么","len","说","条件","group","制定","（","希望","trick","9700","do","raise","方式","频繁","低","被","抑制","proportion","才","file","输入","个别","每个","少则","多","运行","它","小量","splitext","一样","1.8380598782932136","关乎","好后","dense1","而是","什么","能够","description","下","内","扰动","close","改进","看看","类型","多线","甚或","中","当场","大时","故此","两次","不必","？","|","本原","对比","带","看重","sigma","取出","将会","形式","除非","且","常用","平缓","0.0","最大","这四","多数","两组","sgd","shape","layers","了","google","方可","；","相同","固定","慢","generator","10.0","argument","同时","f","设由","预测值","得","9897396","二阶","13","允许","cost","以上","遵照","相仿","逆","为本","决定","运算","工程","flag","方差","结果","各层","机","is","灵活运用","pre","设计","usage","noise","数十","损失","层","width","第一","随机噪声","继承","momentum","approximation","因而","store","argparse","一片","有效","35","整数","speically","tf","online","适用性","axis","fill","为此","training","sd","plt","顾名","cdots","小","顺序","adadelta","模块","大地","出原","继续","未来","linreghandle","仍然","不好","所","迄今","interpolation","并非","showcurves","写出","大量","}","6678","gpu","训练","sub","开关","说明","完完全全","本身","train","4","统计学","虽然","足以","不可或缺","上面","记","连接起来","不能","u","重新","or","signal","偏大","去","一致性","subgradient","残差","merged","读写","特例","testdataregset","改动","送入","初步","构建","从式","返回","用户","馈入","从","非常","*","哪","区分","dparser","率过","matmul","黑色","tensorflow","不仅","二值","biases","方面","两种","epsilon","跟","modify","stystart","formatter","uniform","对角线","可","规范","不为","该字","draw","求解","api","5899","更进一步","新","来自","总是","6665","numpy","得慢","相乘","9701","beyond","模拟出","极端","文献","对于","随机","list","label","保持","难看","提前","数据字","not","依靠","仿射变换","set","learningrate","randomnormal","stochastic","概念","像","过于","适当","考虑","mathbf","fae6a9","验证","性能","数目","iterator","9354","准确度","12","率均","下面","反向","准确","做法","完全","support","semilogy","users","调整结构","unconstrained","编写","as","满足","有关","problem","一系","衰减","略去","或许","定义数据","即使如此","种","指数","14","突兀","false","操作","sze","可变性","e","入门者","第一次","关系","实现","真实","出","电子","stroke","随机数","复用","方程组","但是","支持","mergedlabel","可变","复杂","即将","gca","无论是","顺次","gcf","定义","以及","大多","construction","关注","产生","相差","check","应该","符合","sim","基础","这是","minimization","几乎","利用","计学","有解","dense","none","指派","分析","白","融合","意外","标准差","convergence","毫无","指定","base","note","bar","2c","阶梯","推导","j","大致","话题","再进一步","samples","后者","inches","目的","请参阅","of","records","true","相似","式子","optional","又","作用","放在","initialization","地","convex","调整","nesterov","参照",";","引起","h","mse","弊端","1e","delta","线程","之后","进行","如果","位置","是因为","惯性","就行了","单","错误","代码","换言之","0.6","给定","deep","alpha","更","确保","取得","但","多组","arguments","assert","阶段","速度","random","不得","the","decay","noi","远远不如","自然而然","表述","文字","in","codes","data","9813","为","相应","代替","后来","下降","values","一组","trained","式","信噪比","相接","extension","浮点","轨迹","那么","依然","算是","求得","平均","写作","6","ba9132","9834","秩为","save","退化","常见","outputs","方法","风格","兴趣","是否","markevery","argumentparser","5597","主要","影响","network","哪些","名称","一方面","curves","不同","gradient","直线","序列","tests","轻松","小写","可能","改正","陷入","把","后面","陌生","生成","2459","如何","__","setseed","designed","高级","3","资料","a","解析","tilde","适应","既会","区域","9579","不服","拟合","on","数量","越过","it","事实上","细微","with","仍","一个多","算出","或缺","实用","看到","团队","结构","trainbatchnum","st2","iterative"," ","也就是说","中文","估计","适合","markers","36","自定义","上式","limits","后记","或者","只有","率以","实际","选项",")","除了","4556","障碍","字符","相若","-","o","当然","8","9835","adamax","问题","最大化","三个","、","dp","found","失误","showbars","性相","按","不再","python","marker","小小的"],"title":"线性回归","title_tokens":["线性","回归"]},{"location":"book-1-x/chapter-1/linear-regression/#_1","text":"摘要 本节介绍如何使用类模型(Model)来编写一个线性回归器，以拟合出一个线性模型。本节将第一次介绍如何编写一个带用户参数(选项)的Project，并且允许用户选择不同的优化器、对比验证不同优化算法的效果。","text_tokens":["参数","(","选择","用户","验证","并且","对比","带","不同","类","拟合","第一次","选项","的","允许",")","算法","本节","出","效果","，","model","回归","线性","来","节","。","介绍","器","摘要","以","编写","、","一个","project"," ","将","模型","如何","本","一次","使用","第一","优化"],"title":"线性回归","title_tokens":["线性","回归"]},{"location":"book-1-x/chapter-1/linear-regression/#_2","text":"","text_tokens":[],"title":"理论","title_tokens":["理论"]},{"location":"book-1-x/chapter-1/linear-regression/#_3","text":"设存在一个多输出方程 \\mathbf{y} = \\mathcal{F}(x) \\mathbf{y} = \\mathcal{F}(x) ，当然 \\mathcal{F} \\mathcal{F} 可以是非线性函数，那么我们可以考虑使用一个带可调参数的模型 \\mathbf{D}_{\\boldsymbol{\\Theta}}(\\mathbf{x}) \\mathbf{D}_{\\boldsymbol{\\Theta}}(\\mathbf{x}) 来模拟它，其中 \\boldsymbol{\\Theta} \\boldsymbol{\\Theta} 是可调的参数。于是，该问题可以被表述为 \\begin{equation} \\begin{aligned} \\arg \\min_\\limits{\\boldsymbol{\\Theta}} &\\sum_{k=1}^N \\mathcal{L} \\left( \\mathbf{y}_k,~ \\mathbf{D}_{\\boldsymbol{\\Theta}}(\\mathbf{x}_k) \\right),\\\\ \\mathrm{s.t.}~&\\mathbf{y}_k = \\mathcal{F}(\\mathbf{x}_k). \\end{aligned} \\end{equation} 在我们不知道 \\mathcal{F} \\mathcal{F} 的情况下，我们的目的是使用大量的 \\mathbf{x}_k,~\\mathbf{y}_k \\mathbf{x}_k,~\\mathbf{y}_k 样本，来调整出一个最优的近似模型 \\mathbf{D}_{\\boldsymbol{\\Theta}} \\mathbf{D}_{\\boldsymbol{\\Theta}} 。由于 \\mathcal{F} \\mathcal{F} 是非线性的，这要求我们的 \\mathbf{D}_{\\boldsymbol{\\Theta}} \\mathbf{D}_{\\boldsymbol{\\Theta}} 也可以是非线性的。实际情况下，这样的问题往往不容易求解，尤其是信号的非线性性极强时，该问题很容易陷入局部最优解，从而对求得一个可接受的解造成很大的障碍。 这里 \\mathcal{L} \\mathcal{L} 是损失函数。在回归问题中，很多情况下我们都只能选择 均方误差 (Mean squared error, MSE) 作为损失函数，这是因为回归问题的目的是模拟出一组信号来，而这些信号的分布范围可能是任意的。在一些特别的应用里，例如，如果我们的信号全部为正值，那么我们可以考虑使用 信噪比 (Signal-to-noise ratio, SNR) 来作为我们的损失函数。","text_tokens":["从而","其中","(","于是","squared","分布","因为","为","带","对","性极","right","s",".","这","end","出","一组","存在","，","信噪比","{","线性","那么","~","往往","局部","求得","很多","强时","例如","1","d","很","范围","不","to","在","theta","模拟","使用","可","造成","设","ratio","情况","t","这里","f","求解","输出","这样","要求","回归","方程","来","^","arg","snr","left","误差","可能","特别","解","模拟出","陷入","我们","作为","只能","noise","损失","均方","参数","应用","n","选择","aligned","而","begin","error","最优","任意","equation","近似","函数","_","的",",","拟出","目的","k","容易","一些","由于","x","接受","知道","信号","boldsymbol","mathrm","l","里","一个多","正值","也","调整","\\","被"," ","很大","该","&","都","mse","可调","考虑","mathbf","它","mean","limits","大量","非线性","}","min","实际","可以","mathcal","如果",")","尤其","是因为","sum","样本","障碍","-","当然","=","。","问题","这些","下","一个","全部","是","y","signal","模型","中","表述"],"title":"一般回归问题","title_tokens":["一般","问题","回归"]},{"location":"book-1-x/chapter-1/linear-regression/#_4","text":"继上一节的学习，我们知道如何解一个定义为 \\begin{align} \\mathbf{y} = \\left\\{ \\begin{bmatrix}\\hat{y}_1 > 0 & \\hat{y}_2 > 0 & \\cdots & \\hat{y}_n > 0\\end{bmatrix}^T, ~ \\left| ~ \\hat{\\mathbf{y}} = \\mathbf{A} \\mathbf{x} + \\mathbf{c} + \\boldsymbol{\\varepsilon} \\right. \\right\\}, \\end{align} 的分类模型。在本节，让我们考虑一个更简单的模型： \\begin{align} \\mathbf{y} = \\mathbf{A} \\mathbf{x} + \\mathbf{c} + \\boldsymbol{\\varepsilon}. \\end{align} 现在， \\mathbf{y} \\mathbf{y} 是关乎 \\mathbf{A} \\mathbf{A} 和 \\mathbf{c} \\mathbf{c} 的一个仿射函数，并且我们仍然保留噪声函数 \\boldsymbol{\\varepsilon} \\boldsymbol{\\varepsilon} 。由于这是一个线性模型，我们可以想象到，存在一个线性回归器， \\mathbf{W},~\\mathbf{b} \\mathbf{W},~\\mathbf{b} ，使得预测结果为 \\begin{align} \\tilde{\\mathbf{y}} = \\mathbf{W} \\mathbf{x} + \\mathbf{b}. \\end{align} 类似上一节，假设我们的数据集 (\\mathbf{x},~\\mathbf{y}) \\in \\mathbb{D} (\\mathbf{x},~\\mathbf{y}) \\in \\mathbb{D} 符合 (3) (3) 定义的数据分布特征。我们的基本要求是，在我们不知道 \\mathbf{A},~\\mathbf{c} \\mathbf{A},~\\mathbf{c} 的情况下，使用大量 (\\mathbf{x}_k,~\\mathbf{y}_k) \\in \\mathbb{D} (\\mathbf{x}_k,~\\mathbf{y}_k) \\in \\mathbb{D} 样本训练一个线性分类器，使得当我们给定任意一个新样本 \\mathbf{x} \\mathbf{x} 的时候，分类器能推断出其对应的 \\mathbf{y} \\mathbf{y} 。 故而，该问题可以描述为 \\begin{equation} \\begin{aligned} \\arg \\min_\\limits{\\mathbf{W},~\\mathbf{b}} &\\sum_{k=1}^N \\mathcal{L} \\left( \\mathbf{y}_k,~ \\mathbf{W} \\mathbf{x}_k + \\mathbf{b} \\right), \\\\ \\mathcal{L} \\left( \\mathbf{y},~ \\tilde{\\mathbf{y}} \\right) &= \\lVert \\mathbf{y} - \\tilde{\\mathbf{y}} \\rVert_2^2. \\end{aligned} \\end{equation} 在本例中， \\mathbf{y} \\mathbf{y} 有正有负，因此我们使用均方误差来作为损失函数。","text_tokens":["现在","|","in","(","分布","为","正","一节","right","：",".","想象","end","存在","，","数据","其","推断出","0","{","线性","~","和","保留","本例","1","到","d","rvert","不","在","定义","使用","c","情况","t","符合","对应","上","新","这是","要求","回归","^","噪声","来","简单","arg","结果","left","误差","继上","解","我们","作为","如何","损失","均方","3","bmatrix","n","a","时候","aligned","描述","并且","begin","使得","任意","tilde","负","equation","w","_","函数","的",",","本节","k","cdots","由于","x","分类","知道","能","器","boldsymbol","预测","故而","l",">","\\","varepsilon"," ","有","仍然","该","&","推断","因此","类似","考虑","mathbf","让","+","limits","学习","大量","仿射","}","min","训练","可以","mathcal","2","集",")","关乎","sum","样本","-","=","当","。","mathbb","给定","问题","数据分布","更","特征","下","align","分类器","lvert","一个","假设","是","y","b","模型","hat","中","基本"],"title":"线性回归","title_tokens":["线性","回归"]},{"location":"book-1-x/chapter-1/linear-regression/#_5","text":"作为线性问题，该问题实际上可以写出其解析解。未免读者感到过于突兀，我们先从一个简单的问题开始入手： 例子：一次函数的线性回归 如果我们的矩阵 \\mathbf{A} \\mathbf{A} 退化为标量 a a ，向量 \\mathbf{c} \\mathbf{c} 退化为标量c，那么 (3) (3) 可以重新写为： \\begin{align} y = a x + c + \\varepsilon. \\end{align} 考虑我们拥有N个样本点 (x_k,~y_k) (x_k,~y_k) ，上述问题实际上可以求得解析解。设由这N个点构成了样本向量 \\mathbf{x}_d,~\\mathbf{y}_d \\mathbf{x}_d,~\\mathbf{y}_d (注意与前述的向量区分开来)，则问题可以写成 \\begin{align} \\arg \\min_\\limits{a,~c} \\lVert \\mathbf{y}_d - a \\mathbf{x}_d - c \\mathbf{1} \\rVert^2_2. \\end{align} 这就是附图所示的，拟合到直线的一次函数回归问题。将该损失函数展开，有 \\begin{equation} \\begin{aligned} \\mathcal{L}(a,~c) &= ( \\mathbf{y}_d - a \\mathbf{x}_d - c \\mathbf{1} )^T ( \\mathbf{y}_d - a \\mathbf{x}_d - c \\mathbf{1} )\\\\ &= \\mathbf{y}_d^T\\mathbf{y}_d + a^2 \\mathbf{x}_d^T \\mathbf{x}_d + c^2 + 2ac \\mathbf{1}^T \\mathbf{x}_d - 2 a \\mathbf{y}_d^T \\mathbf{x}_d - 2c \\mathbf{1}^T \\mathbf{y}_d. \\end{aligned} \\end{equation} 令 \\dfrac{\\partial \\mathcal{L}(a,~c)}{\\partial a}=0,~\\dfrac{\\partial \\mathcal{L}(a,~c)}{\\partial c}=0 \\dfrac{\\partial \\mathcal{L}(a,~c)}{\\partial a}=0,~\\dfrac{\\partial \\mathcal{L}(a,~c)}{\\partial c}=0 ，则我们得到一组二元一次方程组 \\begin{equation} \\left\\{ \\begin{aligned} a \\mathbf{x}_d^T \\mathbf{x}_d + c \\mathbf{1}^T \\mathbf{x}_d &= \\mathbf{y}_d^T \\mathbf{x}_d. \\\\ c + a \\mathbf{1}^T \\mathbf{x}_d &= \\mathbf{1}^T \\mathbf{y}_d. \\end{aligned} \\right. \\end{equation} 解之，得 \\begin{equation} \\left\\{ \\begin{aligned} a &= \\frac{ \\mathbf{y}_d^T \\mathbf{x}_d - ( \\mathbf{1}^T \\mathbf{y}_d ) ( \\mathbf{1}^T \\mathbf{x}_d ) }{ \\mathbf{x}_d^T \\mathbf{x}_d - (\\mathbf{1}^T \\mathbf{x}_d)^2 } = \\frac{ \\sum_k x_k y_k - \\sum_k y_k \\sum_k x_k }{ \\sum_k (x_k)^2 - \\left(\\sum_k x_k\\right)^2 }. \\\\ c &= \\mathbf{1}^T \\mathbf{y}_d - a ( \\mathbf{1}^T \\mathbf{x}_d ) = \\sum_k y_k - a \\left( \\sum_k x_k \\right). \\end{aligned} \\right. \\end{equation} 这个式子在诸多教材上都会出现，作为学生解回归问题的入门话题。可见，我们在本节讨论的问题并不是一个陌生的问题，相反，我们过去非常熟悉的一个问题，是这个问题的退化到标量下的特殊情况。另，计算该问题的相关系数，我们常使用 \\begin{align} \\rho = \\frac{ \\sum_k \\left(x_k - \\overline{x}\\right) \\left(y_k - \\overline{y}\\right) }{ \\sqrt{ \\sum_k \\left(x_k - \\overline{x}\\right)^2 \\sum_k \\left(y_k - \\overline{y}\\right)^2 } }, \\end{align} 其中 \\overline{x} = \\sum_k x_k ,~ \\overline{y} = \\sum_k y_k \\overline{x} = \\sum_k x_k ,~ \\overline{y} = \\sum_k y_k 。 有了解上述例子的基础，我们自然可以写出， \\begin{equation} \\begin{aligned} \\mathcal{L}(\\mathbf{A},~\\mathbf{c}) &= \\sum_k ( \\mathbf{y}_k - \\mathbf{A} \\mathbf{x}_k - \\mathbf{c} )^T ( \\mathbf{y}_k - \\mathbf{A} \\mathbf{x}_k - \\mathbf{c} )\\\\ &= \\sum_k \\left[ \\mathbf{y}_k^T\\mathbf{y}_k + \\mathbf{x}_k^T \\mathbf{A}^T\\mathbf{A} \\mathbf{x}_k + \\mathbf{c}^T \\mathbf{c} + 2 \\mathbf{c}^T \\mathbf{A} \\mathbf{x}_k - 2 \\mathbf{y}_k^T \\mathbf{A} \\mathbf{x}_k - 2 \\mathbf{y}_k^T \\mathbf{c} \\right]. \\end{aligned} \\end{equation} 提示 接下来的求导主要涉及单值对矩阵求导（导数仍是矩阵），单值对向量求导（导数仍是向量）。可以参考 The Matrix Cookbook 查到对应情况下的求导结果。 同理，令 \\dfrac{\\partial \\mathcal{L}(\\mathbf{A},~\\mathbf{c})}{\\partial \\mathbf{A}}=0,~\\dfrac{\\partial \\mathcal{L}(\\mathbf{A},~\\mathbf{c})}{\\partial \\mathbf{c}}=0 \\dfrac{\\partial \\mathcal{L}(\\mathbf{A},~\\mathbf{c})}{\\partial \\mathbf{A}}=0,~\\dfrac{\\partial \\mathcal{L}(\\mathbf{A},~\\mathbf{c})}{\\partial \\mathbf{c}}=0 ，则我们得到一组二元一次方程组 \\begin{equation} \\left\\{ \\begin{aligned} \\sum_k \\left[ \\mathbf{A} \\mathbf{x}_k \\mathbf{x}_k^T + \\mathbf{c} \\mathbf{x}_k^T \\right] &= \\sum_k \\left[ \\mathbf{y}_k \\mathbf{x}_k^T \\right]. \\\\ \\sum_k \\left[ \\mathbf{c} + \\mathbf{A} \\mathbf{x}_k \\right] &= \\sum_k \\left[ \\mathbf{y}_k \\right]. \\end{aligned} \\right. \\end{equation} 解之，得 \\begin{equation} \\left\\{ \\begin{aligned} \\mathbf{A} &= \\left[ N \\sum_k \\left[ \\mathbf{y}_k \\mathbf{x}_k^T \\right] - \\sum_k \\left[ \\mathbf{y}_k \\right] \\sum_k \\left[ \\mathbf{x}_k^T \\right] \\right] \\left[ N \\sum_k \\left[ \\mathbf{x}_k \\mathbf{x}_k^T \\right] - \\sum_k \\left[ \\mathbf{x}_k \\right] \\sum_k \\left[ \\mathbf{x}_k^T \\right] \\right]^{-1} \\\\ \\mathbf{c} &= \\frac{1}{N} \\sum_k \\left[ \\mathbf{y}_k - \\mathbf{A} \\mathbf{x}_k \\right]. \\end{aligned} \\right. \\end{equation} 可见，当上式中的逆不存在时（即低秩的情况），该方程还是有可能解不唯一。 同时，相关系数的计算可以表示为 \\begin{align} \\rho = \\mathrm{mean} \\left[ \\frac{ \\sum_k \\left(\\mathbf{x}_k - \\overline{\\mathbf{x}}\\right) \\cdot \\left(\\mathbf{y}_k - \\overline{\\mathbf{y}}\\right) }{ \\sqrt{ \\sum_k \\left[ \\left(\\mathbf{x}_k - \\overline{\\mathbf{x}}\\right) \\cdot \\left(\\mathbf{x}_k - \\overline{\\mathbf{x}}\\right) \\right] \\sum_k \\left[ \\left(\\mathbf{y}_k - \\overline{\\mathbf{y}}\\right) \\cdot \\left(\\mathbf{y}_k - \\overline{\\mathbf{y}}\\right) \\right] } } \\right]. \\end{align} 这就是 皮尔森相关系数 (Pearson's correlation) 。其中 \\overline{\\mathbf{x}} = \\sum_k \\mathbf{x}_k ,~ \\overline{\\mathbf{y}} = \\sum_k \\mathbf{y}_k \\overline{\\mathbf{x}} = \\sum_k \\mathbf{x}_k ,~ \\overline{\\mathbf{y}} = \\sum_k \\mathbf{y}_k ， \\cdot \\cdot 表示的是两个向量按元素各自相乘。它是式 (11) (11) 在多变量问题上的推广。相当于对向量的每一个元素，分别从统计上求取皮尔森相关系数，然后对向量每个元素对应的皮尔森相关系数求取平均值。","text_tokens":["其中","(","突兀","frac","系数","为","不是","相反","对","从","：","前述","right","与","讨论","未免",".","非常","matrix","表示","s","标量","关系","这","end","区分","一组","存在","涉及","，","其","式","解不","0","{","线性","当于","那么","~","方程组","入门","求得","平均","了","1","sqrt","写成","到","2ac","d","提示","rvert","'","不","将","就是","退化","相当","在","下来","一次","使用","还是","同时","cdot","c","出现","点","情况","t","求取","设由","主要","对应","上","得","写为","唯一","时","基础","学生","直线","逆","推广","个点","回归","^","dfrac","方程","会","简单","导数","arg","结果","left","元素","解之","常","相乘","可能","当上","解","二元","入手","然后","每","特殊","陌生","我们","接下","作为","[","一次函数","参考","分别","个","损失","这个","展开","3","自然","皮尔森","n","解析","a","并","秩","aligned","了解","2c","begin","先","equation","另","）","话题","函数","_","的",",","拟合","接下来","（","例子","本节","k","变量","熟悉","x","式子","相关","仍","mathrm","l","注意","\\","varepsilon","感到","低","各自"," ","有","partial","拥有","该","过于","&","都","读者","所示","考虑","overline","]","向量","mathbf","令","每个","求导","诸多","+","教材","相关系数","多","附图","写出","limits","查","mean","它","统计","}","cookbook","min","实际","可以","mathcal","如果","2",")","得到","同理","pearson","两个","均值","平均值","correlation","sum","样本","-","开始","=","。","问题","构成","则","可见","rho","矩阵","实际上","下","align","lvert","一个","11","过去","按","重新","是","y","开来","the","即","上述","相当于","中","计算","单值"],"title":"求解问题","title_tokens":["问题","求解"]},{"location":"book-1-x/chapter-1/linear-regression/#_6","text":"接下来，我们要介绍几种最常见的优化算法。关于更多这方面的内容，可以查考Google团队编写的在线电子书 Deep Learning 。笔者打算在未来为此开辟专题写文，因此这里只是介绍几种常见的 一阶梯度下降 算法。传统优化领域里，单靠一阶梯度下降往往难以满足对准确度的需求，但深度学习(Deep learning)往往必须使用这些简单的一阶梯度下降算法，就连使用一阶梯度近似二阶梯度的算法 共轭梯度下降 ，在很多情况下都被认为是费用(cost)过高。这是由于一个深度网络，往往具有大量的参数需要训练，因此一个Model的参数少则数十MB，多则上GB。一阶梯度下降算法所需的计算量小，能确保我们一次迭代的过程能迅速完成，因而备受青睐。为了提升其性能，深度学习领域内也对其进行了诸多改进。 注意 其实，论到优化算法，往往不得不提到 反向传播 。不过实际上，一个Tensorflow的入门者，其实完全不需要学习如何推导反向传播的过程。下面我们的叙述也完全不会提及反向传播相关的内容。关于为何我们不需要了解反向传播，在下一节我们会论到。但是，在本教程后期，介绍高级技巧的时候，我们会详细展开。事实上，笔者认为，一个Tensorflow的用户，如果只是为了编写代码，反向传播与ta其实无关痛痒；但只有真正掌握反向传播，我们才算是真正入门了神经网络的理论。 我们在这里说到优化算法，是用在训练网络上的。事实上，只有几种个别的机器学习应用，需要我们在测试阶段执行 迭代算法 (iterative algorithm) 。一般来说，深度学习的训练过程可以被普遍地描述为：已知一个带可调参数 \\boldsymbol{\\Theta} \\boldsymbol{\\Theta} 的模型 \\mathcal{D}_{\\boldsymbol{\\Theta}} \\mathcal{D}_{\\boldsymbol{\\Theta}} ，已知一组数据集 (\\mathbf{x}_i,~\\mathbf{y}_i) \\in \\mathbb{D} (\\mathbf{x}_i,~\\mathbf{y}_i) \\in \\mathbb{D} ，则我们的训练目标为 \\begin{equation} \\begin{aligned} \\arg \\min_\\limits{\\boldsymbol{\\Theta}} \\mathbb{E}_{(\\mathbf{x}_i,~\\mathbf{y}_i) \\in \\mathbb{D}} \\left[ \\mathcal{L} \\left( \\mathbf{y}_i,~ \\mathcal{D}_{\\boldsymbol{\\Theta}} (\\mathbf{x}_i) \\right) \\right]. \\end{aligned} \\end{equation} 实际情况下，一般用均值估计来代替上式的期望函数。联系我们上一节的优化问题 (1) (1) 和本节的优化问题 (5) (5) ，都可以描述成上式的形式。也就是说，线性分类/回归器，是神经网络在解线性问题时的特例。","text_tokens":["特例","一般来说","in","(","过程","期望","测试阶段","用户","为","带","对","子书","一节","：","right","与","e",".","入门者","算法","笔者","代替","测试","形式","下降","end","不过","用","一组","成上","，","电子","其","数据","式","{","线性","往往","~","这方面","认为","tensorflow","但是","入门","算是","和","目标","很多","了","google","1","需","到","方面","；","d","完成","不","就是","常见","在","教程","下来","一次","本","theta","使用","内容","机器","几种","不会","情况","gb","这里","上","专题","这方","单靠","二阶","时","这是","cost","梯度","在线","回归","会","来","简单","介绍","执行","arg","left","后期","费用","写文","查考","迭代","事实","解","为何","要","必须","接下","我们","mathbb","论","[","神经网络","如何","数十","理论","/","高级","展开","参数","因而","应用","时候","难以","aligned","了解","描述","传播","阶梯","说","begin","推导","会论","equation","近似","掌握","_","接下来","的","度","无关","一般",",","函数","为此","电子书","本节","神经","model","只是","一","连","小","事实上","提及","由于","能","x","分类","联系","相关","5","boldsymbol","器","具有","无关痛痒","领域","里","algorithm","真正","注意","叙述","网络","地","learning","l","也","未来","团队","开辟","打算","迅速","被","\\","传统"," ","iterative","也就是说","估计","因此","多则","都","才","所","优化","就","可调","]","其实","个别","mathbf","少则","为了","多","诸多","i","上式","limits","学习","大量","性能","就是说","只有","普遍","}","来说","不得不","min","进行","需求","可以","准确度","需要","训练","实际","如果",")","mathcal","集","已知","深度","备受","痛痒","提升","均值","代码","最","下面","反向","。","准确","共轭","deep","完全","ta","这些","更","青睐","确保","则","问题","下","实际上","但","内","编写","一个","阶段","详细","满足","是","量","改进","不得","y","提到","模型","过高","关于","技巧","神经网","mb","计算"],"title":"优化算法","title_tokens":["算法","优化"]},{"location":"book-1-x/chapter-1/linear-regression/#_7","text":"接下来，让我们看看第一个算法， 随机梯度下降 (stochastic gradient descent, SGD) 。 随机梯度下降 记学习率为 \\epsilon \\epsilon ，则在每次迭代中 随机抽取（或从随机排列的数据集中按顺序抽取）m个样本 (\\mathbf{x}_k,~\\mathbf{y}_k) (\\mathbf{x}_k,~\\mathbf{y}_k) ，称这m个样本为一个batch； 计算梯度 \\mathbf{g} = \\frac{1}{m} \\nabla_{\\boldsymbol{\\Theta}} \\sum\\limits_{k=1}^m \\mathcal{L} \\left( \\mathbf{y}_k,~ \\mathcal{D}_{\\boldsymbol{\\Theta}} (\\mathbf{x}_k) \\right) \\mathbf{g} = \\frac{1}{m} \\nabla_{\\boldsymbol{\\Theta}} \\sum\\limits_{k=1}^m \\mathcal{L} \\left( \\mathbf{y}_k,~ \\mathcal{D}_{\\boldsymbol{\\Theta}} (\\mathbf{x}_k) \\right) ； 更新参数 \\boldsymbol{\\Theta} \\leftarrow \\boldsymbol{\\Theta} - \\epsilon \\mathbf{g} \\boldsymbol{\\Theta} \\leftarrow \\boldsymbol{\\Theta} - \\epsilon \\mathbf{g} 。 注意学习率一般需要设为一个较小的值，视情况而定。 由于梯度的期望满足 \\begin{equation} \\begin{aligned} \\mathbb{E} \\left[ \\mathbf{g} \\right] &= \\frac{1}{m} \\sum\\limits_{k=1}^m \\mathbb{E} \\left[ \\nabla_{\\boldsymbol{\\Theta}} \\mathcal{L} \\left( \\mathbf{y}_k,~ \\mathcal{D}_{\\boldsymbol{\\Theta}} (\\mathbf{x}_k) \\right) \\right] \\\\ &= \\mathbb{E} \\left[ \\nabla_{\\boldsymbol{\\Theta}} \\mathcal{L} \\left( \\mathbf{y},~ \\mathcal{D}_{\\boldsymbol{\\Theta}} (\\mathbf{x}) \\right) \\right] = \\nabla_{\\boldsymbol{\\Theta}} \\mathbb{E} \\left[ \\mathcal{L} \\left( \\mathbf{y},~ \\mathcal{D}_{\\boldsymbol{\\Theta}} (\\mathbf{x}) \\right) \\right]. \\end{aligned} \\end{equation} 可知随机抽取m个样本计算的梯度，在统计学上的期望等于全局梯度的期望。因此，这是一个有效的算法。 随机梯度下降存在明显的弊端，就是在收敛到（全局或局部）最优解的前提下，全局梯度为0，但通过随机选取batch得到的梯度（一般）可能不为0；并且，迭代受到个别极端样本梯度的影响较大，因此，我们有了第一个改进，即 带动量的随机梯度下降 (SGD with momentum) 。 带动量的随机梯度下降 参考文献 提出该算法的文章，可以在这里参考： On the momentum term in gradient descent learning algorithms. Neural Networks 记学习率为 \\epsilon \\epsilon ，惯性常数为 \\alpha \\alpha ，初始化动量 \\mathbf{v}=\\mathbf{v}_0 \\mathbf{v}=\\mathbf{v}_0 （不考虑继续训练的情况下 \\mathbf{v}_0 = \\mathbf{0} \\mathbf{v}_0 = \\mathbf{0} ），则在每次迭代中 随机抽取（或从随机排列的数据集中按顺序抽取）m个样本 (\\mathbf{x}_k,~\\mathbf{y}_k) (\\mathbf{x}_k,~\\mathbf{y}_k) ，称这m个样本为一个batch； 计算梯度 \\mathbf{g} = \\frac{1}{m} \\nabla_{\\boldsymbol{\\Theta}} \\sum\\limits_{k=1}^m \\mathcal{L} \\left( \\mathbf{y}_k,~ \\mathcal{D}_{\\boldsymbol{\\Theta}} (\\mathbf{x}_k) \\right) \\mathbf{g} = \\frac{1}{m} \\nabla_{\\boldsymbol{\\Theta}} \\sum\\limits_{k=1}^m \\mathcal{L} \\left( \\mathbf{y}_k,~ \\mathcal{D}_{\\boldsymbol{\\Theta}} (\\mathbf{x}_k) \\right) ； 计算带动量的更新值 \\mathbf{v} \\rightarrow \\alpha \\mathbf{v} - \\epsilon \\mathbf{g} \\mathbf{v} \\rightarrow \\alpha \\mathbf{v} - \\epsilon \\mathbf{g} ； 更新参数 \\boldsymbol{\\Theta} \\leftarrow \\boldsymbol{\\Theta} + \\mathbf{v} \\boldsymbol{\\Theta} \\leftarrow \\boldsymbol{\\Theta} + \\mathbf{v} 。 显然，我们不难计算出， \\begin{equation} \\begin{aligned} \\mathbb{E} \\left[ \\mathbf{v} \\right] &= \\alpha \\mathbb{E} \\left[ \\mathbf{v} \\right] - \\epsilon \\mathbb{E} \\left[ \\mathbf{g} \\right]. \\\\ \\mathbb{E} \\left[ \\mathbf{v} \\right] &= - \\frac{\\epsilon}{1 - \\alpha} \\mathbb{E} \\left[ \\mathbf{g} \\right]. \\end{aligned} \\end{equation} 注意惯性通常需要设为 \\alpha \\in (0,~1) \\alpha \\in (0,~1) 。 这种改进的带来的好处是， 每次更新梯度时，上一次的梯度都会以指数衰减的形式残留在本次迭代中，从而确保新的梯度会被旧的梯度部分中和，避免极端梯度对更新参数影响过大； 当求解得到的梯度陷入局部最优时，如果该局部最优处的曲率较小，可以依靠动量的惯性，越过该局部最优解。 附图说明了使用这种算法的好处。黑色路径为SGD的更新轨迹，而红色路径为本算法的更新轨迹，可以看出随着迭代次数的增加，算法收敛的效果强于SGD。 有人从Nesterov在1983年的论文得到启发，提出了一个修正后的带动量随机梯度下降法，即 带Nesterov动量的随机梯度下降 (SGD with Nesterov momentum) 。 带Nesterov动量的随机梯度下降 参考文献 提出该算法的文章，可以在这里参考： A method for unconstrained convex minimization problem with the rate of convergence o\\left( \\frac{1}{k_2} \\right) o\\left( \\frac{1}{k_2} \\right) 记学习率为 \\epsilon \\epsilon ，惯性常数为 \\alpha \\alpha ，初始化动量 \\mathbf{v}=\\mathbf{v}_0 \\mathbf{v}=\\mathbf{v}_0 （不考虑继续训练的情况下 \\mathbf{v}_0 = \\mathbf{0} \\mathbf{v}_0 = \\mathbf{0} ），则在每次迭代中 随机抽取（或从随机排列的数据集中按顺序抽取）m个样本 (\\mathbf{x}_k,~\\mathbf{y}_k) (\\mathbf{x}_k,~\\mathbf{y}_k) ，称这m个样本为一个batch； 计算惯性目标点的位置： \\boldsymbol{\\Theta}^{\\dagger} \\leftarrow \\boldsymbol{\\Theta} + \\alpha \\mathbf{v} \\boldsymbol{\\Theta}^{\\dagger} \\leftarrow \\boldsymbol{\\Theta} + \\alpha \\mathbf{v} ； 计算梯度 \\mathbf{g} = \\frac{1}{m} \\nabla_{\\boldsymbol{\\Theta}} \\sum\\limits_{k=1}^m \\mathcal{L} \\left( \\mathbf{y}_k,~ \\mathcal{D}_{\\boldsymbol{\\Theta}^{\\dagger}} (\\mathbf{x}_k) \\right) \\mathbf{g} = \\frac{1}{m} \\nabla_{\\boldsymbol{\\Theta}} \\sum\\limits_{k=1}^m \\mathcal{L} \\left( \\mathbf{y}_k,~ \\mathcal{D}_{\\boldsymbol{\\Theta}^{\\dagger}} (\\mathbf{x}_k) \\right) ； 计算带动量的更新值 \\mathbf{v} \\rightarrow \\alpha \\mathbf{v} - \\epsilon \\mathbf{g} \\mathbf{v} \\rightarrow \\alpha \\mathbf{v} - \\epsilon \\mathbf{g} ； 更新参数 \\boldsymbol{\\Theta} \\leftarrow \\boldsymbol{\\Theta}^{\\dagger} - \\epsilon \\mathbf{g} \\boldsymbol{\\Theta} \\leftarrow \\boldsymbol{\\Theta}^{\\dagger} - \\epsilon \\mathbf{g} 。 其实，该方法的更新量期望与前一种方法一样， 显然，我们不难计算出， \\begin{equation} \\begin{aligned} \\mathbb{E} \\left[ \\mathbf{v} \\right] &= - \\frac{\\epsilon}{1 - \\alpha} \\mathbb{E} \\left[ \\mathbf{g} \\right]\\\\ &= \\frac{\\epsilon}{1 - \\alpha} \\nabla_{\\boldsymbol{\\Theta}} \\mathbb{E} \\left[ \\mathcal{L} \\left( \\mathbf{y},~ \\mathcal{D}_{\\boldsymbol{\\Theta} + \\alpha \\mathbf{v}} (\\mathbf{x}) \\right) \\right]. \\end{aligned} \\end{equation} 当收敛到最优解时， \\mathbf{v} \\rightarrow 0 \\mathbf{v} \\rightarrow 0 ，同时有 \\boldsymbol{\\Theta} + \\alpha \\mathbf{v} \\rightarrow \\boldsymbol{\\Theta} \\boldsymbol{\\Theta} + \\alpha \\mathbf{v} \\rightarrow \\boldsymbol{\\Theta} 。我们在此不展开证明这个算法是能收敛的。但Nesterov的文献表明，它能将上面提到的带动量梯度下降算法的误差从 O\\left(\\frac{1}{K}\\right) O\\left(\\frac{1}{K}\\right) 下降到 O\\left(\\frac{1}{K^2}\\right) O\\left(\\frac{1}{K^2}\\right) 。其中 K K 为迭代次数。下图展示了这种方法的改进原理。它的梯度是在更新动量的惯性部分之后才计算出来的，因此新的梯度和之前的惯性是首尾相接的。实际实现时，按照上面的算法，每次迭代需要更新两次参数，计算一次梯度。合理调整算法的计算次序，可以改进为每次迭代更新一次参数，计算一次梯度。","text_tokens":["好处","指数","从而","in","一种","其中","(","期望","frac","首尾相接","method","为","增加","带","对","视","从","right","：","率为","与","e",".","实际","算法","每次","形式","论文","计算出来","这","下降","end","之前","出","实现","存在","初始化","，","数据","强于","相接","值","轨迹","0","{","黑色","~","称","较","和","局部","sgd","部分","目标","了","1","看出","启发","；","到","d","m","证明","不","epsilon","将","就是","g","在","避免","下来","一次","theta","方法","使用","设","同时","不为","情况","点","这里","求解","影响","率","上","年","原理","时","受到","新","这是","algorithms","gradient","leftarrow","nabla","而定","networks","路径","minimization","展示","排列","梯度","为本","可知","次序","^","计学","会","收敛","batch","left","误差","for","这种","可能","旧","迭代","解","参考文献","v","解时","陷入","接下","更新","我们","前提","极端","[","dagger","参考","rate","红色","表明","个","文献","这个","全局","第一","term","随着","momentum","convergence","随机","参数","展开","第一个","残留","a","通过","aligned","而","并且","begin","有效","最优","提出","显然","equation","选取","出来","集中","）","按照","_","接下来","的",",","一般","下图","（","依靠","on","效果","越过","k","较大","不难","小","顺序","由于","初始","with","x","of","能","stochastic","boldsymbol","l","注意","算出","抽取","learning","继续","convex","1983","调整","过大","\\","被","通常","nesterov","常数"," ","有","该","&","因此","都","才","弊端","法","考虑","]","让","mathbf","个别","rightarrow","其实","带动","+","统计","附图","它","limits","学习","明显","neural","一样","}","后","之后","次数","训练","需要","mathcal","文章","可以","如果","说明",")","得到","处","2","位置","惯性","曲率","前","sum","样本","统计学","此","descent","-","动量","o","=","当","。","mathbb","则","alpha","带来","修正","确保","以","下","有人","但","unconstrained","上面","一个","记","按","满足","改进","y","量","看看","或","即","the","是","本次","problem","提到","等于","首尾","合理","衰减","中","两次","计算"],"title":"引入动量的优化算法","title_tokens":["算法","的","引入","动量","优化"]},{"location":"book-1-x/chapter-1/linear-regression/#_8","text":"上述几种算法共同的特点是，具有一个“学习率”。实际上，这个学习率非常不好处理，值过小时，收敛速度很慢；值过大时，在最优解附近又难以收敛。为了解决这一思路，我们可以令学习率可变。最简单的思路是，将学习率设为指数衰减的（当然也可以设置下界），这样当开始学习的时候，学习率较大；而即将收敛时，学习率又会较小。 但是，以上做法不过是一些小小的花招(trick)罢了，接下来介绍的几种算法，是根据当前计算出的梯度来自适应调整学习率的。理论上，使用这种算法，用户不再需要特别关注学习率对训练的影响，我们尽可以设置一个偏大的学习率，在训练过程中，它能被自适应调整到一个合适的区间上。 首先，我们来介绍一种初步的改进， Adagrad (Adaptive Subgradient) ， Adgrad 参考文献 提出该算法的文章，可以在这里参考： Adaptive Subgradient Methods for Online Learning and Stochastic Optimization 记学习率为 \\epsilon \\epsilon ，小量 \\delta \\delta ，初始化学习率参数对角矩阵为 \\mathbf{r} = \\mathrm{diag}(\\mathbf{0}) \\mathbf{r} = \\mathrm{diag}(\\mathbf{0}) ，则在每次迭代中 随机抽取（或从随机排列的数据集中按顺序抽取）m个样本 (\\mathbf{x}_k,~\\mathbf{y}_k) (\\mathbf{x}_k,~\\mathbf{y}_k) ，称这m个样本为一个batch； 计算梯度 \\mathbf{g} = \\frac{1}{m} \\nabla_{\\boldsymbol{\\Theta}} \\sum\\limits_{k=1}^m \\mathcal{L} \\left( \\mathbf{y}_k,~ \\mathcal{D}_{\\boldsymbol{\\Theta}} (\\mathbf{x}_k) \\right) \\mathbf{g} = \\frac{1}{m} \\nabla_{\\boldsymbol{\\Theta}} \\sum\\limits_{k=1}^m \\mathcal{L} \\left( \\mathbf{y}_k,~ \\mathcal{D}_{\\boldsymbol{\\Theta}} (\\mathbf{x}_k) \\right) ； 更新学习率为： \\mathbf{r} \\leftarrow \\mathbf{r} + \\mathrm{diag}(\\mathbf{g})^2 \\mathbf{r} \\leftarrow \\mathbf{r} + \\mathrm{diag}(\\mathbf{g})^2 ； 更新参数 \\boldsymbol{\\Theta} \\leftarrow \\boldsymbol{\\Theta} - \\dfrac{\\epsilon}{\\delta + \\sqrt{\\mathbf{r}}} \\mathbf{g} \\boldsymbol{\\Theta} \\leftarrow \\boldsymbol{\\Theta} - \\dfrac{\\epsilon}{\\delta + \\sqrt{\\mathbf{r}}} \\mathbf{g} 。 注意文献中常用向量点积 \\odot \\odot 来表示学习率，这样学习率就不是对角矩阵而是向量了。我们这里不定义额外的符号，以便不熟悉相关定义的读者理解。 这一方法的思想是，学习率随着梯度的累计增大而逐渐减小，类似我们使用指数衰减的策略。所不同的是，在梯度小的地方，我们认为梯度平缓，所以学习率减小得慢，以便算法迅速地通过这一片区域；在梯度大地地方，由于梯度陡峭，为了防止我们因为学习率过大漏过该区域，学习率减小得快，以适应梯度的大小。 这个方法没有从根本上解决迭代次数过多时，梯度过小的问题。不难看出该算法学习率以 O\\left(\\frac{1}{\\mathbf{g}^T\\mathbf{g}}\\right) O\\left(\\frac{1}{\\mathbf{g}^T\\mathbf{g}}\\right) 的比率衰减，经验指出，这个算法在很多情况下是不好用的，只能解决一些比较特定的模型。 在这里，我们依然不给出收敛性的证明（或许在未来我们会在专题中讨论这一问题）。读者不必为这些算法的原理感到压力，我们只需要对其有一个直观的了解就好。 考虑到Adagrad学习率减小的速度未免太快了，我们可以考虑它的改进， RMSprop (root mean square proportion) ，注意它是另一个算法Adadelta的特例，不过在本节我们不会讨论Adadelta，有兴趣的读者可以自己去寻找参考资料。 RMSprop 参考文献 提出该算法的文章，可以在这里参考： Overview of mini-batch gradient descent 记学习率为 \\epsilon \\epsilon ，小量 \\delta \\delta ，衰减参数 \\rho \\rho ，初始化学习率参数对角矩阵为 \\mathbf{r} = \\mathrm{diag}(\\mathbf{0}) \\mathbf{r} = \\mathrm{diag}(\\mathbf{0}) ，则在每次迭代中 随机抽取（或从随机排列的数据集中按顺序抽取）m个样本 (\\mathbf{x}_k,~\\mathbf{y}_k) (\\mathbf{x}_k,~\\mathbf{y}_k) ，称这m个样本为一个batch； 计算梯度 \\mathbf{g} = \\frac{1}{m} \\nabla_{\\boldsymbol{\\Theta}} \\sum\\limits_{k=1}^m \\mathcal{L} \\left( \\mathbf{y}_k,~ \\mathcal{D}_{\\boldsymbol{\\Theta}} (\\mathbf{x}_k) \\right) \\mathbf{g} = \\frac{1}{m} \\nabla_{\\boldsymbol{\\Theta}} \\sum\\limits_{k=1}^m \\mathcal{L} \\left( \\mathbf{y}_k,~ \\mathcal{D}_{\\boldsymbol{\\Theta}} (\\mathbf{x}_k) \\right) ； 更新学习率为： \\mathbf{r} \\leftarrow \\rho \\mathbf{r} + (1 - \\rho) \\mathrm{diag}(\\mathbf{g})^2 \\mathbf{r} \\leftarrow \\rho \\mathbf{r} + (1 - \\rho) \\mathrm{diag}(\\mathbf{g})^2 ； 更新参数 \\boldsymbol{\\Theta} \\leftarrow \\boldsymbol{\\Theta} - \\dfrac{\\epsilon}{\\delta + \\sqrt{\\mathbf{r}}} \\mathbf{g} \\boldsymbol{\\Theta} \\leftarrow \\boldsymbol{\\Theta} - \\dfrac{\\epsilon}{\\delta + \\sqrt{\\mathbf{r}}} \\mathbf{g} 。 和上一个算法相比，它唯一的改变就是引入了一个衰减参数 \\rho \\rho ，以指数衰减将之前收集的学习率遗忘。如此就可以控制指数过大的问题，这个trick真是令人一言难尽。但是有趣的是，实际经验中，这个方法真的是卓有成效，是现在常用的神经网络优化算法之一。 最后让我们来介绍当前最实用的算法（之一）， Adam (adaptive momentum estimation) 。顾名思义，它的基本原理是基于对动量的可变估计。实际上，在上一节的Project中，我们选用的优化器就是Adam，Tensorflow的官方教程中，也将Adam作为默认推荐的优化器。 Adam 参考文献 提出该算法的文章，可以在这里参考： Adam: a Method for Stochastic Optimization 特别需要注意的是，Adam的收敛性证明已经被后来者推翻，指出其中存在一个错误。改正后的版本称为AMSGrad，Tensorflow的Keras API支持我们在设置Adam的时候开启AMSGrad模式。关于AMSGrad，我们不在此展开讨论，有兴趣的读者可以参考： On the Convergence of Adam and Beyond 记 k k 为迭代次数，学习率为 \\epsilon \\epsilon ，小量 \\delta \\delta ，衰减参数 \\rho_1,~\\rho_2 \\rho_1,~\\rho_2 ，初始化动量为 \\mathbf{s} = \\mathbf{0} \\mathbf{s} = \\mathbf{0} ，学习率参数对角矩阵为 \\mathbf{r} = \\mathrm{diag}(\\mathbf{0}) \\mathbf{r} = \\mathrm{diag}(\\mathbf{0}) ，则在每次迭代中 随机抽取（或从随机排列的数据集中按顺序抽取）m个样本 (\\mathbf{x}_k,~\\mathbf{y}_k) (\\mathbf{x}_k,~\\mathbf{y}_k) ，称这m个样本为一个batch； 计算梯度 \\mathbf{g} = \\frac{1}{m} \\nabla_{\\boldsymbol{\\Theta}} \\sum\\limits_{k=1}^m \\mathcal{L} \\left( \\mathbf{y}_k,~ \\mathcal{D}_{\\boldsymbol{\\Theta}} (\\mathbf{x}_k) \\right) \\mathbf{g} = \\frac{1}{m} \\nabla_{\\boldsymbol{\\Theta}} \\sum\\limits_{k=1}^m \\mathcal{L} \\left( \\mathbf{y}_k,~ \\mathcal{D}_{\\boldsymbol{\\Theta}} (\\mathbf{x}_k) \\right) ； 更新动量为： \\mathbf{s} \\leftarrow \\rho_1 \\mathbf{s} + (1 - \\rho_1) \\mathbf{g} \\mathbf{s} \\leftarrow \\rho_1 \\mathbf{s} + (1 - \\rho_1) \\mathbf{g} ； 更新学习率为： \\mathbf{r} \\leftarrow \\rho_2 \\mathbf{r} + (1 - \\rho_2) \\mathrm{diag}(\\mathbf{g})^2 \\mathbf{r} \\leftarrow \\rho_2 \\mathbf{r} + (1 - \\rho_2) \\mathrm{diag}(\\mathbf{g})^2 ； 调整参数大小： \\hat{\\mathbf{s}} \\leftarrow \\dfrac{\\mathbf{s}}{1 - \\rho_1^k} \\hat{\\mathbf{s}} \\leftarrow \\dfrac{\\mathbf{s}}{1 - \\rho_1^k} , \\hat{\\mathbf{r}} \\leftarrow \\dfrac{\\mathbf{r}}{1 - \\rho_2^k} \\hat{\\mathbf{r}} \\leftarrow \\dfrac{\\mathbf{r}}{1 - \\rho_2^k} ； 更新参数 \\boldsymbol{\\Theta} \\leftarrow \\boldsymbol{\\Theta} - \\epsilon \\dfrac{ \\hat{\\mathbf{s}} }{\\delta + \\sqrt{\\hat{\\mathbf{r}}}} \\boldsymbol{\\Theta} \\leftarrow \\boldsymbol{\\Theta} - \\epsilon \\dfrac{ \\hat{\\mathbf{s}} }{\\delta + \\sqrt{\\hat{\\mathbf{r}}}} 。 Adam不仅估计了学习率的可变性，还引入了可变的动量。这是迄今为止，我们见到的第一个将动量和可变学习率结合起来的算法。我们当然期望它能带来双份的 快乐 好处，可是…… 为什么会这样呢？ ，已经有文献指出，Adam存在原理上的失误，并提出了改正的算法AMSGrad，这正是我们未来将要在专题中讨论的内容。现在读者只需要知道，Adam的思路其实就是结合动量和可变学习率就行了。 注意 无论是我们没提到的Adadelta还是提到的Adam，其实都引入了动量的概念。那么一个自然而然的idea就是，使用Nesterov动量代替普通的动量。当然，毫无意外的是，已经有人做过了。例如，Adam的Nesterov动量版本叫Nadam，有兴趣的读者不妨去了解一下。","text_tokens":["不必","？","一种","其中","基于","本原","odot","一节","率为","一下","root","附近","不过","初始化","存在","常用","平缓","罢了","和","了","1","看出","；","d","证明","慢","g","下来","使用","不会","rmsprop","情况","得","大漏","时","以上","选用","这样","square","排列","真的","会","^","收敛","普通","参考资料","迭代","花招","这个","第一","amsgrad","momentum","策略","时候","了解","一片","提出","nadam","成效","online","接下来","_","一言","神经","防止","k","顾名","小","一些","顺序","知道","相关","具有","adadelta","大地","未来","将要","\\","官方","不好","陡峭","所","迄今","adaptive","学习","}","次数","训练","可以","叫","无论","此","动量","当","rho","变性","实际上","压力","记","是","偏大","去","好","快乐","subgradient","小小","计算","特例","好处","(","初步","frac","期望","method","用户","因为","比率","不是","从","点积","未免","非常","这","卓有","迄今为止","引入","，","率过","符号","首先","称","认为","较","tensorflow","adam","很多","不仅","以便","开启","将","epsilon","相比","教程","呢","几种","称为","t","api","没有","专题","原理","来自","leftarrow","减小","介绍","思想","比较","得慢","收集","这种","特别","beyond","参考文献","如此",":","接下","更新","设置","optimization","overview","文献","adagrad","随机","第一个","并","难以","难看","来者","methods","改变","另","集中","为什么","本节","idea","熟悉","estimation","由于","器","“","stochastic","boldsymbol","一言难尽","概念","注意","learning","project","过大","收敛性","…","类似","都","后来者","优化","考虑","令","mathbf","其实","+","后","文章","额外","地方","经验","sum","可是","descent","r","做法","带来","矩阵","有人","版本","一个","y","提到","神经网","关于","衰减","特定","或许","不妨","现在","指数","双份","过程","大小","对","自己","：","表示","可变性","s","直观","之前","有成","出","其","对角","0","默认","但是","支持","可变","例如","即将","m","很","基本原理","给出","无论是","在","定义","内容","关注","还是","值过","所以","这一","合适","上","增大","这是","来","简单","batch","正是","顾名思义","没","只能","参考","神经网络","理论","意外","展开","convergence","毫无","mini","adgrad","而","最优","寻找","已经","）","的",",","推翻","较大","不难","不难看出","然而","初始","of","x","又","还","l","地","抽取","令人","也","调整","nesterov","该","”","起来","卓有成效","过","向量","让","为了","delta","mean","当前","2","处理","根据","就行了","共同","样本","错误","开始","最","以","逐渐","做过","未免太","速度","或","the","模型","上述","hat","基本","自然而然","从根本上","展开讨论","见到","为","区间","right","讨论","遗忘","算法","每次","代替","后来","用","最后","数据","之一","尽","{","keras","~","依然","那么","解决","特点","sqrt","到","不","就是","模式","小时","theta","方法","兴趣","根本","这里","影响","率","自","唯一","思路","不同","gradient","nabla","梯度","结合","dfrac","left","for","真是","解","改正","我们","作为","个","只","为止","随着","理解","自然","参数","资料","下界","a","通过","过多时","适应","控制","区域","指出","（","on","trick","能","mathrm","网络","实用","diag","被","迅速","感到"," ","有","proportion","估计","读者","就","and","快","它","有趣","limits","推荐","小量","率以","累计","实际","需要","mathcal",")","率设","-","而是","当然","o","什么","=","。","问题","则","这些","下","失误","不再","按","改进","中","大时","小小的"],"title":"引入可变学习率的优化算法","title_tokens":["的","算法","引入","可变","率","学习","优化"]},{"location":"book-1-x/chapter-1/linear-regression/#_9","text":"","text_tokens":[],"title":"解线性回归问题","title_tokens":["问题","线性","回归","解"]},{"location":"book-1-x/chapter-1/linear-regression/#_10","text":"重申我们之前提到的，我们建议一个完整的工程应当包括 . ├─ data/ # where we store our data │ └─ ... ├─ tools.py # codes for post-processing and analyzing records. ├─ extension.py # codes for extending the tensorflow model. ├─ dparser.py # data parser └─ main.py # main module where we define our tensorflow model. 除了保存数据的文件夹，我们应当有三个子模块。其中 tool : 用来处理、分析生成的数据，通常与Tensorflow无关； extension : 用来扩展tensorflow，例如在这里自定义网络层和操作符； dparser : 数据处理器，用来读取并预处理送入网络的数据； main : 主模块，只定义跟Tensorflow模型有关的内容，需要引用 extension 和 dparser 。 视情况可以灵活调整结构，但建议将定义Tensorflow模型的代码单独放在主模块里，和其他外围代码分离。 在上一节中，我们没有定义 tool.py 和 extension.py ，这是因为我们的工程还很简单，不需要扩展Tensoflow模型，也不需要专门的数据处理代码。相应地，我们把数据的后处理代码直接集成在了主模块 lin-cls.py 里。在这一节，我们要开始构造一个真正严格按照这四部分分离的工程，并且在接下来的各个例子实现里，都会遵照这个模式，读者应当熟悉类似我们所推荐的、这样一个高度分离的模块化设计的思路。","text_tokens":["lin","建议","codes","parser","其中","送入","后处理","因为","操作","应当","data","主","─","视","相应","一节","与",".","extending","之前","实现","这","严格","，","数据","extension","dparser","读取","这四","件夹","tensorflow","和","其他","部分","外围","了","define","例如","analyzing","；","很","专门","不","将","跟","模式","在","下来","定义","tensoflow","tools","内容","情况","这里","上","module","没有","思路","└","遵照","where","这样","扩展","cls","...","预处理","会","工程","简单","单独","for","保存","要","包括",":","文件夹","自定","把","构造","分析","我们","接下","生成","设计","网络层","只","灵活","引用","这个","/","用来","store","并","并且","按照","操作符","完整","的","子","无关","接下来","例子","重申","model","main","文件","we","熟悉","records","还","高度","分离","放在","里","模块","真正","│","地","网络","直接","也","调整","结构","our","通常"," ","有","处理器","├","processing","都","读者","类似","所","and","自定义","数据处理","推荐","集成","#","需要","可以","除了","处理","是因为","各个","代码","post","-","开始","理器","。","模块化","三个","调整结构","但","、","一个","py","the","提到","有关","模型","tool","中"],"title":"代码规范","title_tokens":["代码","规范"]},{"location":"book-1-x/chapter-1/linear-regression/#_11","text":"此次是我们第一次写扩展模块，编写扩展模块的目的是，提供一个更复杂的支持库，以便我们能轻松地使用Tensorflow。因此，扩展模块编写地原则应当包括： 可适用性 : 它应当与我们某一个Project完全无关，就像我们自己基于Tensorflow编写一个扩展库一样，以后我们在任何项目都应该可以使用同一个扩展模块文件； 低依赖性 : 它应当最低限度地需要依赖库。 tensorflow 库本身当然是需要的，而 numpy ， matplotlib 甚或是读写数据的模块，都不宜出现在这里，以确保我们的扩展模块被其他任何模块调用时，依赖关系都是树状的； 强一致性 : 它的使用风格，应当尽可能和Tensorflow本身的API一致，使得一个之前不怎么接触它的人，也能快速上手。 在这个工程里，我们扩展的内容其实很简单，就是允许模型调用一个指定的优化器。让我们直接看以下代码： extension.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class AdvNetworkBase : ''' Base object of the advanced network APIs. ''' @staticmethod def optimizer ( name = 'adam' , l_rate = 0.01 , decay = 0.0 ): ''' Define the optimizer by default parameters except learning rate. Note that most of optimizers do not suggest users to modify their speically designed parameters. name: the name of optimizer (default='adam') (available: 'adam', 'amsgrad', 'adamax', 'nadam', 'adadelta', 'rms', 'adagrad', 'nmoment', 'sgd') l_rate: learning rate (default=0.01) decay: decay ratio ('adadeltaDA' do not support this option) ''' name = name . casefold () if name == 'adam' : return tf . keras . optimizers . Adam ( l_rate , decay = decay ) elif name == 'amsgrad' : return tf . keras . optimizers . Adam ( l_rate , decay = decay , amsgrad = True ) elif name == 'adamax' : return tf . keras . optimizers . Adamax ( l_rate , decay = decay ) elif name == 'nadam' : return tf . keras . optimizers . Nadam ( l_rate , schedule_decay = decay ) elif name == 'adadelta' : return tf . keras . optimizers . Adadelta ( l_rate , decay = decay ) elif name == 'rms' : return tf . keras . optimizers . RMSprop ( l_rate , decay = decay ) elif name == 'adagrad' : return tf . keras . optimizers . Adagrad ( l_rate , decay = decay ) elif name == 'nmoment' : return tf . keras . optimizers . SGD ( lr = l_rate , momentum = 0.6 , decay = decay , nesterov = True ) else : return tf . keras . optimizers . SGD ( l_rate , decay = decay ) 我们在这里几乎罗列了所有可能使用的优化器，全部来自Keras API。但我们也可以使用Tensorflow旧版API定义的优化器。目前Tensorflow允许使用两种API中的任意一种来定义，但是实验发现，旧版API系列的优化器要么已经在Keras中能找到对应的版本，要么就水土不服，无法正常调用。因此，上文提到的几种优化器，我们基本上全部在这里用Keras API定义出来。 优化器的参数尽可能应当选择默认参数，并且应当封装起来，不宜让用户自行操作。尤其是Adadelta，Adam这些优化器的 \\rho \\rho 变量，在 Keras文档 中，建议我们遵从默认值。 任何继承该类的子类，都可以通过 self . optimizer ( self . optimizerName , self . learning_rate ) 来将封装好的优化器API调用到主模块中。","text_tokens":["option","建议","一种","不宜","29","14","17","基于","(","18","用户","操作","应当","主","手","自己","：","27","强","与","28",".","22","class","第一次","关系","之前","用","most","，","数据","extension","依赖性","0.0","keras","默认","自行","tensorflow","但是","支持","和","sgd","其他","adam","罗列","接触","0.01","复杂","by","return","6","了","define","staticmethod","1","以便","；","'","无法","到","很","两种","系列","将","就是","to","在","33","modify","一次","风格","定义","使用","同一","内容","几种","可","ratio","中能","rmsprop","出现","应该","这里","任何","api","34","对应","self","network","26","apis","上","if","看","32","文档","尽可","casefold","时","13","正常","来自","允许","扩展","numpy","不怎么","rms","几乎","适用","轻松","某","来","that","工程","简单","parameters","default","else","可能","所有","原则","限度","lr","包括",":","matplotlib","封装","我们","rate","该类","这个","designed","此次","adadeltada","第一","水土不服","尽可能","继承","amsgrad","adagrad","指定","3","note","base","25","momentum","目前","advnetworkbase","参数","选择","要么","通过","而","提供","使得","nadam","写","35","任意","怎么","optimizers","speically","已经","并且","出来","30","tf","适用性","_","的","无关",",","not","20","不服","遵从","目的","their","24","依赖","文件","找到","变量","15","of","object","能","true","器","5","do","optimizername","adadelta","子类","l","里","模块","快速","地","直接","learning","project","也","低","项目","被","nesterov","\\"," ","像","最低","21","因此","31","都","同一个","起来","优化","就","schedule","上文","36","人","其实","让","10","available","默认值","它","@","23","suggest","实验","发现","一致","一样","基本上","以后","可以","需要","2","12",")","this","尤其","本身","7","except","def","nmoment","旧版","以下","4","代码","9","当然","8","0.6","=","。","adamax","完全","name","support","这些","更","advanced","确保","users","以","rho","但","水土","编写","版本","16","一个","py","全部","11","是","the","decay","提到","一致性","好","模型","库","甚或","中","树状","调用","基本","optimizer","elif","读写","19"],"title":"扩展模块","title_tokens":["扩展","模块"]},{"location":"book-1-x/chapter-1/linear-regression/#argparse","text":"本节将第一次引入 argparse 模块。该模块是python本身具有的原生模块，用来给代码提供启动选项。作为一个完整的Project，我们不希望为了调整参数而频繁地修改代码，因此 argparse 对我们是不可或缺的。在后面所有的Project中，我们都会通过 argparse 模块支持项目选项。 argparse 的官方文档可以在此查阅： argparse — Parser for command-line options, arguments and sub-commands 调用 argparse 的一开始，我们需要定义如下内容： Codes 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import argparse def str2bool ( v ): if v . casefold () in ( 'yes' , 'true' , 't' , 'y' , '1' ): return True elif v . casefold () in ( 'no' , 'false' , 'f' , 'n' , '0' ): return False else : raise argparse . ArgumentTypeError ( 'Unsupported value encountered.' ) parser = argparse . ArgumentParser ( description = 'A demo for linear regression.' , formatter_class = argparse . ArgumentDefaultsHelpFormatter ) Output usage: tools.py [ -h ] A demo for linear regression. optional arguments: -h, --help show this help message and exit 我们首先定义了 str2bool 函数，用来支持用户提供布尔类型的选项；之后，我们初始化了 parser ，一般地初始化 parser 时，我们主要定义三个参数： description : 项目描述，展示在参数用法之前的一段字符串； formatter_class : 格式化器 ，我们一般调用的都是 ArgumentDefaultsHelpFormatter ，因为它能支持自动换行，并在每个参数用法后展示该参数的默认值； epilog : 后记 ，这一段说明文字出现在所有参数用法之后。我们一般不太需要这个功能，但是有时候我们可以使用该功能提供一些用法范例给用户。 现在，我们来介绍几种典型的 argparse 可以提供的参数类型。 字符串选项 1 2 3 4 5 6 7 parser . add_argument ( '-o' , '--optimizer' , default = 'adam' , metavar = 'str' , help = ''' \\ The optimizer we use to train the model (available: 'adam', 'amsgrad', 'adamax', 'nadam', 'adadelta', 'rms', 'adagrad', 'nmoment', 'sgd') ''' ) 在这里我们定义了一个字符串选项，这是最常用的一类选项。用户可以像 python codes.py -o amsgrad 或者 python codes.py --optimizer amsgrad 一样，通过添加参数来覆盖默认值(定义在 default 字段下)。 数值选项 1 2 3 4 5 6 parser . add_argument ( '-lr' , '--learningRate' , default = 0.001 , type = float , metavar = 'float' , help = ''' \\ The learning rate for training the model. ''' ) 这里添加的参数类型是一个浮点数，虽然用户在输入参数的时候输入的是一个字符串，但 metavar 字段告诉了用户应该输入浮点数， type 决定了用户输入的字符串会被自动转换为浮点数。类似地，将两个字段的 float 改为 int ，我们就能提供一个整数作为参数选项 布尔选项 1 2 3 4 5 6 parser . add_argument ( '-if' , '--importFlag' , type = str2bool , nargs = '?' , const = True , default = False , metavar = 'bool' , help = ''' \\ The flag of importing pre-trained model. ''' ) 这里添加的是一个二值选项，它的默认值是 False ，用户可以通过输入 ( 'yes' , 'true' , 't' , 'y' , '1' ) 中的任何一个来指定该选项为真，或通过 ( 'no' , 'false' , 'f' , 'n' , '0' ) 中的任何一个指定该选项为假，不区分大小写。该功能由我们之前定义的 str2bool 函数提供。 特别值得注意的是，这个布尔选项还可以有这样的用法，例如： python codes.py -if -o amsgrad 我们如果指派了 -if ，在不指定它任何值的情况下，该选项就会被开启（值为真）了；如果我们去掉这一行的 -if ，则该选项关闭（值为假）。 多值选项 1 2 3 4 5 6 parser . add_argument ( '-ml' , '--mergedLabel' , default = None , type = int , nargs = '+' , metavar = 'int' , help = ''' \\ The merged label settings. ''' ) 上面的设置提供了一个可以输入任意多个 int 型值的选项，用法如下： python codes.py -ml 1 3 4 0 2 -o amsgrad 上述的输入会被解析成一个值为 [ 1 , 3 , 4 , 0 , 2 ] 的列表。当然，我们也可以输入任意多的值，但是特别值得注意的是，由于在 nargs 字段指定了 + ，一旦我们指派该选项，就要至少输入一个值方可。 上面的几种范例，并不是每一种都需要用在Project中。实际设置选项的时候，应当参照实际情况来处理。例如，本例中，就只使用 字符串选项 和 数值选项 两种。更多关于 add_argument 的用法，请参阅官方文档： argparse — add_argument() 在所有参数都设置好后，调用 args = parser . parse_args () 即可使参数选项生效。用户输入的参数选项将返回到 args 中，例如，如果用户制定了 -o ( --optimizer )，那么我们可以调用 args.optimizer 来取出该字段的值。","text_tokens":["一种","列表","取出","class","初始化","常用","add","和","sgd","了","1","方可","'","；","使用","argument","情况","f","options","int","时","13","encountered","这样","settings","—","改为","决定","const","会","flag","pre","usage","这个","第一","amsgrad","argparse","时候","字符串","output","help","nadam","整数","大小写","任意","转换","_","完整","training","至少","model","一些","5","具有","adadelta","去掉","原生","模块","\\","官方","一类","10","available","float","可以","sub","说明","this","本身","nmoment","def","train","4","此","虽然","值得","不可或缺","上面","是","str","由","浮点数","格式","elif","merged","格式化","(","返回","用户","因为","应当","不是","importflag",".","这","引入","区分","commands","，","show","首先","adam","return","use","二值","两种","开启","将","覆盖","metavar","formatter","几种","yes","段","出现","该字","t","文档","casefold","importing","type","rms","一行","value","介绍","argumenttypeerror","else","所有","v","特别",":","import","设置","[","adagrad","label","并","提供","argumentdefaultshelpformatter","值为","函数","值得注意","一般","line","本节","learningrate","功能","由于","器","注意","learning","project","给","项目","像","args","因此","点数","都","类似","+","后","12","有时","一旦","数值","一个","11","字段","y","关于","调用","现在","parser","message","14","false","使","大小","对","：","第一次","之前","参阅","不太","有时候","0","默认","不可","但是","支持","mergedlabel","典型","生效","一段","例如","本例","假","to","在","bool","一次","定义","型值","内容","启动","epilog","应该","if","exit","来","default","str2bool","none","lr","指派","nargs","no","就要","rate","?","真","指定","而","描述","）","的",",","请参阅","一","初始","of","true","optional","还","地","也","调整","参照","h","该","为了","默认值","之后","如果","2","处理","9","代码","开始","最","linear","自动","更","修改","但","py","arguments","或","the","parse","上述","字","文字","codes","in","为","demo","告诉","用","trained","unsupported","范例","浮点","值","那么","6","到","不","command","tools","argumentparser","这里","任何","关闭","主要","即可","展示","用法","布尔","小写","for","添加","后面","每","我们","作为","如下","regression","只","用来","3","参数","n","a","解析","通过","成","制定","（","希望","we","能","raise","或缺","频繁","被"," ","有","多个","ml","就","输入","]","每个","and","多","查阅","它","后记","或者","一样","实际","需要","选项",")","7","两个","多值","换行","好后","字符","-","o","8","当然","=","。","adamax","description","则","下","三个","0.001","python","类型","中","optimizer"],"title":"项目选项：argparse","title_tokens":["：","选项","argparse","项目"]},{"location":"book-1-x/chapter-1/linear-regression/#_12","text":"本节的数据也是自动生成出来的。参考上一节的数据生成器，重新定义数据生成类的迭代器： dparser.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class TestDataRegSet ( TestDataSet ): ''' A generator of the data set for testing the linear regression model. ''' def next_train ( self ): ''' Get the next train batch: (x, y) ''' x = self . s_x * ( np . random . random ([ self . batch , self . len_x ]) - 0.5 ) y = np . matmul ( x , self . A ) + self . c if self . noise > 1e-3 : y = y + np . random . normal ( 0 , self . noise , size = y . shape ) else : np . random . normal ( 0 , self . noise , size = y . shape ) return x , y 提示 这里我们在没有噪声的情况下，仍然调用随机噪声函数，这是为了确保噪声函数被调用，使得随机数无论开关噪声，都能保持一致性。 该生成器同样是输入一组 \\mathbf{A},~\\mathbf{c} \\mathbf{A},~\\mathbf{c} ，以及相关配置，之后就可以通过 迭代器 (iterator) 或 方法 (method) 随机生成数据。与上一节不同的是，我们在本节可以尝试更进一步，令 \\mathbf{A} \\mathbf{A} 的 SVD分解 写作如下形式 \\begin{align} \\mathbf{A} = \\mathbf{U} \\boldsymbol{\\Sigma} \\mathbf{V}^T. \\end{align} 其中， \\boldsymbol{\\Sigma} \\boldsymbol{\\Sigma} 是一个对角矩阵，对角线上的元素顺次排列，对应为矩阵 \\mathbf{A} \\mathbf{A} 的各个特征值。Numpy的库已经集成了 SVD分解 。我们知道，一个 M \\times N M \\times N 的矩阵经过SVD分解后，应当有 \\mathbf{U}_{M \\times M} \\mathbf{U}_{M \\times M} 和 \\mathbf{V}^T_{N \\times N} \\mathbf{V}^T_{N \\times N} 两个方阵。故而，矩阵 \\boldsymbol{\\Sigma}_{M \\times N} \\boldsymbol{\\Sigma}_{M \\times N} 并非方阵。由于它只有对角线上有元素，所以必定有多出来的空行或空列。因此，若我们设 K = \\min(M,~N) K = \\min(M,~N) ，则我们可以知道，SVD分解其实不需要矩阵 \\mathbf{U} \\mathbf{U} 和 \\mathbf{V}^T \\mathbf{V}^T 两个方阵都是方阵，因为当我们取矩阵 \\boldsymbol{\\Sigma}_{K \\times K} \\boldsymbol{\\Sigma}_{K \\times K} 这一对角部分后，可以只取部分行/列构成的矩阵 \\mathbf{U}_{M \\times K} \\mathbf{U}_{M \\times K} 和 \\mathbf{V}^T_{K \\times N} \\mathbf{V}^T_{K \\times N} 。这相当于我们略去了 \\boldsymbol{\\Sigma} \\boldsymbol{\\Sigma} 上的空行/空列，但是SVD分解仍然能保证恢复出原矩阵来。 在本例中，我们保留 \\boldsymbol{\\Sigma} \\boldsymbol{\\Sigma} 中的前 r r 个特征值，其后的特征值都丢弃，我们把这样的做法称为矩阵的低秩近似，于是有 dparser.py 1 2 3 4 5 6 7 8 9 10 11 12 def gen_lowrank ( A , r ): ''' Generate a low rank approximation to matrix A. A: input matrix. r: output rank. ''' sze = A . shape r_min = np . amin ( sze ) assert r <= r_min and r > 0 , 'r should in the range of [1, {0}]' . format ( r_min ) u , s , v = np . linalg . svd ( A , full_matrices = False ) s = np . diag ( s [: r ]) return np . matmul ( np . matmul ( u [:,: r ], s ), v [: r ,:]) 一个低秩近似的矩阵，其定义的仿射变换 (3) (3) 满足不同的 \\mathbf{x} \\mathbf{x} 对应同一个值 \\mathbf{y} \\mathbf{y} ；反之， \\mathbf{y} \\mathbf{y} 将会对应多个不同的解 \\mathbf{x} \\mathbf{x} 。如果我们训练的线性分类器模拟的是 (3) (3) 的逆过程，可能我们会无法模拟出合适的解来；但是，由于我们定义的 (4) (4) 仍是在拟合正过程，故而我们仍然可以把这个问题看成是有解的。在后续的内容中，我们会适当地讨论当问题 解不唯一 时，我们可以进行哪些工作来处理这类问题。 接下来，我们即可测试低秩近似的效果， dparser.py 1 2 3 4 5 6 7 8 9 def test_lowrank (): A = np . random . normal ( 0 , 10 , [ 10 , 6 ]) for r in range ( 1 , 7 ): A_ = gen_lowrank ( A , r ) RMS = np . sqrt ( np . mean ( np . square ( A - A_ ))) R = np . linalg . matrix_rank ( A_ ) print ( 'Rank = {0}, RMS={1}' . format ( R , RMS )) test_lowrank () Output Rank = 1 , RMS = 6.8600432267325955 Rank = 2 , RMS = 4.677152938185369 Rank = 3 , RMS = 3.216810970685858 Rank = 4 , RMS = 1.8380598782932136 Rank = 5 , RMS = 0.9348520972791058 Rank = 6 , RMS = 9.736224609164252e-15 可见，对于一个标准差为10的矩阵，低秩近似的残差仍然是不超过随机高斯矩阵本身的标准差的。这里的秩是我们在调用低秩近似函数后，使用 np.linalg.matrix_rank 测量的结果。","text_tokens":["其中","size","一节","sigma","class","将会","形式","测试","generate","end","后续","工作","线性","生成器","和","部分","shape","了","1","'","；","generator","下来","使用","c","情况","时","13","get","full","这样","逆","square","排列","^","low","会","结果","迭代","noise","这个","随机噪声","approximation","机数","test","使得","output","svd","_","接下来","k","model","分类","知道","若","5","相关","lowrank","出原","\\","仍然","并非","10","看成","}","训练","可以","开关","本身","def","train","无论","4","当","其后","align","u","是","重新","一致性","残差","<","testdataregset","(","method","因为","应当","正","matrix",".","*","这","变换","，","dparser","matmul","testdataset","input","4.677152938185369","testing","return","同样","rank","对角线","只取","称为","t","对应","self","没有","角","更进一步","分解","numpy","尝试","rms","else","空行","v","配置","模拟出","方阵",":","接下","9.736224609164252","[","对于","标准","随机","经过","保持","进一步","print","出来","matrices","函数","一对","本节","仿射变换","效果","set","format","由于","器","boldsymbol","故而","高斯",">","保证","因此","都","适当","3.216810970685858","6.8600432267325955","mathbf","令","其实","+","反之","iterator","后","min","12","前","超过","range","r","gen","做法","构成","可见","矩阵","特征","一个","11","满足","y","库","略去","调用","定义数据","于是","过程","14","false","sze","丢弃","：","与","s","amin","e","其","解不","对角","随机数","0","当于","但是","本例","特征值","提示","无法","m","相当","to","顺次","在","定义","以及","同一","内容","秩是","所以","合适","if","上","np","这是","列","噪声","来","有解","batch","恢复","参考","/","标准差","秩","已经","近似","必定","的",",","行","15","of","x","地","也","成器","该","同一个","1e","为了","mean","之后","进行","类","2","如果","处理","各个","9","测量","linear","自动","确保","py","assert","random","或","the","空列","in","data","normal","为","讨论","一组","数据","值","{","~","解来","保留","写作","6","sqrt","0.5","不","方法","模拟","设","这里","哪些","唯一","0.9348520972791058","不同","即可","元素","for","可能","解","把","linalg","我们","生成","如下","regression","个","3","n","a","通过","len","begin","拟合","拟出","取","能","仍","should","低","被","diag"," ","有","多个","就","输入","]","and","多","它","一致","只有","集成","仿射","需要","一步","1.8380598782932136",")","7","两个","-","8","=","times","。","问题","则","下","分类器","next","相当于","中"],"title":"数据生成","title_tokens":["数据","生成"]},{"location":"book-1-x/chapter-1/linear-regression/#_13","text":"类模型 (Model class) ，在官方文档中也称为函数式API，是Tensorflow-Keras的用户大多数情况下应当使用的模型。它支持一些灵活的操作，使得我们可以 多输入多输出 : 类模型的输入和输出层，都是通过函数定义的。类模型在构建的时候，只需要给定输入和输出即可； 跨层短接 : 由于类模型的各层都由函数定义，可以轻松将不同的层连接起来，通常通过 融合层 完成这一工作； 多优化器 : 可以通过复用同一层对应的对象，构建多个不同的类模型，并分别对它们使用不同的训练数据、损失函数、优化器，以实现多优化目标。 一个顺序模型大致可以描述为下图的模式： graph LR st1(输<br/>入<br/>1) --> l11[层<br/>1-1] l11 --> l21[层<br/>1-2] l21 --> l31[层<br/>1-3] l31 --> ldots1[层<br/>...] st2(输<br/>入<br/>2) --> l12[层<br/>2-1] l12 --> l22[层<br/>2-2] l22 --> l32[层<br/>2-3] l32 --> ldots2[层<br/>...] ldots1 --> l3[层<br/>3] ldots2 --> l3 l3 --> l4[层<br/>4] l4 --> ed1(输<br/>出<br/>1) l4 --> ed2(输<br/>出<br/>2) l22 --> ed3(输出3) l21 --> l3 classDef styStart fill:#FAE6A9,stroke:#BA9132; class st1,ed1,st2,ed2,ed3 styStart 在本节中，尽管我们开始使用类模型，但我们定义的仍然是一个单线路的线性回归模型，换言之，这样的模型完全可以通过 顺序模型 实现出来。我们从这一节开始，不再使用顺序模型，其一，是因为顺序模型都可以写成类模型的形式，其二，是希望读者能够熟悉、灵活运用类模型的优势。 我们定义一个继承自 extension.py 的类， class LinRegHandle ( ext . AdvNetworkBase ): 。与上一节的情况相若，这里我们不再赘述需要定义哪些方法。并且，我们也不会介绍一些改动不大、或者不重要的方法，详情请读者参阅源码。","text_tokens":["改动","(","构建","用户","一层","操作","应当","因为","为","br","对","从","：","一节","ed3","与",".","class","对象","实现","入","l4","这","形式","参阅","源码","出","式","，","数据","stroke","extension","工作","复用","keras","线性","多数","大多数","tensorflow","支持","和","目标","ext","1","ba9132","写成","；","ed2","完成","将","l11","l12","不","连接","模式","在","其二","l21","方法","定义","使用","stystart","大多","不会","称为","情况","这里","api","这一","对应","文档","上","自","哪些","l31","不同","即可","输出","这样","ldots2","重要","...","轻松","回归","介绍","各层","灵活运用","lr","跨层",":","我们","同","分别","[","ldots1","l22","详情请","融合","只","灵活","层","损失","/","继承","3","详情","advnetworkbase","时候","并","通过","描述","使得","并且","出来","大致","函数","下图","的",",","fill","本节","希望","l3","赘述","model","熟悉","一些","由于","顺序","线路","器","l32","st1","大","graph","也",">",";","通常","st2","运用"," ","linreghandle","多个","官方","仍然","都","起来","读者","优化","输入","]","它们","接起","多","fae6a9","它","或者","classdef","#","训练","类","可以","需要","2",")","是因为","单","输","4","相若","-","开始","换言之","能够","优势","给定","。","短接","完全","以","下","但","、","一个","py","连接起来","不再","是","其一","ed1","模型","尽管","由","中","<"],"title":"定义类模型","title_tokens":["类","定义","模型"]},{"location":"book-1-x/chapter-1/linear-regression/#_14","text":"首先，定义初始化方法： lin-cls.py: class LinRegHandle 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def __init__ ( self , learning_rate = 0.01 , epoch = 10 , steppe = 30 , optimizerName = 'adam' ): ''' Initialization and pass fixed parameters. learning_rate: the learning rate for optimizer. epoch: training epochs. steppe: steps per epoch optimizerName: the name of optimizer (available: 'adam', 'amsgrad', 'adamax', 'nadam', 'adadelta', 'rms', 'adagrad', 'nmoment', 'sgd') ''' self . lr = learning_rate self . epoch = epoch self . steppe = steppe self . optimizerName = optimizerName 与上一节相比，这里我们增加了一个参数， opmizerName ，用来指定我们选用的优化器名称，默认值为 adam 。","text_tokens":["lin","(","14","pass","为","增加","：","一节","与",".","class","初始化","，","epoch","默认","epochs","首先","sgd","adam","0.01","6","了","1","'","相比","方法","定义","这里","self","上","名称","13","选用","cls","rms","fixed","steps","parameters","for","opmizername","lr",":","我们","rate","__","用来","adagrad","amsgrad","3","指定","参数","nadam","30","_","的",",","training","初始","of","器","5","per","optimizername","adadelta","initialization","learning","linreghandle"," ","优化","init","steppe","and","10","available","默认值","12","2",")","7","nmoment","def","4","9","-","8","=","。","adamax","name","py","一个","11","the","optimizer"],"title":"初始化方法","title_tokens":["初始","方法","初始化"]},{"location":"book-1-x/chapter-1/linear-regression/#_15","text":"接下来定义网络构造 lin-cls.py: class LinRegHandle 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 def construct ( self ): ''' Construct a linear model and set the optimizer as Adam ''' # Construction input = tf . keras . Input ( shape = ( INPUT_SHAPE ,), dtype = tf . float32 ) dense1 = tf . keras . layers . Dense ( LABEL_SHAPE , use_bias = True , kernel_initializer = tf . keras . initializers . RandomNormal ( 0.0 , stddev = 10.0 ), bias_initializer = tf . keras . initializers . Constant ( 2 ), activation = None , name = 'dense1' )( input ) self . model = tf . keras . Model ( inputs = input , outputs = dense1 ) # Set optimizer self . model . compile ( optimizer = self . optimizer ( self . optimizerName , self . lr ), loss = tf . keras . losses . MeanSquaredError (), metrics = [ self . relation ] ) @staticmethod def relation ( y_true , y_pred ): m_y_true = tf . keras . backend . mean ( y_true , axis = 0 ) m_y_pred = tf . keras . backend . mean ( y_pred , axis = 0 ) s_y_true = tf . keras . backend . sqrt ( tf . keras . backend . mean ( tf . keras . backend . square ( y_true ), axis = 0 ) - tf . keras . backend . square ( m_y_true )) s_y_pred = tf . keras . backend . sqrt ( tf . keras . backend . mean ( tf . keras . backend . square ( y_pred ), axis = 0 ) - tf . keras . backend . square ( m_y_pred )) return tf . keras . backend . mean (( tf . keras . backend . mean ( y_true * y_pred , axis = 0 ) - m_y_true * m_y_pred ) / ( s_y_true * s_y_pred )) 使用类模型时，我们每定义一层，都调用对应的网络层函数，并返回层的输出结果。这就是为何它又叫“函数式API”。我们直接使用均方误差作为我们的损失函数，同时，我们还自行定义了一个评价函数， 皮尔森相关系数 ，该系数专门用来反映两组数据之间是否线性相关，上文我们已经叙述过它的定义。 注意 理想情况下，相关系数应当使用整个数据集来求取。但实际情况下做不到这一点，因此我们求取的相关系数只能看作是一个通过batch得到的估计。故此，我们可以发现，求相关系数要求我们每次输入的样本至少有2个。样本数目越多，相关系数的估计越准确。 注意 从式中可以发现，我们定义的皮尔森相关系数时，完全使用的时Tensorflow-Keras API，因此它当然可以用作我们的训练损失函数。但实际情况下，我们并不使用它。考虑一个反例，当两组数据的分布之间唯一的不同只是均值时，亦即 \\mathbf{y}_2 = \\mathbf{y}_1 + C \\mathbf{y}_2 = \\mathbf{y}_1 + C ，这种情况下皮尔森相关系数仍然为1。虽然我们可以考虑用 余弦相似度函数 (Cosine similarity) 来代替它，但经验显示，余弦相似度最大化到一定程度以后，其对应的均方误差反而上升。考虑另一个反例， \\mathbf{y}_2 = \\alpha \\mathbf{y}_1 \\mathbf{y}_2 = \\alpha \\mathbf{y}_1 ，显然 \\mathbf{y}_1 \\mathbf{y}_1 和 \\mathbf{y}_2 \\mathbf{y}_2 的余弦相似度是1。因此，实际应用中，无论是皮尔森相关系数还是余弦相似度，都适合用作评价函数而不是损失函数。 与上一节不同的是，由于这是一个线性回归器，我们不给它提供激活函数。","text_tokens":["lin","从式","(","14","17","返回","18","一层","分布","应当","系数","为","不是","一节","程度","与","均",".","class","22","s","*","每次","activation","关系","代替","这","用","式","，","数据","其","0","0.0","input","keras","线性","{","最大","两组","tensorflow","和","adam","shape","return","layers","use","6","了","staticmethod","1","sqrt","'","到","激活","m","专门","用作","不","10.0","就是","无论是","集来","outputs","下来","反而","定义","relation","是否","使用","construction","同时","还是","求取","c","情况","initializer","api","对应","self","26","大化","上","整个","唯一","meansquarederror","时","13","不同","上升","这是","输出","越","square","要求","cls","inputs","construct","求","回归","来","constant","理想","similarity","dense","结果","batch","误差","这种","none","为何","lr","构造",":","每","接下","我们","作为","[","只能","网络层","个","损失","层","stddev","losses","/","均方","用来","自行","皮尔森","3","25","label","应用","a","并","通过","而","提供","loss","已经","显然","另","dtype","tf","反映","_","接下来","axis",",","的","函数","20","度","至少","bias","24","set","model","只是","15","由于","true","randomnormal","相似","cosine","器","5","又","optimizername","“","还","相关","之间","注意","叙述","网络","直接","给","\\","linreghandle","看作","一定"," ","有","仍然","该","21","因此","估计","backend","都","”","余弦","适合","上文","]","过","输入","考虑","compile","mathbf","and","10","相关系数","多","+","它","@","23","pred","mean","发现","数目","反例","}","#","叫","float32","类","12","2","实际","可以","训练",")","得到","经验","以后","7","def","均值","dense1","4","9","样本","虽然","-","无论","8","当然","=","当","。","linear","准确","name","完全","metrics","alpha","最大化","线性相关","initializers","下","但","kernel","方","as","16","py","一个","不到","11","性相","是","y","the","即","模型","做","一点","中","亦","调用","故此","optimizer","显示","评价","19"],"title":"构造方法","title_tokens":["构造","方法","构造方法"]},{"location":"book-1-x/chapter-1/linear-regression/#_16","text":"类模型的 compile 、 fit 、 evaluate 、 predict 等API与顺序模型完全相同，详情请查看： Model类 (函数式API) - Keras中文文档","text_tokens":["evaluate","compile","详情","api","(","文档","predict","：","与","函数","类","的",")","式","，","model","查看","顺序","-","keras","等","完全","、","相同"," ","中文","详情请","模型","fit","完全相同"],"title":"训练和测试方法","title_tokens":["训练","和","测试","方法","测试方法"]},{"location":"book-1-x/chapter-1/linear-regression/#_17","text":"上一节中，我们每次训练后，就当场显示分析结果。在本节中，我们会“再进一步”。即使用 tools.py 专门进行实验结果分析（后处理）。相对地，训练后，我们会讲 原始输出 (raw output) 保存到文件里。这是一种编写代码的思想，是为了便于我们批量分析测试数据。在后面的Project中，我们会看到，我们既会编写当场显示分析结果的测试代码，也会编写保存输出后使用 tools.py 分析的代码。究竟使用哪种方式分析数据，视具体情况而定。一般地，测试少量数据时，我们当场分析；批量测试大量数据时，或者需要比较不同选项（例如不同噪声）对结果的影响时，我们在 tools.py 中分析。本实验的情况属于后者。","text_tokens":["种","一种","(","后处理","对","视","一节",".","每次","测试","哪","，","数据","例如","到","；","专门","在","本","使用","tools","测试数据","情况","影响","具体情况","上","时","相对","不同","这是","输出","原始","而定","会","噪声","属于","结果","思想","比较","究竟","保存","后面","分析","我们","进一步","output","既会","）","再进一步","一般","的","（","后者","本节","文件","“","便于","讲","里","地","看到","project","也","方式"," ","”","就","测试代码","为了","具体","实验","大量","或者","后","进行","训练","需要","一步","选项","raw",")","处理","代码","少量","。","编写","py","是","即","批量","中","当场","显示"],"title":"调试","title_tokens":["调试"]},{"location":"book-1-x/chapter-1/linear-regression/#_18","text":"由于我们本次实验需要对比不同设置下的回归器性能，我们希望随机生成的矩阵 \\mathbf{A} \\mathbf{A} ，向量 \\mathbf{c} \\mathbf{c} 应当可复现；换言之，我们希望我们的结果是可复现的。 关于这一问题，Keras的文档给出的建议可以在这里查阅： 如何在 Keras 开发过程中获取可复现的结果？ - Keras中文文档 我们只需要使 argparse 添加一个选项 -sd ( --seed )，并通过该选项控制： 1 2 3 4 5 6 def setSeed ( seed ): np . random . seed ( seed ) random . seed ( seed + 12345 ) tf . set_random_seed ( seed + 1234 ) if args . seed is not None : # Set seed for reproductable results setSeed ( args . seed ) 其中， np.random.seed ， random.seed ， tf.set_random_seed 分别来自Numpy，python原生的random库，以及Tensorflow。将这三个库的 随机种子 (seed) 设为三个不同的值，即可保证我们每次指定 -sd 后，从程序运行开始，得到的所有随机数都是固定的随机序列。当然， Keras文档 指出，即使如此，我们还不能保证我们的结果完完全全是可复现的。因为多线程算法并发的先后顺序随机性、GPU运算带来的先后顺序随机性等干扰因素，均会导致我们每次得到的结果有细微的偏差。但这些因素对于本实验验证可复现数据的要求几乎没有什么影响。","text_tokens":["偏差","？","建议","其中","过程","(","使","reproductable","因为","应当","对比","为","从","：",".","每次","算法","这","，","数据","值","随机数","{","keras","tensorflow","并发","6","1","；","固定","将","给出","在","本","以及","可","获取","设","c","这里","这一","影响","if","文档","没有","np","不同","来自","即可","程序","序列","要求","numpy","几乎","种子","回归","运算","结果","for","is","干扰","添加","none","所有",":","如此","我们","设置","生成","分别","开发","如何","只","对于","setseed","3","随机","指定","argparse","1234","a","并","机数","通过","即使","因素","控制","指出","tf","_","的","not","希望","sd","set","顺序","由于","细微","器","5","还","导致","原生","先后顺序","保证","\\"," ","有","args","中文","该","均会","都","等","向量","mathbf","复现","查阅","+","运行","验证","实验","性能","线程","}","随机性","后","#","gpu","需要","可以","选项","2","完完全全",")","得到","def","4","results","-","换言之","开始","当然","什么","多线程","。","问题","完全","这些","带来","矩阵","seed","下","三个","但","、","一个","先后","不能","random","是","python","程序运行","本次","12345","多线","库","关于","中","即使如此"],"title":"使实验结果可复现","title_tokens":["复现","结果","使","实验","可"]},{"location":"book-1-x/chapter-1/linear-regression/#_19","text":"首先，训练网络。我们同样随机生成 \\mathbf{x} \\mapsto \\mathbf{y}:~\\mathbb{R}^{10} \\mapsto \\mathbb{R}^6 \\mathbf{x} \\mapsto \\mathbf{y}:~\\mathbb{R}^{10} \\mapsto \\mathbb{R}^6 的仿射变换，将该变换中的线性变换矩阵采用秩为4的低秩近似，并且设置好数据集，给定噪声扰动由用户决定。默认值下，噪声为 \\boldsymbol{\\varepsilon} \\sim \\mathcal{N}(0,10)^6 \\boldsymbol{\\varepsilon} \\sim \\mathcal{N}(0,10)^6 ，epoch为20个，每个epoch迭代500次，每次馈入32个样本构成的batch。我们将上一节的主函数输出部分修改成如下形式，并进行不加参数的调试： lin-cls.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 # Initialization A = dp . gen_lowrank ( np . random . normal ( 0 , 10 , [ INPUT_SHAPE , LABEL_SHAPE ]), RANK ) c = np . random . uniform ( 1 , 3 , [ 1 , LABEL_SHAPE ]) dataSet = dp . TestDataRegSet ( 10 , A , c ) dataSet . config ( noise = args . noise ) # Generate a group of testing samples. if args . seed is not None : setSeed ( args . seed + 1000 ) dataSet . config ( batch = args . testBatchNum ) x , y = next ( dataSet ) # Set the data set for training. dataSet . config ( batch = args . trainBatchNum ) # Construct the model and train it. h = LinRegHandle ( learning_rate = args . learningRate , epoch = args . epoch , steppe = args . steppe , optimizerName = args . optimizer ) h . construct () print ( 'Begin to train:' ) print ( '---------------' ) record = h . train ( iter ( dataSet )) # Check the testing results print ( 'Begin to test:' ) print ( '---------------' ) yp , loss_p , corr_p = h . test ( x , y ) # Check the regressed values W , b = h . model . get_layer ( name = 'dense1' ) . get_weights () # Save if args . outputData is not None : np . savez_compressed ( args . outputData , epoch = record . epoch , loss = record . history [ 'loss' ], corr = record . history [ 'relation' ], test_x = x , test_y = y , pred_y = yp , pred_loss = loss_p , pred_corr = corr_p , W = W , b = b , A = A , c = c ) Output Begin to train: --------------- Epoch 1 /20 500 /500 [==============================] - 1s 2ms/step - loss: 29084 .6994 - relation: 0 .3472 Epoch 2 /20 500 /500 [==============================] - 1s 2ms/step - loss: 15669 .9579 - relation: 0 .5597 Epoch 3 /20 500 /500 [==============================] - 1s 2ms/step - loss: 8145 .8705 - relation: 0 .7134 Epoch 4 /20 500 /500 [==============================] - 1s 2ms/step - loss: 4000 .0838 - relation: 0 .8130 Epoch 5 /20 500 /500 [==============================] - 1s 2ms/step - loss: 1856 .1477 - relation: 0 .8801 Epoch 6 /20 500 /500 [==============================] - 1s 2ms/step - loss: 799 .4556 - relation: 0 .9354 Epoch 7 /20 500 /500 [==============================] - 1s 2ms/step - loss: 336 .8600 - relation: 0 .9700 Epoch 8 /20 500 /500 [==============================] - 1s 2ms/step - loss: 166 .5899 - relation: 0 .9813 Epoch 9 /20 500 /500 [==============================] - 1s 2ms/step - loss: 113 .2465 - relation: 0 .9831 Epoch 10 /20 500 /500 [==============================] - 1s 2ms/step - loss: 102 .0431 - relation: 0 .9834 Epoch 11 /20 500 /500 [==============================] - 1s 2ms/step - loss: 99 .6678 - relation: 0 .9838 Epoch 12 /20 500 /500 [==============================] - 1s 2ms/step - loss: 99 .8547 - relation: 0 .9833 Epoch 13 /20 500 /500 [==============================] - 1s 2ms/step - loss: 100 .1278 - relation: 0 .9834 Epoch 14 /20 500 /500 [==============================] - 1s 2ms/step - loss: 99 .6048 - relation: 0 .9835 Epoch 15 /20 500 /500 [==============================] - 1s 2ms/step - loss: 101 .1930 - relation: 0 .9832 Epoch 16 /20 500 /500 [==============================] - 1s 2ms/step - loss: 101 .6636 - relation: 0 .9835 Epoch 17 /20 500 /500 [==============================] - 1s 2ms/step - loss: 100 .6665 - relation: 0 .9834 Epoch 18 /20 500 /500 [==============================] - 1s 2ms/step - loss: 101 .2459 - relation: 0 .9832 Epoch 19 /20 500 /500 [==============================] - 1s 2ms/step - loss: 100 .9701 - relation: 0 .9836 Epoch 20 /20 500 /500 [==============================] - 1s 2ms/step - loss: 100 .7719 - relation: 0 .9836 Begin to test: --------------- 10 /10 [==============================] - 0s 5ms/sample - loss: 94 .8883 - relation: 0 .9897 Evaluated loss ( losses.MeanSquaredError ) = 94 .88829040527344 Evaluated metric ( Pearson ' s correlation ) = 0 .9897396 以上结果是不加任何参数的前提下，直接以默认参数运行程序得到的。结果显明，MSE最后收敛在100左右，因为我们馈入的label添加了标准差为10的白噪声，对应的方差为100。可知，实验结果与预期一致。另一方面，我们可以看到，相关系数在这里可以充当类似准确度的作用，考虑到我们默认的噪声为10，这一相关系数的收敛结果是符合我们的预期的。 我们还可以注意到，这段代码中，生成测试集的代码被提前了，这是为了确保每次运行程序，只要指定了种子，生成的测试集总是一致的。 现在，我们可以导出生成数据了，首先，我们改变不同的优化器，其他参数全部一致，例如，学习率均为0.01（Adadelta除外，其初始参数一般推荐为1.0）。调用代码时的参数设置如下 python lin-reg.py -e 25 -sd 1 -do test/algorithm/ { optimizer } -o { optimizer } 其中我们用 {optimizer} 来指代我们选用的优化算法。同时，我们固定测试的epoch数量为25，这是因为有些算法的收敛速度不足以保证20个epoch收敛。 接下来，我们固定优化器为Adam，改变不同的噪声，分别令标准差为0, 1, 5, 10, 50, 100，产生多组结果。 python lin-reg.py -sd 1 -do test/noise/ { noise } -is { noise }","text_tokens":["9832","加","29","其中","17","18","一节","27","形式","测试","generate","99","94","线性","部分","其他","shape","0.01","了","500","1","'","固定","testbatchnum","下来","dataset","relation","1930","同时","c","26","2ms","32","9897396","8705","meansquarederror","时","13","get","以上","选用","决定","可知","construct","^","compressed","方差","收敛","调试","结果","is","迭代","noise","test","output","35","5ms","w","_","接下来","training","sd","24","model","采用","5","相关","optimizername","adadelta","lowrank","algorithm","\\","linreghandle","31","steppe","10","pred","29084","学习","100","}","yp","6678","8801","训练","可以","336","37","得到","pearson","train","4","results","足以","15669","record","savez","9838","是","b","好","1278","由","不足","19","9836","testdataregset","(","用户","因为","主","系数","馈入",".","这","变换","，","input","首先","testing","adam","方面","同样","6048","将","0431","rank","uniform","段","对应","sample","左右","5899","总是","程序","6665","种子","9701","7134","101","8883",":","接下","设置","[","有些","分别","2465","标准","losses","随机","label","并","corr","print","提前","改变","函数","一般","not","20","仿射变换","set","learningrate","器","boldsymbol","注意","learning","显明","9831","1477","varepsilon","保证","1856","args","21","类似","不加","指代","6994","优化","考虑","mathbf","令","9897","8130","+","23","9354","准确度","12","8600","7719","correlation","率均","r","gen","准确","构成","矩阵","0838","11","y","50","调用","lin","现在","14","导出","：","28","与","s","22","e","关系","其","88829040527344","0","默认","例如","to","在","另一方","产生","3472","check","34","符合","这一","线性变换","799","if","只要","上","166","np","sim","这是","1.0","cls","噪声","来","不足以","batch","none","8547","白","rate","/","标准差","指定","25","秩","8145","并且","loss","layer","step","近似","30","）","reg","samples","的",",","15","of","初始","x","作用","还","initialization","outputdata","h","该","器为","mse","为了","次","0s","相关系数","默认值","进行","2","集","是因为","样本","9","4000","history","代码","给定","mathbb","修改","确保","seed","以","多组","16","py","全部","速度","random","the","一方","normal","data","9813","为","每次","算法","values","用","最后","数据","epoch","{","~","6","到","config","9834","秩为","不","save","33","102","另一方面","regressed","5597","这里","任何","9833","除外","1000","一方面","1s","不同","输出","evaluated","6636","for","添加","iter","mapsto","metric","前提","我们","生成","2459","如下","个","参数设置","setseed","3","参数","n","a","成","begin","9579","group","（","数量","it","9700","p","do","网络","直接","看到","低","trainbatchnum","被"," ","]","36","每个","and","运行","推荐","实验","一致","仿射","预期","#","mathcal",")","7","dense1","4556","充当","-","o","8","=","9835","113","。","name","下","weights","dp","扰动","next","python","中","optimizer"],"title":"使实验代码保存输出","title_tokens":["输出","使","实验","代码","保存"]},{"location":"book-1-x/chapter-1/linear-regression/#toolspy","text":"首先，在 tools.py 中定义数据解析函数 tools.py 1 2 3 4 5 6 7 8 9 10 11 12 def parseData ( path , keys ): keys_list = dict (( k , []) for k in keys ) name_list = [] for f in os . scandir ( path ): if f . is_file (): name , _ = os . path . splitext ( f . name ) name_list . append ( name . replace ( '_' , ' ' )) data = np . load ( os . path . join ( path , f . name )) for key in keys : keys_list [ key ] . append ( data [ key ]) epoch = data [ 'epoch' ] return name_list , epoch , keys_list 该函数的作用是，给定保存输出文件的文件夹路径，能够自动读取文件夹下所有数据文件，并将不同文件的结果列在列表的不同元素中。 keys 关键字能帮助我们指派我们关心的数据字段。 接下来，我们通过如下代码，对比不同优化器条件下的损失函数和测度函数，对比不同噪声条件下的损失函数和测度函数，输出的曲线反映了对训练过程的跟踪。 tools.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def showCurves ( path , prefix = '{0}' , converter = str ): ''' Show curves from different tests in a same folder. ''' name_list , epoch , keys_list = parseData ( path , [ 'loss' , 'corr' ]) loss_list = keys_list [ 'loss' ] corr_list = keys_list [ 'corr' ] if ( not loss_list ) or ( not corr_list ): raise FileExistsError ( 'No data found, could not draw curves.' ) for i in range ( len ( loss_list )): plt . semilogy ( loss_list [ i ], label = prefix . format ( converter ( name_list [ i ])), marker = MARKERS [ i % 9 ], markevery = 3 ) plt . legend () plt . xlabel ( 'epoch' ), plt . ylabel ( 'MSE' ) plt . gcf () . set_size_inches ( 5 , 5 ), plt . tight_layout (), plt . show () for i in range ( len ( corr_list )): plt . plot ( corr_list [ i ], label = prefix . format ( converter ( name_list [ i ])), marker = MARKERS [ i % 9 ], markevery = 3 ) plt . legend () plt . xlabel ( 'epoch' ), plt . ylabel ( 'Pearson \\' s correlation' ) plt . gcf () . set_size_inches ( 5 , 5 ), plt . tight_layout (), plt . show () showCurves ( './test/algorithm' ) showCurves ( './test/noise' , prefix = 'ε=N(0,{0})' , converter = int ) Output (优化器) 损失函数 (MSE) 测度函数 (相关系数) Output (噪声) 损失函数 (MSE) 测度函数 (相关系数) 可见，损失曲线反映了训练的进度，而测度曲线反映了当前的准确度。我们可以得到如下结论： 令人意外的是，SGD和Nesterov动量法收敛速度最快。这是由于这两种方法没有引入对学习率的调整。我们使用的损失函数初始点梯度非常大，这使得简单的方法，形如SGD和动量法在一开头就取得了非常迅速的下降；而对那些需要调整学习率的算法而言，初始梯度在很大的情况下，会导致初始学习率被降到较小的水准。这就是为何Adagrad几乎不收敛的原因，因为一开始这一算法的学习率就被大梯度抑制到将近0的水平了，导致训练无法为继； 在调整学习率的算法里，收敛速度有 RMSprop > Adam = NAdam > Adamax = AMSgrad > Adadelta。从AMSgrad以上的这些算法都可资利用，Adadelta的原理和RMSprop几乎相同但效果相差甚巨，这是由于参数不同引起的，我们虽然将Adadelta的学习率特地设为 1.0 ，仍然远远不如RMSprop，可见一个合适的参数对算法的重要性。 噪声的输出结果并不令人意外，所有噪声条件下的MSE最后都收敛到对应的噪声方差上。 为了检查测试集的情况，我们通过以下函数来绘制比较不同样本在不同优化器、不同噪声条件下的RMSE（均方根误差）， tools.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def showBars ( path , prefix = '{0}' , converter = str , ylim = None ): ''' Show bar graphs for RMSE for each result ''' name_list , epoch , keys_list = parseData ( path , [ 'test_y' , 'pred_y' ]) #print(keys_list) ytrue_list = keys_list [ 'test_y' ] ypred_list = keys_list [ 'pred_y' ] def RMSE ( y_true , y_pred ): return np . sqrt ( np . mean ( np . square ( y_true - y_pred ), axis = 1 )) N = ytrue_list [ 0 ] . shape [ 0 ] NG = len ( ytrue_list ) for i in range ( NG ): plt . bar ([ 0.6 + j + 0.8 * i / NG + 0.4 / NG for j in range ( - 1 , 9 , 1 )], RMSE ( ytrue_list [ i ], ypred_list [ i ]), width = 0.8 / NG , label = prefix . format ( converter ( name_list [ i ]))) plt . legend ( ncol = 5 ) plt . xlabel ( 'sample' ), plt . ylabel ( 'RMSE' ) if ylim is not None : plt . ylim ([ 0 , ylim ]) plt . gcf () . set_size_inches ( 12 , 5 ), plt . tight_layout (), plt . show () showBars ( './test/algorithm' , ylim = 70 ) showBars ( './test/noise' , prefix = 'ε=N(0,{0})' , converter = int ) Output (优化器) Output (噪声) 上述结果反映了 测试结果和训练情况相仿，这是由于我们的训练集和测试机完全独立同分布； Adadelta和Adagrad还没有训练好，它们的误差明显大于其他算法。且Adagrad已经无法收敛，可见这种算法不实用。 再接下来，我们要分别展示不同测试下的输出。下面列举的所有输出由该函数所产生： tools.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 def saveResults ( path , opath , oprefix , datakeys , title = '' , xlabel = None , ylabel = None , onlyFirst = False , plot = False , prefix = ' ({0})' , converter = str ): ''' Save result graphs to a folder. ''' name_list , _ , data_list = parseData ( path , datakeys ) if plot : # show curves c_list = data_list [ 'c' ] b_list = data_list [ 'b' ] NG = len ( b_list ) for i in range ( NG ): plt . plot ( c_list [ i ] . T , label = 'c' ) plt . plot ( b_list [ i ] . T , label = 'b' ) plt . legend () plt . gca () . set_title ( title + prefix . format ( converter ( name_list [ i ]))) if xlabel is not None : plt . xlabel ( xlabel ) if ylabel is not None : plt . ylabel ( ylabel ) plt . gcf () . set_size_inches ( 5 , 5 ) if onlyFirst : formatName = '' else : formatName = name_list [ i ] . replace ( ' ' , '_' ) plt . savefig ( os . path . join ( opath , oprefix + '{0}.svg' . format ( formatName ))) plt . close ( plt . gcf ()) if onlyFirst : return else : # show images data_list = data_list [ datakeys [ 0 ]] NG = len ( data_list ) for i in range ( NG ): plt . imshow ( data_list [ i ], interpolation = 'nearest' , aspect = 'auto' ), plt . colorbar (), plt . gca () . set_title ( title + prefix . format ( converter ( name_list [ i ]))) if xlabel is not None : plt . xlabel ( xlabel ) if ylabel is not None : plt . ylabel ( ylabel ) plt . gcf () . set_size_inches ( 6 , 5 ) if onlyFirst : formatName = '' else : formatName = name_list [ i ] . replace ( ' ' , '_' ) plt . savefig ( os . path . join ( opath , oprefix + '{0}.png' . format ( formatName ))) plt . close ( plt . gcf ()) if onlyFirst : return 测试代码 1 2 3 4 5 6 7 8 9 10 11 12 13 def saveAllResults (): saveResults ( './test/algorithm' , './record/algorithm' , 'alg-A-' , [ 'A' ], title = 'A' , prefix = '' , onlyFirst = True ) saveResults ( './test/algorithm' , './record/algorithm' , 'alg-yt-' , [ 'test_y' ], title = 'True values' , prefix = '' , onlyFirst = True ) saveResults ( './test/algorithm' , './record/algorithm' , 'alg-y-' , [ 'pred_y' ], title = 'Predicted values' ) saveResults ( './test/algorithm' , './record/algorithm' , 'alg-W-' , [ 'W' ], title = 'W' ) saveResults ( './test/algorithm' , './record/algorithm' , 'alg-cb-' , [ 'c' , 'b' ], title = 'Biases' , plot = True ) saveResults ( './test/noise' , './record/noise' , 'noi-A-' , [ 'A' ], title = 'A' , prefix = '' , onlyFirst = True ) saveResults ( './test/noise' , './record/noise' , 'noi-yt-' , [ 'test_y' ], title = 'True values' , prefix = ' (ε=N(0,{0}))' , converter = int ) saveResults ( './test/noise' , './record/noise' , 'noi-y-' , [ 'pred_y' ], title = 'Predicted values' , prefix = ' (ε=N(0,{0}))' , converter = int ) saveResults ( './test/noise' , './record/noise' , 'noi-W-' , [ 'W' ], title = 'W' , prefix = ' (ε=N(0,{0}))' , converter = int ) saveResults ( './test/noise' , './record/noise' , 'noi-cb-' , [ 'c' , 'b' ], title = 'Biases' , plot = True , prefix = ' (ε=N(0,{0}))' , converter = int ) saveAllResults () 首先考虑不同优化器的测试，在这些测试里，我们确保 \\mathbf{A},~\\mathbf{c} \\mathbf{A},~\\mathbf{c} 对所有测试相同，且产生的随机数据真值 \\mathbf{y}_{\\mathrm{true}} \\mathbf{y}_{\\mathrm{true}} 对所有测试也相同，亦即： \\mathbf{A} \\mathbf{A} \\mathbf{y} \\mathbf{y} 的真实值 于是我们可得到所有的数据 优化器 \\mathbf{y} \\mathbf{y} 的预测值 \\mathbf{W} \\mathbf{W} \\mathbf{b} \\mathbf{b} 与 \\mathbf{c} \\mathbf{c} Adadelta Adagrad Adam Adamax AMSgrad Nesterov Adam Nesterov Moment RMSprop SGD 接下来考虑不同噪声的测试，在这些测试里，我们确保 \\mathbf{A},~\\mathbf{c} \\mathbf{A},~\\mathbf{c} 对所有测试相同，但由于噪声大小的不同，随机数据真值 \\mathbf{y}_{\\mathrm{true}} \\mathbf{y}_{\\mathrm{true}} 会有所偏差： \\mathbf{A} \\mathbf{A} 于是我们可得到所有的数据 \\boldsymbol{\\varepsilon} \\sim N(0,~?) \\boldsymbol{\\varepsilon} \\sim N(0,~?) \\mathbf{y} \\mathbf{y} 的真实值 \\mathbf{y} \\mathbf{y} 的预测值 \\mathbf{W} \\mathbf{W} \\mathbf{b} \\mathbf{b} 与 \\mathbf{c} \\mathbf{c} 0 1 5 10 50 100 我们最为看重的，其实是是否拟合出 \\mathbf{A} \\mathbf{A} 和 \\mathbf{c} \\mathbf{c} 。一系列实验表明， \\mathbf{W} \\mathbf{W} 和 \\mathbf{b} \\mathbf{b} 的拟合效果甚好。由于我们建立的仿射变换模型和原始仿射变换模型有着完全一致的结构，优化结果反映这一问题的解相当准确。至此，我们已经掌握了一个完整的Project应当具有的模块结构，以及对不同的优化器有了理论和实际的体验。在后续的章节里，除非有特别的应用，我们不再探讨不同的优化器对结果的影响，在绝大多数情况下，我们都将使用AMSgrad。","text_tokens":["偏差","42","29","17","列表","18","对比","datakeys","看重","size","key","27","均","关心","测试","至此","alg","fileexistserror","除非","后续","且","件夹","多数","和","sgd","其他","shape","了","cb","1","'","；","相同","绘制","images","下来","使用","rmsprop","c","点","情况","f","int","预测值","26","32","title","ytrue","13","xlabel","以上","相仿","square","原始","rmse","会","一系列","方差","特地","收敛","结果","机","is","ylim","重要性","探讨","noise","曲线","损失","width","parsedata","saveresults","amsgrad","ε","test","output","使得","nadam","35","w","colorbar","_","接下来","axis","完整","结论","plt","k","24","39","文件","小","关键字","5","相关","具有","adadelta","预测","oprefix","algorithm","模块","建立","\\","仍然","而言","31","所","法","interpolation","10","showcurves","pred","降到","学习","明显","100","}","水平","formatname","训练","dict","可以","37","得到","pearson","def","38","4","虽然","最快","列举","动量","甚巨","方根","record","将近","是","or","str","b","load","好","亦","19","(","分布","水准","因为","应当","系数","从","跟踪","形如",".","非常","*","再","这","引入","变换","，","path","show","大多数","首先","join","较","adam","return","44","biases","两种","甚","将","完全一致","可","段","ypred","draw","t","对应","sample","没有","原理","路径","aspect","真值","else","比较","绝大","这种","所有","特别","46","要",":","接下","[","分别","adagrad","随机","could","list","label","应用","并","corr","tight","print","0.8","函数","predicted","数据字","not","20","远远","效果","仿射变换","set","format","replace","由于","器","boldsymbol","大","里","converter","project",">","varepsilon","45","21","都","优化","考虑","测试代码","mathbf","其实","关键","i","+","23","legend","准确度","12","onlyfirst","correlation","大于","range","下面","准确","完全","可见","semilogy","一个","11","43","y","50","一系","scandir","有所","定义数据","于是","过程","14","进度","false","帮助","大小","原因","对","different","：","28","与","开头","s","22","关系","真实","出","读取","0","svg","无法","gca","auto","to","相当","在","gcf","定义","以及","大多","不如","体验","产生","相差","检查","34","这一","合适","if","上","np","sim","这是","1.0","重要","几乎","最为","列","利用","噪声","那些","来","简单","none","0.4","保存","为何","指派","文件夹","no","?","理论","/","saveallresults","意外","bar","25","png","而","loss","已经","j","savefig","）","30","反映","graphs","的",",","inches","可资利用","一","15","初始","true","作用","还","章节","令人","也","调整","nesterov","引起","很大","该","mse","41","它们","为了","相关系数","mean","当前","器有","2","集","有着","以下","9","代码","样本","开始","0.6","70","给定","自动","确保","取得","但","each","16","py","moment","速度","ncol","prefix","noi","模型","result","上述","远远不如","same","in","data","为","算法","下降","%","values","最后","数据","from","值","epoch","{","~","远不如","ng","folder","6","sqrt","到","os","不","save","独立","就是","系列","opath","33","layout","方法","是否","tools","设","markevery","append","影响","率","keys","curves","绝大多数","不同","输出","展示","梯度","tests","由该","ylabel","40","误差","元素","for","plot","解","测度","我们","同","如下","表明","数据文件","3","参数","n","解析","a","通过","len","条件","掌握","拟合","（","继","能","导致","mathrm","raise","实用","nearest","结构","迅速","被","抑制"," ","有","法在","yt","file","就","]","markers","36","实验","splitext","一致","仿射","#","实际","需要",")","7","-","imshow","8","能够","=","。","adamax","name","问题","这些","下","、","showbars","found","close","不再","即","中","marker"],"title":"在tools.py中分析比较结果","title_tokens":["分析","结果","比较","在","py","中","tools","."]},{"location":"book-1-x/chapter-1/nonlinear-regression/","text":"非线性回归 ¶ 摘要 本节将讨论如何将一个解析的非线性的回归问题，表述成使用非线性函数激活的线性回归问题。特别地，我们将通过自己定义“激活层”来引入我们定义的解析的非线性函数。 理论 ¶ 一般回归问题 ¶ 回忆我们的多输出方程 \\mathbf{y} = \\mathcal{F}(x) \\mathbf{y} = \\mathcal{F}(x) ，其中 \\mathcal{F} \\mathcal{F} 可以是非线性函数，那么我们可以考虑使用一个带可调参数的模型 \\mathbf{D}_{\\boldsymbol{\\Theta}}(\\mathbf{x}) \\mathbf{D}_{\\boldsymbol{\\Theta}}(\\mathbf{x}) 来模拟它，其中 \\boldsymbol{\\Theta} \\boldsymbol{\\Theta} 是可调的参数。于是，该问题可以被表述为 \\begin{equation} \\begin{aligned} \\arg \\min_\\limits{\\boldsymbol{\\Theta}} &\\sum_{k=1}^N \\mathcal{L} \\left( \\mathbf{y}_k,~ \\mathbf{D}_{\\boldsymbol{\\Theta}}(\\mathbf{x}_k) \\right),\\\\ \\mathrm{s.t.}~&\\mathbf{y}_k = \\mathcal{F}(\\mathbf{x}_k). \\end{aligned} \\end{equation} 其中， (\\mathbf{x}_k,~\\mathbf{y}_k) \\in \\mathbb{D} (\\mathbf{x}_k,~\\mathbf{y}_k) \\in \\mathbb{D} 来自由非线性函数 \\mathcal{F} \\mathcal{F} 产生的数据集。 非线性解析函数的分解 ¶ 对于一个解析的非线性函数，我们假设任何这样的函数都可以分解成多个复合函数 \\mathbf{f}_i \\mathbf{f}_i ，其中每个复合函数都只包含一个仿射变换 \\mathbf{h}_j = \\mathbf{W}_j \\cdot + \\mathbf{b}_j \\mathbf{h}_j = \\mathbf{W}_j \\cdot + \\mathbf{b}_j 和一个对在各元素操作的非线性激活函数 \\Lambda_j \\Lambda_j 。因此，复合函数可以写作 \\mathbf{f}_i = \\Lambda_j \\circ \\mathbf{h}_j \\mathbf{f}_i = \\Lambda_j \\circ \\mathbf{h}_j 。于是，整个非线性的函数可以表述为： \\begin{equation} \\begin{aligned} \\mathcal{F} = \\Lambda_M \\circ \\mathbf{h}_M \\circ \\Lambda_{M-1} \\circ \\mathbf{h}_{M-1} \\circ \\cdots \\Lambda_1 \\circ \\mathbf{h}_1. \\end{aligned} \\end{equation} 例如，对函数 \\begin{align} \\mathcal{F}(\\mathbf{x}) = \\exp( \\mathbf{A} \\log ( | \\mathbf{B} \\mathbf{x} + \\mathbf{c} | ) ). \\end{align} 可以分解为： \\mathbf{h}_1 (\\mathbf{x}) = \\mathbf{B} \\mathbf{x} + \\mathbf{c} \\mathbf{h}_1 (\\mathbf{x}) = \\mathbf{B} \\mathbf{x} + \\mathbf{c} ； \\Lambda_1 (\\mathbf{h}_1) = \\log ( | \\mathbf{h}_1 | ) \\Lambda_1 (\\mathbf{h}_1) = \\log ( | \\mathbf{h}_1 | ) ； \\mathbf{h}_2 (\\Lambda_1) = \\mathbf{A} \\Lambda_1 \\mathbf{h}_2 (\\Lambda_1) = \\mathbf{A} \\Lambda_1 ； \\Lambda_2 (\\mathbf{h}_2) = \\exp ( \\mathbf{h}_2 ) \\Lambda_2 (\\mathbf{h}_2) = \\exp ( \\mathbf{h}_2 ) 。 实际上，当然还存在更复杂的情况，例如，一个非线性函数 \\mathbf{f}_j \\mathbf{f}_j 是两个非线性函数的和、积、商，或是某函数导数的范数等……但原则上，这些函数都可以写作上述（多个）可分解复合函数的（联合）变换。本质上，函数中的任何参数，都可以看作是在参与一个仿射变换。因此，任何函数只要能写出解析式，理论上就能分解为（多个）上述的可分解函数的形式。 相信有一点功底的读者都可以看出， (2) (2) 其实就是一个神经网络的表达式。换言之，只要知道一个函数的解析式，我们就可以用一个或多个神经网络来为其建模。虽然我们可能不知道这个函数里具体的参数值，但通过对网络训练，我们可以让网络的参数回归到函数的参数上。 本节问题 ¶ 考虑一组三角函数的线性组合，使得列向量 \\mathbf{x} \\in \\mathbb{R}^T \\mathbf{x} \\in \\mathbb{R}^T 映射到列向量 \\mathbf{y} \\in \\mathbb{R}^T \\mathbf{y} \\in \\mathbb{R}^T ，其中 \\mathbf{x} \\mathbf{x} ， \\mathbf{y} \\mathbf{y} 均为时间域上的变量，则： \\begin{align} \\mathbf{y} = \\sum_{i=1}^N a_i \\cos ( \\omega_i \\mathbf{x} + \\varphi_i ). \\end{align} 如果我们将其写成矩阵的形式，应当有 \\begin{align} \\mathbf{y} = \\cos ( \\mathbf{x} \\boldsymbol{\\omega}^T + \\mathbf{1} \\boldsymbol{\\varphi}^T ) \\mathbf{a}. \\end{align} 设若我们有大量的样本 (\\mathbf{x}_k,~\\mathbf{y}_k) (\\mathbf{x}_k,~\\mathbf{y}_k) ，但我们不知道参数 \\boldsymbol{\\omega},~\\boldsymbol{\\varphi},~\\mathbf{a} \\boldsymbol{\\omega},~\\boldsymbol{\\varphi},~\\mathbf{a} 。若我们想在频率域上拟合出该模型的参数，则根据 (1) (1) ，该问题可以写作： \\begin{equation} \\begin{aligned} \\arg \\min_\\limits{\\boldsymbol{\\omega},~\\boldsymbol{\\varphi},~\\mathbf{a}} &\\sum_{k=1}^K \\lVert \\mathrm{Re}\\{\\mathbf{Y}_k - \\hat{\\mathbf{Y}}_k \\} \\rVert_2^2 + \\lVert \\mathrm{Im}\\{\\mathbf{Y}_k - \\hat{\\mathbf{Y}}_k \\} \\rVert^2_2,\\\\ \\mathrm{s.t.}~&\\mathbf{Y}_k = \\mathrm{FFT}(\\mathbf{y}_k), \\\\ &\\hat{\\mathbf{Y}}_k = \\mathrm{FFT}(\\cos ( \\mathbf{x}_k \\boldsymbol{\\omega}^T + \\mathbf{1} \\boldsymbol{\\varphi}^T ) \\mathbf{a}). \\end{aligned} \\end{equation} 其中，FFT指 快速傅里叶变换 ，虽然FFT是一个线性变换，但显然，该问题是一个非线性问题，这是由于预测值的表达式 \\hat{\\mathbf{y}} \\hat{\\mathbf{y}} 的表达式 (5) (5) 是非线性的。 由于表达式 (5) (5) 是一个显式函数，相比上一节求取低秩近似的仿射变换，我们可以知道，即使该问题即使存在多个不同的 \\mathbf{x}_k \\mathbf{x}_k 对应同一个 \\mathbf{y}_k \\mathbf{y}_k ，也不影响我们对问题的求解（即训练得到的参数能和真实参数产生相同的输出）。然而，从这里的参数的定义可以看出，我们在这个问题中使用的参数是非常低秩的（所有的参数秩均为1），这将导致这个问题的解具有高度的不确定性，许多不同的参数组 \\boldsymbol{\\omega},~\\boldsymbol{\\varphi},~\\mathbf{a} \\boldsymbol{\\omega},~\\boldsymbol{\\varphi},~\\mathbf{a} 均能达到相同的效果。例如，我们已知三个参数向量是长度相同的，若我们选取三个向量各自的第 i i 个元素，和其对应的第 j j 个元素相互交换（例如 \\omega_i \\leftrightarrow \\omega_j \\omega_i \\leftrightarrow \\omega_j ），则根据 (4) (4) ，这两个不同的解均能产生相同的效果。另一个例子是，由于余弦函数具有周期性，对 \\boldsymbol{\\varphi} \\boldsymbol{\\varphi} 的任意元素 \\varphi_i \\varphi_i ，即使令 \\varphi_i = \\varphi_i + 2 \\pi \\varphi_i = \\varphi_i + 2 \\pi ，仍不影响拟合的效果。因此，通过 (6) (6) 求解的向量 \\boldsymbol{\\varphi} \\boldsymbol{\\varphi} 也具有不确定性。 根据我们前面提到的对非线性解析函数的分解方法，该问题的模型可以分解为： \\mathbf{h}_1 (\\mathbf{x})= \\mathbf{x} \\boldsymbol{\\omega}^T + \\mathbf{1} \\boldsymbol{\\varphi}^T \\mathbf{h}_1 (\\mathbf{x})= \\mathbf{x} \\boldsymbol{\\omega}^T + \\mathbf{1} \\boldsymbol{\\varphi}^T ； \\Lambda_1 (\\mathbf{h}_1) = \\cos ( \\mathbf{h}_1 ) \\Lambda_1 (\\mathbf{h}_1) = \\cos ( \\mathbf{h}_1 ) ； \\mathbf{h}_2 (\\Lambda_1) = \\Lambda_1 \\mathbf{a} \\mathbf{h}_2 (\\Lambda_1) = \\Lambda_1 \\mathbf{a} ； \\hat{\\mathbf{Y}} = \\Lambda_2 (\\mathbf{h}_2) = \\mathrm{FFT} ( \\mathbf{h}_2 ) \\hat{\\mathbf{Y}} = \\Lambda_2 (\\mathbf{h}_2) = \\mathrm{FFT} ( \\mathbf{h}_2 ) 。 解非线性回归问题 ¶ 我们已经知道，该问题可以建立成一个两层的模型，两层的变换函数和激活函数分别为 (\\mathbf{h}_1,~\\Lambda_1) (\\mathbf{h}_1,~\\Lambda_1) , (\\mathbf{h}_2,~\\Lambda_2) (\\mathbf{h}_2,~\\Lambda_2) 。然而，实现该模型仍然存在技术问题。即，神经网络中，并未定义 \\mathbf{h}_1,~\\mathbf{h}_2,~\\Lambda_2 \\mathbf{h}_1,~\\mathbf{h}_2,~\\Lambda_2 的层API，因此，我们必须自己来实现这些功能。 这一节讨论的内容更偏向于技术实现，而且对新入门的读者而言具有一定的难度。但本节讨论的技术，即自定义网络层，实在是非常广泛地应用在Keras API的用户中。例如，著名的Residual network和Inception network，在Tensorflow-Keras API中均未提供现成的API，需要读者自行设法构造。 熟悉旧版Tensorflow的用户，可能会发现，在实现自定义API的过程上，旧版API使用起来更容易上手；然而，Keras式的API也有其好处，那就是强制用户必须按照规范、统一的标准处理API的定义和接口，使得用户更容易建立规范的编写习惯。 自定义网络层 ¶ 自定义Keras层的方法可以参照： 编写你自己的Keras层 - Keras中文文档 编写好的层是一个类API，可以同时被顺序模型或类模型调用。 学习一个完全规范化的风格 ¶ 让我们观察Tensorflow-keras模型对最简单的层，全连接层 Dense 的定义（我们之前也分别在顺序模型和类模型中使用过该API）。下面的内容摘自 Tensorflow源码 ： import 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from tensorflow.python.eager import context from tensorflow.python.framework import common_shapes from tensorflow.python.framework import ops from tensorflow.python.framework import tensor_shape from tensorflow.python.keras import activations from tensorflow.python.keras import backend as K from tensorflow.python.keras import constraints from tensorflow.python.keras import initializers from tensorflow.python.keras import regularizers from tensorflow.python.keras.engine.base_layer import Layer from tensorflow.python.keras.engine.input_spec import InputSpec from tensorflow.python.keras.utils import conv_utils from tensorflow.python.keras.utils import generic_utils from tensorflow.python.keras.utils import tf_utils from tensorflow.python.ops import array_ops from tensorflow.python.ops import gen_math_ops from tensorflow.python.ops import math_ops from tensorflow.python.ops import nn from tensorflow.python.ops import nn_ops from tensorflow.python.ops import standard_ops from tensorflow.python.util.tf_export import tf_export class Dense 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @tf_export ( 'keras.layers.Dense' ) class Dense ( Layer ): def __init__ ( self , units , activation = None , use_bias = True , kernel_initializer = 'glorot_uniform' , bias_initializer = 'zeros' , kernel_regularizer = None , bias_regularizer = None , activity_regularizer = None , kernel_constraint = None , bias_constraint = None , ** kwargs ) def build ( self , input_shape ) def call ( self , inputs ) def compute_output_shape ( self , input_shape ) def get_config ( self ) doc string 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class Dense ( Layer ): \"\"\"Just your regular densely-connected NN layer. `Dense` implements the operation: `output = activation(dot(input, kernel) + bias)` where `activation` is the element-wise activation function passed as the `activation` argument, `kernel` is a weights matrix created by the layer, and `bias` is a bias vector created by the layer (only applicable if `use_bias` is `True`). Note: if the input to the layer has a rank greater than 2, then it is flattened prior to the initial dot product with `kernel`. Example: # as first layer in a sequential model: model = Sequential() model.add(Dense(32, input_shape=(16,))) # now the model will take as input arrays of shape (*, 16) # and output arrays of shape (*, 32) # after the first layer, you don't need to specify # the size of the input anymore: model.add(Dense(32)) Arguments: units: Positive integer, dimensionality of the output space. activation: Activation function to use. If you don't specify anything, no activation is applied (ie. \"linear\" activation: `a(x) = x`). use_bias: Boolean, whether the layer uses a bias vector. kernel_initializer: Initializer for the `kernel` weights matrix. bias_initializer: Initializer for the bias vector. kernel_regularizer: Regularizer function applied to the `kernel` weights matrix. bias_regularizer: Regularizer function applied to the bias vector. activity_regularizer: Regularizer function applied to the output of the layer (its \"activation\").. kernel_constraint: Constraint function applied to the `kernel` weights matrix. bias_constraint: Constraint function applied to the bias vector. Input shape: nD tensor with shape: `(batch_size, ..., input_dim)`. The most common situation would be a 2D input with shape `(batch_size, input_dim)`. Output shape: nD tensor with shape: `(batch_size, ..., units)`. For instance, for a 2D input with shape `(batch_size, input_dim)`, the output would have shape `(batch_size, units)`. \"\"\" Dense.__init__ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Dense ( Layer ): def __init__ ( self , units , activation = None , use_bias = True , kernel_initializer = 'glorot_uniform' , bias_initializer = 'zeros' , kernel_regularizer = None , bias_regularizer = None , activity_regularizer = None , kernel_constraint = None , bias_constraint = None , ** kwargs ): if 'input_shape' not in kwargs and 'input_dim' in kwargs : kwargs [ 'input_shape' ] = ( kwargs . pop ( 'input_dim' ),) super ( Dense , self ) . __init__ ( activity_regularizer = regularizers . get ( activity_regularizer ), ** kwargs ) self . units = int ( units ) self . activation = activations . get ( activation ) self . use_bias = use_bias self . kernel_initializer = initializers . get ( kernel_initializer ) self . bias_initializer = initializers . get ( bias_initializer ) self . kernel_regularizer = regularizers . get ( kernel_regularizer ) self . bias_regularizer = regularizers . get ( bias_regularizer ) self . kernel_constraint = constraints . get ( kernel_constraint ) self . bias_constraint = constraints . get ( bias_constraint ) self . supports_masking = True self . input_spec = InputSpec ( min_ndim = 2 ) Dense.build 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Dense ( Layer ): def build ( self , input_shape ): input_shape = tensor_shape . TensorShape ( input_shape ) if tensor_shape . dimension_value ( input_shape [ - 1 ]) is None : raise ValueError ( 'The last dimension of the inputs to `Dense` ' 'should be defined. Found `None`.' ) last_dim = tensor_shape . dimension_value ( input_shape [ - 1 ]) self . input_spec = InputSpec ( min_ndim = 2 , axes = { - 1 : last_dim }) self . kernel = self . add_weight ( 'kernel' , shape = [ last_dim , self . units ], initializer = self . kernel_initializer , regularizer = self . kernel_regularizer , constraint = self . kernel_constraint , dtype = self . dtype , trainable = True ) if self . use_bias : self . bias = self . add_weight ( 'bias' , shape = [ self . units ,], initializer = self . bias_initializer , regularizer = self . bias_regularizer , constraint = self . bias_constraint , dtype = self . dtype , trainable = True ) else : self . bias = None self . built = True Dense.call 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Dense ( Layer ): def call ( self , inputs ): inputs = ops . convert_to_tensor ( inputs ) rank = common_shapes . rank ( inputs ) if rank > 2 : # Broadcasting is required for the inputs. outputs = standard_ops . tensordot ( inputs , self . kernel , [[ rank - 1 ], [ 0 ]]) # Reshape the output back to the original ndim of the input. if not context . executing_eagerly (): shape = inputs . get_shape () . as_list () output_shape = shape [: - 1 ] + [ self . units ] outputs . set_shape ( output_shape ) else : outputs = gen_math_ops . mat_mul ( inputs , self . kernel ) if self . use_bias : outputs = nn . bias_add ( outputs , self . bias ) if self . activation is not None : return self . activation ( outputs ) # pylint: disable=not-callable return outputs Dense.compute_output_shape 1 2 3 4 5 6 7 8 9 class Dense ( Layer ): def compute_output_shape ( self , input_shape ): input_shape = tensor_shape . TensorShape ( input_shape ) input_shape = input_shape . with_rank_at_least ( 2 ) if tensor_shape . dimension_value ( input_shape [ - 1 ]) is None : raise ValueError ( 'The innermost dimension of input_shape must be defined, but saw: %s ' % input_shape ) return input_shape [: - 1 ] . concatenate ( self . units ) Dense.get_config 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Dense ( Layer ): def get_config ( self ): config = { 'units' : self . units , 'activation' : activations . serialize ( self . activation ), 'use_bias' : self . use_bias , 'kernel_initializer' : initializers . serialize ( self . kernel_initializer ), 'bias_initializer' : initializers . serialize ( self . bias_initializer ), 'kernel_regularizer' : regularizers . serialize ( self . kernel_regularizer ), 'bias_regularizer' : regularizers . serialize ( self . bias_regularizer ), 'activity_regularizer' : regularizers . serialize ( self . activity_regularizer ), 'kernel_constraint' : constraints . serialize ( self . kernel_constraint ), 'bias_constraint' : constraints . serialize ( self . bias_constraint ) } base_config = super ( Dense , self ) . get_config () return dict ( list ( base_config . items ()) + list ( config . items ())) 为了便于读者阅读，我们将它按照重定义的方法分成了几片不同的代码。下面我们来分别观察不同代码里实现的内容。 初始化方法 ¶ 首先，在 __init__ 方法中，定义了用来初始化该层的所有可选参数。从这一段代码，可以观察到以下结论： units 是 Dense 的输出维度，是唯一一个必选参量，并用 int() 强制转换的方式确保输入的是整数。 除了布尔类型的输入，其他所有的输入都使用 tensorflow.python.keras 下的对应方法保护起来。例如， kernel_regularizer 的实现通过 keras.regularizers 方法初始化。这是为了确保用户使用该接口时，既可以使用字符串指定正则化器，也可以通过一个现成的正则化器实例来指定。 supports_masking 和 input_spec 这两个量由类本身决定，不受用户初始化参数的影响。 input_spec 用来限定输入网络的张量必须具有哪些属性，参见官方文档对 tf.keras.layers.InputSpec 的说明。 supports_masking 用来表示该输入是否支持 Masking 层，参见 Masking - Keras中文文档 对该层的介绍。它主要用来取消时序模型（一般是RNN/LSTM）中缺失的时间点数据对网络结果的影响。一般来说，一个与时序无关的（或者称为时不变(timeless)的）模型，直接设该值为True即可。 特别地， activity_regularizer 通过覆盖输入参量的默认值来实现。这是因为在 Dense 的父类 Layer 中，已经定义过 activity_regularizer 。其他的参量不能通过这种方式实现，是因为它们都跟新加入的参数有关。 构造方法 ¶ 接下来，让我们观察 build 方法。在该方法中，我们实现了网络中各参数的构造过程。 首先，通过 input_shape 来得到输入张量的形状。在本例中，特别检查了 input_shape 的规范性，确保输入数据的最后一个维度值为已知。因为， Dense 的API允许用户只通过输入来自上一层的张量，来推断全连接层的输入维度。特别地，如果我们的层有多个输入， input_shape 会是一个 list 类型。 接下来，通过 self.add_weight 或 self.add_variable 来添加参数。该方法的用法参见官方文档中的 Layers.add_weight 。它接受包括初始化器 initializer ，正则化器 regularizer 等一系列参数，这些参数都要求必须是具有回调属性的实例。这一条件我们已经在 __init__ 方法中满足了。 最后，设定 self.built 为 True 。事实上，Keras推荐我们使用类似 super ( Dense , self ) . build ( input_shape ) 的方式来完成这一设置，这种做法和显式地设定 self.built 等价。 回调方法 ¶ 接下来观察 call 方法。该方法接受的是该层实际输入的张量，同时也输出一个张量，该输出张量即使该层的输出结果。可以说，在该方法中，我们才正式开始实现层的实际功能。 在该范例中，该方法的实现是通过Tensorflow最底层的标准API。这些API对用户来说是封装起来的，一般情况下用户不需要使用它们。实际上，该方法实现的就是 \\mathbf{y} = \\mathbf{W} \\mathbf{x} + \\mathbf{b} \\mathbf{y} = \\mathbf{W} \\mathbf{x} + \\mathbf{b} 的过程。这种代码风格显得颇为繁琐，但是它提供了精密的参数检查和高效的API操作。我们不会讨论这段代码的具体实现细节，因为它既然是被封装的API，我们一般来说就不需要调用它们实现功能（除非我们需要修改使用同样被封装的底层API所编写的模块）。等价地，我们分别介绍Keras API和Tensorflow API如何做到相同的效果。 首先是Keras API版本的等效代码，它修改自 Keras中文文档 ： Dense.call 1 2 3 4 5 6 7 def call ( self , inputs ): res = K . dot ( inputs , self . kernel ) if self . use_bias : res = res + self . bias if self . activation is not None : res = self . activation ( res ) return res 接下来是Tensorflow API版本的等效代码， Dense.call 1 2 3 4 5 6 7 8 9 def call ( self , inputs ): inputs = tf . convert_to_tensor ( inputs ) rank = tf . rank ( inputs ) res = tf . tensordot ( inputs , self . kernel , [[ rank - 1 ], [ 0 ]]) if self . use_bias : res = tf . nn . bias_add ( inputs , self . bias ) if self . activation is not None : res = self . activation ( res ) return res 与Keras API的实现相比，Tensorflow API主要区别是使用 tf.tensordot 时需要指定执行矩阵计算的两轴。实际上，使用Tensorflow API对已经较为熟悉Tensorflow旧版API的用户是十分亲切的，它使我们找回了当初自己编写中层API的感觉。 输出形状方法 ¶ 接下来观察 compute_output_shape 方法。我们知道Tensorflow-Keras支持对每一层的输入输出作形状推断，而形状推断的具体实现就在这一步。 问题 为什么我们需要定义这个方法？难道我们不可以直接通过对输出张量计算 K.shape(output) 或 tf.shape(output) 来确定输出形状吗？ 这是由于，对Tensorflow-Keras而言，推断网络各层的形状和推断网络各层的张量是两码事。定义该方法能够确保我们在不调用任何一个 call 方法的前提下，推断出整个网络各层的输入、输出形状。 这里实现这一方法的过程仍然是调用Tensorflow的最底层API。事实上，Keras API对这一方法的输出并没有严格的要求，它可以是一个 tf.Shape ，可以是一个 list / tuple ，还可以是将两者元素混合在一起的 list 。我们不考虑对输入形状进行这些检查，那么，一个简单的，Keras风格的改写是 Dense.compute_output_shape 1 2 def compute_output_shape ( self , input_shape ): return ( * input_shape [:, - 1 ], self . units ) 或者我们可以更规范一点，使用Tensorflow API来确保该方法的输入、输出和具体操作都是对 tf.Shape 进行的 Dense.compute_output_shape 1 2 3 4 class Dense ( Layer ): def compute_output_shape ( self , input_shape ): input_shape = tensor_shape . TensorShape ( input_shape ) return input_shape [: - 1 ] . concatenate ( self . units ) 设置提取方法 ¶ 最后，在 get_config 中，我们将我们自定义的所有参数实例，通过 serialize 方法加入到该层的参数设置字典中。实现这一步是颇为重要的（但是在 Keras中文文档 中并未提及），它允许我们将我们自己定义的网络层编译成一个包含设置信息的字典，并允许我们通过该字典重构出具有相同参数设置的层来，参见： 关于Keras网络层 - Keras中文文档 例如，对一个 Dense 层，通过该方法重构的步骤是 1 2 3 layer = Dense ( 32 ) config = layer . get_config () reconstructed_layer = Dense . from_config ( config ) 综上，我们可以从官方代码如何定义 Dense 层学习到我们自己应该如何定义类似的层。事实上，我们建议读者在自定义任何层之前，先选择一个与我们要自定义的层形式相似的层，阅览官方代码，了解定义一个这样的层大致的步骤，然后再开始实际行动。 自定义第一层 ¶ 接下来，我们考虑来自己构造一个层API。该层的表达式为： \\begin{align} \\mathbf{y} = \\eta ( \\mathbf{x} \\boldsymbol{\\omega}^T + \\mathbf{1} \\boldsymbol{\\varphi}^T ), \\end{align} 这里 \\mathbf{x} \\mathbf{x} 为输入的列向量（但是注意在代码中它是行向量）， \\mathbf{1} \\mathbf{1} 是一个与 \\mathbf{x} \\mathbf{x} 形状相同的，值全为1的向量； \\boldsymbol{\\omega},~\\boldsymbol{\\varphi} \\boldsymbol{\\omega},~\\boldsymbol{\\varphi} 为可训练的参数，而 \\eta(\\cdot) \\eta(\\cdot) 是一个应用在元素级的激活函数。我们考虑实现以下功能： 该层输入一个形状为 [ N , L ] 的向量组，输出一个形状为 [ N , L , M ] 的矩阵组，其中 M 是参数 \\boldsymbol{\\omega} \\boldsymbol{\\omega} 的长度。因此，该层不需要获取输入向量的形状，但需要定义输出矩阵的列数 M 。换言之，该层的作用是将向量升维成低秩矩阵； 参数 \\boldsymbol{\\omega},~\\boldsymbol{\\varphi} \\boldsymbol{\\omega},~\\boldsymbol{\\varphi} 都可以指定初始化器、正则化器和限制条件，就像 Dense 层一样； 可以选择是否使用 \\boldsymbol{\\varphi} \\boldsymbol{\\varphi} ，就像在 Dense 层我们可以选择是否使用 biase 一样； 激活函数 \\eta(\\cdot) \\eta(\\cdot) 可以是一个任意的激活函数，并且允许我们为它添加正则化器。 综上，我们定义该层为 class UpDimAffine ( Layer ): UpDimAffine.__init__ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def __init__ ( self , units , activation = None , use_bias = True , kernel_initializer = 'glorot_uniform' , bias_initializer = 'zeros' , kernel_regularizer = None , bias_regularizer = None , activity_regularizer = None , kernel_constraint = None , bias_constraint = None , ** kwargs ): if 'input_shape' not in kwargs and 'input_dim' in kwargs : kwargs [ 'input_shape' ] = ( kwargs . pop ( 'input_dim' ),) super ( UpDimAffine , self ) . __init__ ( activity_regularizer = regularizers . get ( activity_regularizer ), ** kwargs ) self . units = int ( units ) self . activation = activations . get ( activation ) self . use_bias = use_bias self . kernel_initializer = initializers . get ( kernel_initializer ) self . bias_initializer = initializers . get ( bias_initializer ) self . kernel_regularizer = regularizers . get ( kernel_regularizer ) self . bias_regularizer = regularizers . get ( bias_regularizer ) self . kernel_constraint = constraints . get ( kernel_constraint ) self . bias_constraint = constraints . get ( bias_constraint ) self . supports_masking = True self . input_spec = InputSpec ( min_ndim = 2 ) UpDimAffine.build 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def build ( self , input_shape ): input_shape = tf . TensorShape ( input_shape ) self . kernel = self . add_weight ( 'kernel' , shape = [ 1 , self . units ], initializer = self . kernel_initializer , regularizer = self . kernel_regularizer , constraint = self . kernel_constraint , dtype = self . dtype , trainable = True ) if self . use_bias : self . bias = self . add_weight ( 'bias' , shape = [ 1 , self . units ], initializer = self . bias_initializer , regularizer = self . bias_regularizer , constraint = self . bias_constraint , dtype = self . dtype , trainable = True ) else : self . bias = None super ( UpDimAffine , self ) . build ( input_shape ) UpDimAffine.call 1 2 3 4 5 6 7 8 9 10 def call ( self , inputs ): inputs = tf . expand_dims ( tf . convert_to_tensor ( inputs ), - 1 ) rank = inputs . get_shape () . ndims res = tf . tensordot ( inputs , self . kernel , [[ rank - 1 ], [ 0 ]]) if self . use_bias : varbias = tf . tensordot ( tf . ones_like ( inputs ), self . bias , [[ rank - 1 ], [ 0 ]]) res = tf . add ( res , varbias ) if self . activation is not None : res = self . activation ( res ) return res UpDimAffine.compute_output_shape 1 2 3 def compute_output_shape ( self , input_shape ): input_shape = tensor_shape . TensorShape ( input_shape ) return input_shape . concatenate ( self . units ) UpDimAffine.get_config 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def get_config ( self ): config = { 'units' : self . units , 'activation' : activations . serialize ( self . activation ), 'use_bias' : self . use_bias , 'kernel_initializer' : initializers . serialize ( self . kernel_initializer ), 'bias_initializer' : initializers . serialize ( self . bias_initializer ), 'kernel_regularizer' : regularizers . serialize ( self . kernel_regularizer ), 'bias_regularizer' : regularizers . serialize ( self . bias_regularizer ), 'activity_regularizer' : regularizers . serialize ( self . activity_regularizer ), 'kernel_constraint' : constraints . serialize ( self . kernel_constraint ), 'bias_constraint' : constraints . serialize ( self . bias_constraint ) } base_config = super ( UpDimAffine , self ) . get_config () return dict ( list ( base_config . items ()) + list ( config . items ())) 这组定义完全启发自 Dense 的定义，因此改动其实不多，与 Dense 相比，主要的区别是 call 方法的实现。特别地，与 Dense 相同的是，我们使用 tf.tensordot 来指定对两个高维度的张量，取前一个张量的最后一维和第二个张量的第一维来进行矩阵乘法。 自定义第二层 ¶ 第二层的表达式为： \\begin{equation} \\begin{aligned} \\mathbf{y}_1 = \\mathrm{Re}\\{ \\mathrm{FFT}( \\mathbf{x} \\mathbf{a} ) \\}, \\\\ \\mathbf{y}_2 = \\mathrm{Im}\\{ \\mathrm{FFT}( \\mathbf{x} \\mathbf{a} ) \\}, \\end{aligned} \\end{equation} 这里 \\mathbf{x} \\mathbf{x} 为输入的矩阵， \\mathrm{FFT}(\\cdot) \\mathrm{FFT}(\\cdot) 是快速傅里叶变换。我们使用 \\mathbf{y}_1 \\mathbf{y}_1 和 \\mathbf{y}_2 \\mathbf{y}_2 来表示输出是具有两个通道的向量。我们考虑实现以下功能： 该层输入一个形状为 [ N , L , M ] 的向量组，输出一个形状为 [ N , l , 2 ] 的矩阵组，其中 L 在 l 为奇数时，取 (L+1)/2 ；在 L 为偶数时，取 L/2+1 ； 2 是两个通道，分别表示傅里叶变换的实部值和虚部值，同时，从输出可以看出傅里叶变换将使信号长度折半； 参数只有 \\mathbf{a} \\mathbf{a} ，它可以指定初始化器、正则化器和限制条件，就像 Dense 层一样； 我们不使用两输出的形式，而是使用单输出、两通道的形式来定义该层，是为了方便处理后续的步骤（计算损失函数）。 这里我们介绍一种新的定义层的方法，即“使用层来定义层”。该层定义为 class FFTAffine ( Layer ): FFTAffine.__init__ 1 2 3 4 5 6 7 8 9 10 11 def __init__ ( self , kernel_initializer = 'glorot_uniform' , kernel_regularizer = None , kernel_constraint = None , ** kwargs ): if 'input_shape' not in kwargs and 'input_dim' in kwargs : kwargs [ 'input_shape' ] = ( kwargs . pop ( 'input_dim' ),) super ( FFTAffine , self ) . __init__ ( ** kwargs ) self . kernel_initializer = initializers . get ( kernel_initializer ) self . kernel_regularizer = regularizers . get ( kernel_regularizer ) self . kernel_constraint = constraints . get ( kernel_constraint ) self . supports_masking = True self . input_spec = InputSpec ( min_ndim = 3 ) FFTAffine.build 1 2 3 4 5 6 7 8 def build ( self , input_shape ): input_shape = tf . TensorShape ( input_shape ) self . layer_Dense = tf . keras . layers . Dense ( 1 , use_bias = False , kernel_initializer = self . kernel_initializer , kernel_regularizer = self . kernel_regularizer , kernel_constraint = self . kernel_constraint ) self . layer_Dense . build ( input_shape ) super ( FFTAffine , self ) . build ( input_shape ) FFTAffine.call 1 2 3 4 5 6 7 def call ( self , inputs ): res = tf . squeeze ( self . layer_Dense ( inputs ), - 1 ) res = tf . signal . rfft ( res ) res_r = tf . expand_dims ( tf . real ( res ), - 1 ) res_i = tf . expand_dims ( tf . imag ( res ), - 1 ) res = tf . concat ([ res_r , res_i ], - 1 ) return res FFTAffine.compute_output_shape 1 2 3 4 5 6 7 8 9 10 def compute_output_shape ( self , input_shape ): input_shape = tf . TensorShape ( input_shape ) shape_lst = input_shape . as_list () if shape_lst [ - 2 ] is None : return input_shape [: - 1 ] . concatenate ( 2 ) else : if shape_lst [ - 2 ] % 2 == 0 : return input_shape [: - 2 ] . concatenate ( shape_lst [ - 2 ] // 2 + 1 ) . concatenate ( 2 ) else : return input_shape [: - 2 ] . concatenate (( shape_lst [ - 2 ] + 1 ) // 2 ) . concatenate ( 2 ) FFTAffine.get_config 1 2 3 4 5 6 7 8 def get_config ( self ): config = { 'kernel_initializer' : initializers . serialize ( self . kernel_initializer ), 'kernel_regularizer' : regularizers . serialize ( self . kernel_regularizer ), 'kernel_constraint' : constraints . serialize ( self . kernel_constraint ) } base_config = super ( FFTAffine , self ) . get_config () return dict ( list ( base_config . items ()) + list ( config . items ())) 首先，我们需要观察的是 __init__ 和 get_config 两个方法。由于该层只有一个参数 \\mathbf{a} \\mathbf{a} ，我们因此只需要为它指定初始化器、正则化器和限制条件即可。这一步和之前处理第一层的情况相似。 接下来，观察 build ，与定义第一层情况不同的是，在这里我们不是使用基本API (例如 add_weights )，而是来自 tf.keras.layers 的层API， Dense 。我们将初始化时构建的三个实例馈入 Dense 的参数中。并且，在这一阶段，我们不调用 Dense 处理张量，而是直接获取 Dense 的实例。 提示 注意我们在这里手动调用了 self.layer_Dense.build(input_shape) 。 在一些行内的人眼里，这一步是不可或缺的，因为只有调用了 build 方法，我们定义的 Dense 类才会实例化其内的参数。但事实不完全如此，即使我们去掉这一行，即不调用 Dense 的 build 方法，效果也完全一样。这是因为 Dense 的父类 Layer （当然也是我们继承的父类）具有检查 self.built 是否为 True 的能力，并在调用某些方法的时候，如果发现 self.built 为 False ，则自动调用 build 。这属于 build 方法的隐式调用。 虽然如此，我们仍然提倡用户一定要手动定义 build 。其一是因为，这种显式的定义在逻辑上是通顺、符合人的直觉的；其二是因为，我们不能完全确保自定义层里的所有子层的 build 方法一定会在任何情况下都能隐式触发。况且，这种做法是完全可行的，活用 compute_output_shape 或 tf.shape 等方法，我们可以做到手动触发一个有多个子层的自定义层中的所有子层的 build 方法。 提示 有些行内的人指出，在使用 build 方法时，应当显式地将子层的可训练、不可训练参数都反馈给自定义层的参数表（参见 StackOverflow的讨论串 ），具体的操作如下： self . _trainable_weights = self . layer_Dense . trainable_weights self . _non_trainable_variables = self . layer_Dense . non_trainable_variables 然而必须指出的是，这种做法是不正确的。因为观察 源代码 可以发现， trainable_weights 和 non_trainable_variables 都是封装好的属性方法。私有变量 _trainable_weights 和 _non_trainable_variables 与前者不同的是，这两个私有变量包含的是 直属于本层的可训练、不可训练变量 ；但前者的实现分别是 本层和本层的所有子层的所有可训练、不可训练变量 。因此，将子层的所有变量加诸自定义层的直属变量里，是多余、且容易造成误解的做法。 观察 call 方法，在该方法里，我们首先将维度为 [ N , L , M ] 的参数通过无bias的全连接层映射到 [ N , L , 1 ] ，再压缩最后一维度，得到维度为 [ N , L ] 的向量，通过Tensorflow自带的实值FFT变换函数 tf.signal.rfft ，得到复数域的输出 [ N , l ] ，对该输出分别取实部和虚部，再将两实值化的结果以通道的形式并在一起，最终我们就得到两通道的输出 [ N , l , 2 ] 。其中，第一个通道是傅里叶变换的实部，第二个通道是傅里叶变换的虚部。 信息 实际上，Tensorflow的官方教程给出了一种自定义层的范例，参看 Custom layers 。在这一范例中，使用 tf.keras.Model 定义一个有多个子层的模型，且该模型的使用方法和 Layer 一样。从某种程度上，这种方法比我们使用的方法更简洁。然而，需要指出的是， Model类继承 - Keras中文文档 也提到了这种做法，但使用 Model 类继承会导致网络具体实现的细节变得不可追索，具体而言就是形如 Model.to_json 、 Model.to_yaml 、 Model.get_config 和 Model.save 等方法变得不可用。 我们的这种做法则不存在这个问题，因为我们在每个自定义层里都定义了 get_config 方法，从而使得我们可以像使用内置的层API一样来使用它们。 最后，观察 compute_output_shape 方法，在这里，我们需要推断经过傅里叶变换后，输出向量的长度。特别地，我们需要考虑到，输入向量的长度已知和未知两种不同情况下的处理方式。 检测效果 ¶ 注意，在两个自定义层都定义好后，需要在两层定义的最后，加上如下代码： customObjects = { 'FFTAffine' : FFTAffine , 'UpDimAffine' : UpDimAffine } 该字典提供了一个索引表，将字符串形式的层名称映射到具体实现的类Object上。我们在任何涉及读取层的设置，例如 from_json 、 load_model 等方法中，都需要传入该索引表，确保Keras知道如何从配置文件里恢复出我们自定义的层。 如下代码提供了一个简单的两个自定义层叠加在一起的测试 test_layers 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import numpy as np def test_layers (): # Set model and see the summary of the model model = tf . keras . models . Sequential ([ UpDimAffine ( 10 , use_bias = True , activation = tf . math . cos , input_shape = ( 5 ,)), FFTAffine ( trainable = False ) ]) model . compile ( optimizer = optimizers . Adam ( 0.01 ), loss = tf . keras . losses . mean_squared_error , metrics = [ tf . keras . metrics . mean_squared_error ] ) model . summary () model . save ( 'my_model.h5' ) # perform the test var_input = np . ones ([ 2 , 5 ]) var_output = model . predict ( var_input ) print ( var_input . shape , var_output . shape ) print ( var_output ) test_layers () Output _________________________________________________________________ Layer ( type ) Output Shape Param # ================================================================= up_dim_affine ( UpDimAffine ) ( None, 5 , 10 ) 20 _________________________________________________________________ fft_affine ( FFTAffine ) ( None, 3 , 2 ) 10 ================================================================= Total params: 30 Trainable params: 20 Non-trainable params: 10 _________________________________________________________________ ( 2 , 5 ) ( 2 , 3 , 2 ) [[[ -3.25903225e+00 5 .96046448e-08 ] [ 1 .05201025e-07 -5.80141695e-08 ] [ 3 .23036957e-08 -3.17865378e-08 ]] [[ -3.25903225e+00 5 .96046448e-08 ] [ 1 .05201025e-07 -5.80141695e-08 ] [ 3 .23036957e-08 -3.17865378e-08 ]]] Bug 注意，Tensorflow目前的版本(r1.13)仍然有不完善之处。在上述测试中，如果我们把 tf.keras.losses.mean_squared_error 替换成 tf.keras.MeanSquaredError ，虽然该测试能正常跑通，但接下来读取已保存的网络时则会报错。这是由于目前版本的Tensorflow使用了部分废旧的API来定义读取配置的函数，在Github上的某个 讨论串 ，有人已经给出了解决方案，但仍然需要等候被新版Tensorflow采纳才能生效。 该测试首先通过顺序模型，引入了我们自定义的两个层，然后通过 summary 显示模型的详细结构，并通过 save 保存整个网络的模型配置以及具体的参数值。接下来使用一个值全为1的，形状为 [ 2 , 5 ] 的输入来测试该模型，并记录测试结果，与我们的预期完全相符。 同时，我们在设置两层的时候，刻意地令第二层的参数不可训练，实际显示的结果表明，该设置是成功的。第二个函数的10个参量确实在模型的记录里显示为不可训练的。 信息 关于如何保存网络，我们会在下一章详细展开。 接下来，为了证明我们的自定义层能完全正常地工作，我们进行读取测试， test_read 1 2 3 4 5 6 7 8 9 10 11 import numpy as np def test_read (): customObjects [ 'cos' ] = tf . math . cos new_model = tf . keras . models . load_model ( 'my_model.h5' , custom_objects = customObjects ) new_model . summary () var_input = np . ones ([ 2 , 5 ]) var_output = new_model . predict ( var_input ) print ( var_input . shape , var_output . shape ) print ( var_output ) test_read () Output _________________________________________________________________ Layer ( type ) Output Shape Param # ================================================================= up_dim_affine ( UpDimAffine ) ( None, 5 , 10 ) 20 _________________________________________________________________ fft_affine ( FFTAffine ) ( None, 3 , 2 ) 10 ================================================================= Total params: 30 Trainable params: 20 Non-trainable params: 10 _________________________________________________________________ ( 2 , 5 ) ( 2 , 3 , 2 ) [[[ -3.25903225e+00 5 .96046448e-08 ] [ 1 .05201025e-07 -5.80141695e-08 ] [ 3 .23036957e-08 -3.17865378e-08 ]] [[ -3.25903225e+00 5 .96046448e-08 ] [ 1 .05201025e-07 -5.80141695e-08 ] [ 3 .23036957e-08 -3.17865378e-08 ]]] 在该测试里，我们的模型从配置到参数，都完完全全是从文件 my_model.h5 中读取的。注意我们馈入 customObjects 给 load_model ，使Keras能发现我们自己定义的层。同时， customObjects 还需要添加 tf.math.cos 函数，这是因为该激活函数同样不在Keras内置的几种基本的激活函数之列。 我们用完全相同的输入来测试模型的输出，得到的结果和我们上一个测试完全一致，说明对该模型（包括我们自定义的两层）的保存是成功的。 观察两个测试的输出值，我们会发现，对三维的输出，在确定后两维下标 a, b 的情况下 [:, a , b ] 的输出都是一样的。这是因为，第一维反映的是向量组中不同向量的测试结果，而我们馈入模型的向量组是两个值均为1的长度为5的向量。由于这两个向量完全相同，其对应的输出也完全相同。 数据生成 ¶ 我们仍然使用自动生成的数据。我们重新继承了自 第一节：线性分类 里定义的数据集生成类，新定义的数据集生成器 class TestDataFFTSet ( TestDataSet ): dparser.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class TestDataFFTSet ( TestDataSet ): ''' A generator of the data set for testing the non-linear regression model. y = cos(x w^T + 1 p^T) a ''' def __init__ ( self , scale_x , len_x , omega , phi , a ): ''' Initialize the data generator. scale_x: the scale of input vector. len_x: the length of input vector. omega (w) [1 x N]: the inner linear transformation. phi (p) [1 x N]: the inner bias. a [N x 1]: the outer linear transormation. ''' self . s_x = 2 * scale_x self . omega = omega self . phi = phi self . a = a self . len_x = len_x self . config ( train = True , batch = 100 , noise = 0.0 ) def mapfunc ( self , x ): xu = np . expand_dims ( x , - 1 ) y1 = np . tensordot ( xu , self . omega , ( 2 , 0 )) y1 = np . cos ( y1 + np . tensordot ( np . ones_like ( xu ), self . phi , ( 2 , 0 ))) y2 = np . squeeze ( np . tensordot ( y1 , self . a , ( 2 , 0 )), axis =- 1 ) y2 = np . fft . rfft ( y2 ) y_r = np . expand_dims ( np . real ( y2 ), - 1 ) y_i = np . expand_dims ( np . imag ( y2 ), - 1 ) y = np . concatenate ([ y_r , y_i ], axis =- 1 ) return y def next_train ( self ): ''' Get the next train batch: (x, y) ''' x = self . next_test () y = self . mapfunc ( x ) return x , y 我们新定义的这个数据生成器，与以往的一个不同在于，其定义了 mapfunc 方法；而产生训练数据的原理，是用 mapfunc 将产生的测试数据（只有输入 \\mathbf{x} \\mathbf{x} ）映射到输出 \\mathbf{Y} \\mathbf{Y} 。这个数据集可以通过迭代不断产生随机数据，也可以通过 mapfunc 来将任意给定的向量 \\mathbf{x} \\mathbf{x} 转换成 (6) (6) 定义的频域输出 \\hat{\\mathbf{Y}} \\hat{\\mathbf{Y}} 。 特别地，这里计算矩阵的时候，不使用 np.matmul 而是 np.tensordot ，和我们为第一层定义的时候使用 tf.tensordot 的原因相同。该函数支持对两个高维度的张量，取其中的两个维度分别计算矩阵乘法。 接下来测试数据集的输出效果 dparser.py 1 2 3 4 5 6 7 8 9 10 11 def test_dataset (): omega = 3 * np . random . random ([ 1 , 12 ]) phi = 2 * np . random . random ([ 1 , 12 ]) a = np . random . normal ( 0 , 1 , [ 12 , 1 ]) dataSet = TestDataFFTSet ( 1 , 10 , omega , phi , a ) dIter = iter ( dataSet ) for i in range ( 10 ): x , y = next ( dIter ) print ( y . shape , np . abs ( y [ 0 , ... , 0 ] + 1j * y [ 0 , ... , 1 ])) test_dataset () Output ( 100 , 6 , 2 ) [ 14 .29735734 9 .75982541 4 .73928941 6 .83158726 5 .16604991 0 .66256222 ] ( 100 , 6 , 2 ) [ 9 .32749042 5 .68157606 4 .86524786 11 .17296633 6 .37133611 7 .68757874 ] ( 100 , 6 , 2 ) [ 3 .97163879 9 .35646167 1 .43682653 4 .49838507 7 .39721013 4 .34096144 ] ( 100 , 6 , 2 ) [ 6 .56389599 5 .59993345 8 .19466732 0 .72835593 5 .01080391 9 .0552016 ] ( 100 , 6 , 2 ) [ 9 .71065508 3 .08608948 8 .72857359 9 .47081321 4 .87269945 7 .02108589 ] ( 100 , 6 , 2 ) [ 6 .05645098 6 .05961698 2 .98397442 8 .83888829 2 .91282992 5 .07843238 ] ( 100 , 6 , 2 ) [ 5 .11452286 1 .34310476 4 .15953687 3 .43588933 1 .7484992 0 .21387424 ] ( 100 , 6 , 2 ) [ 0 .63167972 8 .34622626 6 .21582338 5 .01146157 1 .50978382 1 .18373357 ] ( 100 , 6 , 2 ) [ 5 .88872479 6 .18109798 6 .97300166 4 .48064652 8 .13842369 6 .01989667 ] ( 100 , 6 , 2 ) [ 1 .28678976 3 .08831315 5 .3226707 0 .86784854 7 .83722167 0 .98692777 ] 我们产生的数据长度为10，参数的长度为12，我们在测试代码中，显示每次生成batch中，第一个样本的频谱强度。测试结果显示，频谱强度分布较为合理，且FFT后的数据长度为6=10/2+1，符合我们的预期。 定义类模型 ¶ 与 上一节 相似，我们在本节使用的仍然是回归模型，因此，在主程序部分的代码改动不大。我们定义新的类 class NonLinRegHandle ( ext . AdvNetworkBase ): ，其中核心部分（构造方法）的代码如下： class NonLinRegHandle 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def construct ( self ): ''' Construct a linear model and set the optimizer as Adam ''' # Construction input = tf . keras . Input ( shape = ( INPUT_SHAPE ,), dtype = tf . float32 ) upAff = ext . UpDimAffine ( PARAMS_SHAPE , use_bias = True , kernel_initializer = tf . keras . initializers . RandomUniform ( minval = 0.0 , maxval = 3.0 ), bias_initializer = tf . keras . initializers . RandomUniform ( minval = 0.0 , maxval = 2.0 ), kernel_constraint = tf . keras . constraints . NonNeg (), bias_constraint = tf . keras . constraints . NonNeg (), activation = tf . math . cos , name = 'up_dim_affine' )( input ) dnAff = ext . FFTAffine ( name = 'fft_affine' )( upAff ) self . model = tf . keras . Model ( inputs = input , outputs = dnAff ) # Set optimizer self . model . compile ( optimizer = self . optimizer ( self . optimizerName , self . lr ), loss = tf . keras . losses . mean_squared_error , metrics = [ self . relation ] ) self . model . summary () 在这个模型中，除了输入层以外，其余的两层都分别是我们自定义的层。第一个层内有参数 \\boldsymbol{\\omega},~\\boldsymbol{\\phi} \\boldsymbol{\\omega},~\\boldsymbol{\\phi} ，我们对这两个参数均加上了必须为正数的严格限制条件，同时对 \\boldsymbol{\\omega} \\boldsymbol{\\omega} ，我们使用均匀分布 U(0.0,~3.0) U(0.0,~3.0) 对其初始化，对 \\boldsymbol{\\phi} \\boldsymbol{\\phi} ，我们使用均匀分布 U(0.0,~2.0) U(0.0,~2.0) 对其初始化。在该层的最后，使用 \\cos(\\cdot) \\cos(\\cdot) 函数作为激活函数。 第二层内有参数 \\mathbf{a} \\mathbf{a} ，我们直接使用默认的初始化器来对其初始化。 实际测试的过程中，我们发现上一节定义的 相关系数 仍有缺陷。具体体现在，当两个被对比的向量中任何一个向量的某一维度的样本分布在方差为0时，分母 \\sigma_1^{(i)} \\sigma_2^{(i)} = 0 \\sigma_1^{(i)} \\sigma_2^{(i)} = 0 （其中 i i 表示向量的某一维度），从而导致该系数无法计算出结果。故而，我们考虑对其修正，在计算各维度相关系数的平均值时，排除掉那些无法计算相关系数的维度，改进后的代码如下： class NonLinRegHandle 1 2 3 4 5 6 7 8 9 10 @staticmethod def relation ( y_true , y_pred ): m_y_true = tf . keras . backend . mean ( y_true , axis = 0 ) m_y_pred = tf . keras . backend . mean ( y_pred , axis = 0 ) s_y_true = tf . keras . backend . sqrt ( tf . keras . backend . mean ( tf . keras . backend . square ( y_true ), axis = 0 ) - tf . keras . backend . square ( m_y_true )) s_y_pred = tf . keras . backend . sqrt ( tf . keras . backend . mean ( tf . keras . backend . square ( y_pred ), axis = 0 ) - tf . keras . backend . square ( m_y_pred )) s_denom = s_y_true * s_y_pred s_numer = tf . keras . backend . mean ( y_true * y_pred , axis = 0 ) - m_y_true * m_y_pred s_index = tf . keras . backend . greater ( s_denom , 0 ) return tf . keras . backend . mean ( tf . boolean_mask ( s_numer , s_index ) / tf . boolean_mask ( s_denom , s_index )) 调试 ¶ 在调试阶段，我们采用随机生成的参数作为真值。其中， \\boldsymbol{\\omega} \\in U(0.0,~3.0) \\boldsymbol{\\omega} \\in U(0.0,~3.0) , \\boldsymbol{\\phi} \\in U(0.0,~2.0) \\boldsymbol{\\phi} \\in U(0.0,~2.0) ， \\mathbf{a} \\in N(0.0,~1.0) \\mathbf{a} \\in N(0.0,~1.0) 。然后，我们生成大量的 (\\mathbf{x},~\\mathbf{Y}) (\\mathbf{x},~\\mathbf{Y}) ，其中 \\mathbf{x} \\in U(-3.0,~3.0) \\mathbf{x} \\in U(-3.0,~3.0) 。注意在这个问题里，模型的输入输出向量是等长的，参数的长度不影响输出向量的长度。我们将参数的长度固定为10个元素，并定义如下函数 class NonLinRegHandle 1 2 3 4 5 6 7 8 9 10 def groupSort ( * params ): sortind = np . argsort ( params [ 0 ]) . flatten () res = [] for p in params : if p . shape [ 0 ] > p . shape [ 1 ]: p = p [ sortind , :] else : p = p [:, sortind ] res . append ( p ) return res 该函数用于对一组相同长度的向量进行排序，这些向量不拘于行向量或列向量。排序的标准是第一个参数向量从小到大的顺序。定义该函数是为了修整我们的输出结果。在上文理论部分，我们已经说明，对于一组解，交换任意两个维度的值，不影响模型的效果。因此我们通过对预测值和真值分别进行排序，来评估两组解之间的差异程度。 class NonLinRegHandle 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 # Initialization omega = 3 * np . random . random ([ 1 , PARAMS_SHAPE ]) phi = 2 * np . random . random ([ 1 , PARAMS_SHAPE ]) a = np . random . normal ( 0 , 1 , [ PARAMS_SHAPE , 1 ]) dataSet = dp . TestDataFFTSet ( 3 , args . xLength , omega , phi , a ) # Generate a group of testing samples. if args . seed is not None : setSeed ( args . seed + 1000 ) dataSet . config ( batch = args . testBatchNum ) x , y = next ( dataSet ) # Set the data set for training. dataSet . config ( batch = args . trainBatchNum ) # Construct the model and train it. h = NonLinRegHandle ( xLength = args . xLength , learningRate = args . learningRate , epoch = args . epoch , steppe = args . steppe , optimizerName = args . optimizer ) h . construct () print ( 'Begin to train:' ) print ( '---------------' ) record = h . train ( iter ( dataSet )) # Generate a group of testing samples: dataSet . config ( batch = args . testBatchNum ) x2 = np . reshape ( np . linspace ( - 3 , 3 , args . xLength ), [ 1 , args . xLength ]) y2 = dataSet . mapfunc ( x2 ) x = np . concatenate ([ x , x2 ], axis = 0 ) y = np . concatenate ([ y , y2 ], axis = 0 ) # Check the testing results print ( 'Begin to test:' ) print ( '---------------' ) yp , loss_p , corr_p = h . test ( x , y ) # Check the regressed values w , p = h . model . get_layer ( name = 'up_dim_affine' ) . get_weights () b = h . model . get_layer ( name = 'fft_affine' ) . get_weights ()[ 0 ] # Resort data w , b , p = groupSort ( w , b , p ) # The solution omega , phi , a = groupSort ( omega , phi , a ) # The ground truth # Save if args . outputData is not None : np . savez_compressed ( args . outputData , epoch = record . epoch , loss = record . history [ 'loss' ], corr = record . history [ 'relation' ], test_x = x , test_y = y , pred_y = yp , pred_loss = loss_p , pred_corr = corr_p , W = w , p = p , b = b , omega = omega , phi = phi , a = a ) Output _________________________________________________________________ Layer ( type ) Output Shape Param # ================================================================= input_1 ( InputLayer ) ( None, 100 ) 0 _________________________________________________________________ up_dim_affine ( UpDimAffine ) ( None, 100 , 10 ) 20 _________________________________________________________________ fft_affine ( FFTAffine ) ( None, 51 , 2 ) 10 ================================================================= Total params: 30 Trainable params: 30 Non-trainable params: 0 _________________________________________________________________ Begin to train: --------------- Epoch 1 /20 500 /500 [==============================] - 3s 5ms/step - loss: 6 .8965 - relation: 0 .9842 Epoch 2 /20 500 /500 [==============================] - 2s 4ms/step - loss: 0 .0027 - relation: 1 .0000 Epoch 3 /20 500 /500 [==============================] - 2s 4ms/step - loss: 0 .0018 - relation: 1 .0000 Epoch 4 /20 500 /500 [==============================] - 2s 4ms/step - loss: 0 .0016 - relation: 1 .0000 Epoch 5 /20 500 /500 [==============================] - 2s 4ms/step - loss: 0 .0014 - relation: 1 .0000 Epoch 6 /20 500 /500 [==============================] - 2s 4ms/step - loss: 0 .0012 - relation: 1 .0000 Epoch 7 /20 500 /500 [==============================] - 2s 4ms/step - loss: 0 .0010 - relation: 1 .0000 Epoch 8 /20 500 /500 [==============================] - 2s 4ms/step - loss: 9 .0556e-04 - relation: 1 .0000 Epoch 9 /20 500 /500 [==============================] - 2s 4ms/step - loss: 7 .9935e-04 - relation: 1 .0000 Epoch 10 /20 500 /500 [==============================] - 2s 4ms/step - loss: 7 .0898e-04 - relation: 1 .0000 Epoch 11 /20 500 /500 [==============================] - 2s 4ms/step - loss: 6 .3418e-04 - relation: 1 .0000 Epoch 12 /20 500 /500 [==============================] - 2s 4ms/step - loss: 5 .6936e-04 - relation: 1 .0000 Epoch 13 /20 500 /500 [==============================] - 2s 4ms/step - loss: 5 .1473e-04 - relation: 1 .0000 Epoch 14 /20 500 /500 [==============================] - 2s 4ms/step - loss: 4 .6677e-04 - relation: 1 .0000 Epoch 15 /20 500 /500 [==============================] - 2s 4ms/step - loss: 4 .2542e-04 - relation: 1 .0000 Epoch 16 /20 500 /500 [==============================] - 2s 4ms/step - loss: 3 .8777e-04 - relation: 1 .0000 Epoch 17 /20 500 /500 [==============================] - 2s 4ms/step - loss: 3 .5603e-04 - relation: 1 .0000 Epoch 18 /20 500 /500 [==============================] - 2s 4ms/step - loss: 3 .2665e-04 - relation: 1 .0000 Epoch 19 /20 500 /500 [==============================] - 2s 4ms/step - loss: 3 .0134e-04 - relation: 1 .0000 Epoch 20 /20 500 /500 [==============================] - 2s 4ms/step - loss: 2 .7940e-04 - relation: 1 .0000 Begin to test: --------------- 11 /11 [==============================] - 0s 6ms/sample - loss: 2 .4728e-04 - relation: 1 .0000 Evaluated loss ( losses.MeanSquaredError ) = 0 .0002472764754202217 Evaluated metric ( Pearson ' s correlation ) = 0 .9999991 在测试阶段，我们除了生成10组随机数据以外，还生成了一组从 [-3, 3] [-3, 3] 之间均匀增长的数据。这组数据与我们之前使用的随机数据分布不同，通过检测该数据的输出结果，我们可以验证我们拟合的这个参数模型是否具有一定的鲁棒性。 输入向量 \\mathbf{x} \\mathbf{x} 的长度不但影响输出 \\mathbf{Y} \\mathbf{Y} 的长度，也影响FFT的精度。因此，我们通过使用不同的向量长度分别进行测试，并对测试结果进行评估。调用测试的代码如下： python lin-reg.py -sd 1 -do test/ { length } -xl { length } 通过指派不同的向量长度 {length} ，将输出保存到不同的文件里，以绘制它们的对比效果图。首先，我们观察训练过程的记录情况 损失函数 (MSE) 测度函数 (相关系数) 可以看见，收敛的速度非常快。并且随着数据向量长度的增加，损失函数收敛到的值也增加。这是由于傅里叶变换的影响。我们使用的傅里叶变换是还没有标准化后的数据，因此，随着输入向量的增长，傅里叶变换的精度也提高，导致低频部分的数值明显变大，从而导致损失函数的收敛值增加。而相关系数显示，预测输出和真实值之间的线性相关性迅速趋近于1，印证该训练过程非常快。 注意 需要重申的是，我们计算相关系数是基于不同样本的统计情况来确定的。因此为了估计出准确的的相关系数，我们的batch需要有足够多的样本。显然，1个样本的batch是无法用来计算相关系数的。这里我们的batch含有32个样本。 接下来运行测试集检查结果。我们对预测的频谱和真实频谱之间求均方根误差(RMSE)，结果如下： 均方根误差 (RMSE) 由 (4) (4) 知，我们的模型本质上其实是一个对向量个元素独立运算的函数，亦即元素级的函数。因此， (4) (4) 可以被改写成 \\begin{align} y(x) = \\sum_{i=1}^N a_i \\cos ( \\omega_i x + \\varphi_i ). \\end{align} 如果我们输入一组向量，值在 [-3, 3] [-3, 3] 之内从小到大均匀增长，那么对应的取傅里叶变换的输出向量，可以看成是响应 x \\in (-3,~3) x \\in (-3,~3) 的频谱。我们在上述测试过程中，虽然使用了不同的向量长度 L L ，但生成的最后一个测试向量 \\mathbf{x} \\mathbf{x} 均是在 x \\in (-3,~3) x \\in (-3,~3) 均匀采样得到的。因此，不同的向量长度的测试结果，对应的是不同精度的向量的频谱。在这里，我们可以把“精度”理解成采样率，精度更高的向量对应的采样率也就越高，所以频谱的范围也就越大。尽管在下面的各图中我们使用了角频率（在 0 \\sim \\pi 0 \\sim \\pi 之间）来表述频率，但需要厘清的是，它们对应的频谱宽度是不一样的。 我们将训练好的模型输出的频谱和真实数据生成的频谱对比，得到以下结果： 频谱响应 幅值 相位 L=10 L=100 L=500 L=1000 可见，我们的回归到的模型输出的频谱和真值的模型完全一致。 问题 如果一个模型在频域上对一个信号的回归是精确的，是否在原域上（即时域）的回归也是精确的？ 正是如此。因为，考虑FFT的逆变换iFFT，作为一个线性变换，iFFT毫无疑问满足Lipschitz连续条件。这意味着，如果一个信号的在频域上的回归结果满足 \\lVert \\hat{\\mathbf{Y}} - \\mathbf{Y} \\rVert < \\varepsilon \\lVert \\hat{\\mathbf{Y}} - \\mathbf{Y} \\rVert < \\varepsilon ，则必有在时域上满足 \\lVert \\hat{\\mathbf{y}} - \\mathbf{y} \\rVert < C\\varepsilon \\lVert \\hat{\\mathbf{y}} - \\mathbf{y} \\rVert < C\\varepsilon ，其中 C C 是一个有限的常量。 另一种思考方法是，iFFT和FFT互为逆变换，这说明这两者之间构成一一映射。如果两组信号的FFT相同，那么其对应的一一映射，iFFT，又或者说是原信号，是势必相同的。这意味着，如果一个模型能够在时域上回归到某组数据，那么其频域上也必然能回归到相同数据的频域表达，反之亦然。 最后，我们来观察三个参数向量的回归情况，比对不同测试回归到的参数向量和真值之间的差别，结果如下 \\boldsymbol{\\omega} \\boldsymbol{\\omega} \\boldsymbol{\\phi} \\boldsymbol{\\phi} \\mathbf{a} \\mathbf{a} 鉴于模型的解具有高度的不确定性，我们发现我们回归到的结果受到初始化值的影响非常严重。尽管我们的回归模型确实拟合出了原函数的特性，但回归到的参数却和真值有明显的区别。 本节虽然使用了一个高度不确定的、却又简单的非线性函数作为例子，但我们所希望传达的，主要有以下两个要点： 一个可以写成解析式的线性或非线性函数，可以轻易地被实现成Tensorflow-Keras模式下的可微模型。这种函数包括但不限于普通的 数学函数 （例如指数函数、三角函数、贝塞尔函数等）， 快速傅里叶变换 ， 离散余弦变换 ， 常规的线性代数操作 （例如行列式、特征值）， SVD分解 ，等等。这些函数全部都已经被Tensorflow实现出来，可以通过内置API任意组合。更重要的是，在本节中，我们没有定义任何求取导数、梯度的方法，因为上述的每一个Tensorflow内置API，都已经内置了解析级别的梯度的计算方法。因此，对于一些简单的非线性模型，用户可以完全不用关心反向传播的过程，而是合心定意在编写正向传播上。从某种程度上，这大大降低了求解非线性问题的难度。 本节重点揭示的，是如何优雅地完成一个自定义层。截至笔者写到目前为止(03/17/2019)，未见网络上有登载类似的、规范的教程。如果用户能习惯按照本节的方式，扩展Tensorflow-Keras API，会带来两大好处： 一些复杂的模块，例如Residual block，Inception block等，可以以封装好的形式利用起来，使得主程序的代码简洁干净； 使用和Keras源码一致的语言风格，确保我们编写的所有自定义API，都可以被Keras原生的存取工具（包括 to_json , save 等）正确地保存下来。 在后续的内容里，我们还会涉及自定义网络层的情况，但是我们就不会特别说明完整的定义流程。在本教程推进的过程中，我们会不断定义各种需要用到的网络层，从而不断丰富扩展模块 extension.py 的内容。到本教程结束的时候，我们期望能够建立一个对用户友好的、功能完善而又与Tensorflow-Keras源代码风格一致的扩展模块出来。这一模块将可以用来构建任何形式的Tensorflow工程。","text_tokens":["42","可行","基于","一层","defined","75982541","size","一节","映射","在上文","class","generate","end","参见","存在","涉及","后续","包含","线性","部分","ext","并用","观察","看出","'","压缩","engine","范围","下来","sortind","变","使用","确定性","不会","cdot","residual","情况","点","int","initializer","变得","26","least","meansquarederror","时","难度","rmse","would","5.80141695","^","检查和","收敛","compute","复合","反之亦然","构造","封装","三角函数","7940e","summary","厘清","阅览","read","字符串","svd","optimizers","w","mul","3.25903225","完整","二层","结论","采用","提及","example","一些","若","08","相关","optimizername","预测","has","00","47081321","&","余弦","而言","doc","31","第二层","强度","数表","如","排除","非常低","10","周期性","串","var","发现","学习","100","大大","yp","可以","dict","37","pearson","已知","results","定性","数据分布","record","align","savez","大大降低","back","正式","87269945","load","轻易","细节","<","(","不是","等等","86784854","19466732","再","变换","交换","testdataset","首先","ground","return","use","leftrightarrow","回忆","线性代数","必然","44","rvert","化","将","结果显示","tuple","降低","r1","称为","diter","文档","affine","reshape","8777e","68757874","specify","18373357","type","分解","要求","一行","真值","positive","ndim","干净","else","一一","体操","denom","自定","接下","import","设置","github","[","分别","timeless","原域","标准","util","等价","greater","第一个","non","传播","繁琐","另","函数","variables","一般","本节","whether","熟悉","源代码","block","接受","奇数","“","编译成","受","高度","故而","ones","eta","xl","类似","like","用到","反之","dnaff","im","况且","后","dims","均值","supports","0016","混合","gen","数值","可见","带来","矩阵","有人","版本","达式","一个","关于","调用","而且","虚部值","于是","原因","created","对","自己","：","与","偶数","43682653","组是","must","必选","入门","中层","生效","显得","特征值","提示","无法","m","求均","to","同一","获取","所以","线性变换","从小到大","if","上","新版","91282992","正常","1j","custom","...","will","执行","形","2665e","正是","你","dim","lr","恢复","列式","必须","now","选","神经网络","59993345","/","实部值","商","21582338","即使","loss","）","反映",",","15","x","broadcasting","space","推断","backend","未见","41","json","过","为了","0s","默认值","mean","generic","集","确定","根据","设定","开始","不用","mathbb","原函数","solution","并未","kernel","py","维度","量","采纳","其一","模型","concatenate","第","squared","normal","比","right","每次","activation","步骤","一章","%","参数均","length","shapes","from","epoch","输入输出","较为","05645098","zeros","之内","到","前为","模式","33","0002472764754202217","十分","求取","groupsort","pylint","精确","2542e","反馈","输出","evaluated","参看","梯度","不断丰富","导数","信息","布尔","reconstructed","left","误差","for","ndims","you","its","iter","包括","本质","我们","方便","网络层","表明","个","initial","参数设置","regression","用来","n","2s","first","指出","核心","不但","某种程度","范化","长","能","export","颇为重要","迅速","自由","于","统一","就","可调","推荐","样本分布","01146157","仿射","预期","第二","加在","mathcal","一步","处","两个","平均值","亦然","0012","framework","29","17","误解","记录","或列","83722167","手","27","程度","关心","含有","ifft","初始化","传达","squeeze","印证","生成器","和","相位","其他","0.01","报错","现成","08831315","证明","维和","绘制","连接","required","本","relation","c","param","时则","列数","¶","整个","32","constraints","这样","无疑","construct","回归","compressed","一系列","调试","语言","要点","迭代","表","flattened","product","某组","这个","化器","index","96046448e","自行","时候","test","了解","使得","output","任意","01989667","转换","_","接下来","参量","神经","k","39","model","文件","分类","过该","手动","原生","建立","\\","或者说","看作","transformation","34622626","精度","各图","biase","该层","_________________________________________________________________","等","then","看成","pi","统计","72857359","建模","替换成","h5","方根","底层","实际上","取前","lvert","习惯","2019","2d","由","亦","好处","kwargs",".","build","这","引入","at","，","input","testing","adam","激活","配置文件","同样","在于","覆盖","教程","disable","时序","差异","cos","self","第二个","提倡","没有","predict","某","value","inception","特别","46","3418e","要","配置","差别","mat","如此","executing","but","有些","res","72835593","applicable","势必","应用","21387424","corr","显然","先","值为","是从","范数","例子","功能","由于","73928941","信号","prior","前者","里","转换成","注意","omega",">","varbias","97300166","ie","45","…","28678976","因此","都","不确定性","维来","低频","测试代码","其实","23","相关性","min","sum","situation","类才","range","r","层里","03","特征","11","不变","fft","未知","34096144","第一层","神经网","lin","一般来说","98692777","过程","mask","增加","然后","28","22","加入","笔者","全","联合","合心定","默认","严重","本层","实值","一段","本例","无","abs","定义新","pop","给出","内置","nn","在","设若","resort","效果图","逆变","测试数据","造成","值均","丰富","特性","34","这一","只要","6936e","加在一起","np","重要","inputs","列","那些","到列","activity","掉","摘要","arg","batch","实部","眼里","no","0134e","折半","将子层","两","理论","original","目前","展开","regularizer","25","秩","组合","0018","选择","而","step","目前为止","reg","活","揭示","广泛","容易","然而","初始","那","之间","两码事","快速","outputdata","17296633","也","common","各自","一定","该","同一个","强制","精密","相关系数",".__","层内","total","这组","存取","linear","即时","metrics","修改","seed","initializers","50978382","流程","假设","concat","尽管","合理","上述","hat","stackoverflow","regularizers","建议","摘自","层叠","48064652","讨论","models","阅读","看见","范例","值","还会","keras","~","解决","x2","自带","phi","设法","索引","不","不断","鉴于","其二","模拟","regressed","通顺","自","1000","即可","追索","where","层来","刻意","译成","亲切","器来","40","元素","添加","dot","原则","测度","每","前提","如下","只","07843238","偏向","lambda","随着","参数","通过","成","begin","dtype","重申","鲁棒性","取","p","节","98397442","don","导致","mathrm","网络","直接","should","层中","行动","有","多个","vector","两码","读者","init","]","第一节","相互交换","and","快","@","非线性","一致","疑问","#","需要","7","合心","之","=","。","..","name","则","这些","randomuniform","修正","简洁","weights","详细","next","need","即","隐式","实值化","optimizer","一种","其中","minval","18","最底层","passed","保护","均","源码","测试","工作","63167972","add","6677e","500","常量","1","customobjects","d","两轴","linspace","原则上","正数","意味着","testbatchnum","dataset","足够","weight","二个","37133611","编译","取消","意味","get","限定","square","实例","扩展","可分","技术","会","张量","integer","普通","改写","限于","地令","real","aligned","39721013","error","5ms","构造方法","综上","bias","24","知道","5","9842","具有","规范性","去掉","正向","官方","某个","steppe","登载","参数表","采样率","pred","明显","级","float32","得到","一起","def","38","代数","ops","当","角频率","0556e","是","某种","b","区别","好","全为","argsort","相互","显示","计算","19","从而","期望","32749042","分布","因为","测试阶段","应当","系数","valueerror","arrays","matrix","傅里叶","严格","most","其余","有限","23036957e","推断出","5603e","eagerly","4ms","完成","相比","anymore","rank","替换","完全一致","3226707","评估","几种","段","指","t","49838507","对应","sample","原理","秩均","程序","互为","加诸","方程","34310476","为重","介绍","这种","所有","可微","缺失","方案",":","塞尔","功底","losses","y1","并","经过","提供","print","思考","写","equation","出来","为什么","20","效果","感觉","线性组合","upaff","器","便于","boldsymbol","built","9999991","重","大","connected","给","varepsilon","args","分成","21","解均","维","implements","49","令","i","+","响应","05961698","来说","多余","作","correlation","具体操作","构成","circ","43","y","uses","提到","排序","参数值","使","0000","可分解","表示","bug","function","s","objects","之前","完善","其","读取","0","不可","maxval","例如","staticmethod","加上","写成","行列式","log","直觉","内容","检查","\"","1.0","`","来","简单","最终","事实","保存","only","masking","element","下标","up","并且","anything","layer","已经","触发","选取","按照","scale","近似","30","see","的","无关","rnn","变量","一","object","缺陷","05201025e","还","l","imag","本分","采样","以外","成器","”","起来","吗","完全相同","07","向量","让","它们","人","compile","具体","updimaffine","类","2","处理","旧版","重点","以下","样本","9","history","最","自动","0552016","以","47","16","04","13842369","全部","或","限制","子层","一点","call","基本","接口","lst","re","regular","y2","或类","用","callable","最后","数据","{","结果表明","知","35646167","by","sqrt","启发","config","系列","正确","独立","就是","theta","层能","这里","任何","append","唯一","97163879","受到","越","提高","属于","用法","修整","解","metric","作为","为止","理解","super","advnetworkbase","频域","幅值","convert","len","说","条件","transormation","group","items","（","直属","希望","回调","中均","do","new","废旧","raise","参与","方式","三维","低","被","7484992","才","输入","组中","每个","多","等候","运行","instance","它","重构","一样","expand","好后","densely","而是","什么","能够","主程序","下","内有","改进","类型","逆变换","中","？","|","形状","trainable","对比","带","既","宽度","sigma","均匀","形式","2.0","除非","显式","且","0.0","tensordot","两组","after","shape","layers","了","take","高","；","相同","两者之间","固定","直","generator","argument","同时","达到","颇为","当初","f","周期","各种","预测值","inner","8965","13","允许","serialize","两维","决定","18109798","频谱","不拘","运算","方差","工程","结果","各层","is","units","1473e","互交","数学","工具","noise","损失","层","inputlayer","第一","继承","由类","fftaffine","积","整数","换成","35","tf","axis","6ms","4728e","3.0","training","sd","以往","context","truth","cdots","顺序","have","未","三角","分解成","模块","my","applied","仍然","0898e","所","难道","乘法","66256222","写出","大量","私有","}","29735734","训练","说明","完完全全","本身","train","4","虽然","lipschitz","不可或缺","其内","均匀分布","initialize","不能","u","be","重新","signal","改动","构建","用户","馈入","从","非常","*","趋近","表达","两大","时间","两者","dparser","解决方案","matmul","属性","却","tensorflow","两层","last","两种","跟","xu","uniform","可","规范","求解","表达式","api","几片","新","来自","variable","numpy","组","conv","02108589","频率","51","复数","utils","对于","意在","实际行动","随机","list","exp","毫无疑问","才能","分母","not","传入","仿射变换","set","learningrate","原","逻辑","能力","像","0027","长度","考虑","mathbf","或是","验证","lstm","著名","12","array","下面","反向","准确","做法","完全","编写","as","满足","行列","有关","tensor","一系","0010","相信","指数","14","false","操作","优雅","e","做到","实现","关系","真实","mapfunc","出","常规","11452286","但是","支持","复杂","截至","规范化","结束","定义","以及","设该","56389599","construction","必有","产生","check","应该","dimension","符合","0014","sim","行向量","这是","01080391","确实","sequential","利用","许多","dense","指数函数","48","activations","none","友好","各","nonneg","指派","时域","constraint","高效","testdatafftset","than","3.17865378","note","指定","毫无","base","string","spec","your","83158726","父类","j","大致","samples","范性","相符","域","3s","of","true","相似","作用","又","initialization","nd","地","参照","h","glorot","mse","已","tensorshape","进行","如果","是因为","单","代码","换言之","给定","boolean","params","取实部","更","确保","但","标准化","arguments","阶段","速度","random","the","表述","in","前面","data","为","numer","inputspec","某些","既然","values","一组","式","extension","那么","平均","flatten","写作","6","提取","dimensionality","nonlinreghandle","等效","计算方法","save","推进","outputs","方法","风格","是否","rfft","主要","影响","network","哪些","15953687","名称","跑通","不同","通道","想","71065508","9935e","检测","成功","字典","可能","perform","axes","把","贝塞尔","生成","级别","如何","__","operation","outer","setseed","出该","功能完善","3","解析","a","86524786","拟合","地被","it","事实上","with","从小","再压缩","仍","增长","yaml","或缺","88872479","math","结构","trainbatchnum","standard"," ","虚部","08608948","中文","用于","估计","wise","36","升维成","自定义","实在","limits","体现","或者","只有","just","实际",")","行内","除了","83888829","字符","离散","-","当然","8","16604991","varphi","xlength","连续","问题","正是如此","三个","innermost","正则","、","43588933","found","dp","saw","python","eager","68157606","找回"],"title":"非线性回归","title_tokens":["线性","非线性","回归"]},{"location":"book-1-x/chapter-1/nonlinear-regression/#_1","text":"摘要 本节将讨论如何将一个解析的非线性的回归问题，表述成使用非线性函数激活的线性回归问题。特别地，我们将通过自己定义“激活层”来引入我们定义的解析的非线性函数。","text_tokens":["解析","通过","成","非线性","自己","讨论","函数","的","本节","引入","，","回归","线性","来","。","问题","摘要","“","地","一个","特别","激活"," ","将","我们","如何","”","定义","层","使用","表述"],"title":"非线性回归","title_tokens":["线性","非线性","回归"]},{"location":"book-1-x/chapter-1/nonlinear-regression/#_2","text":"","text_tokens":[],"title":"理论","title_tokens":["理论"]},{"location":"book-1-x/chapter-1/nonlinear-regression/#_3","text":"回忆我们的多输出方程 \\mathbf{y} = \\mathcal{F}(x) \\mathbf{y} = \\mathcal{F}(x) ，其中 \\mathcal{F} \\mathcal{F} 可以是非线性函数，那么我们可以考虑使用一个带可调参数的模型 \\mathbf{D}_{\\boldsymbol{\\Theta}}(\\mathbf{x}) \\mathbf{D}_{\\boldsymbol{\\Theta}}(\\mathbf{x}) 来模拟它，其中 \\boldsymbol{\\Theta} \\boldsymbol{\\Theta} 是可调的参数。于是，该问题可以被表述为 \\begin{equation} \\begin{aligned} \\arg \\min_\\limits{\\boldsymbol{\\Theta}} &\\sum_{k=1}^N \\mathcal{L} \\left( \\mathbf{y}_k,~ \\mathbf{D}_{\\boldsymbol{\\Theta}}(\\mathbf{x}_k) \\right),\\\\ \\mathrm{s.t.}~&\\mathbf{y}_k = \\mathcal{F}(\\mathbf{x}_k). \\end{aligned} \\end{equation} 其中， (\\mathbf{x}_k,~\\mathbf{y}_k) \\in \\mathbb{D} (\\mathbf{x}_k,~\\mathbf{y}_k) \\in \\mathbb{D} 来自由非线性函数 \\mathcal{F} \\mathcal{F} 产生的数据集。","text_tokens":["参数","mathbf","t","in","n","f","(","其中","多","于是","aligned","它","limits","begin","为","非线性","带","right","}","equation","min","s","函数","_","的","mathcal","可以",",","输出",".",")","可调","end","集","k","，","sum","数据","{","方程","x","=","线性","那么","来","。","^","问题","boldsymbol","~","mathbb","arg","mathrm","left","l","回忆","一个","1","d","\\","被","表述"," ","是","y","自由","我们","该","&","模型","theta","模拟","使用","考虑","产生"],"title":"一般回归问题","title_tokens":["一般","问题","回归"]},{"location":"book-1-x/chapter-1/nonlinear-regression/#_4","text":"对于一个解析的非线性函数，我们假设任何这样的函数都可以分解成多个复合函数 \\mathbf{f}_i \\mathbf{f}_i ，其中每个复合函数都只包含一个仿射变换 \\mathbf{h}_j = \\mathbf{W}_j \\cdot + \\mathbf{b}_j \\mathbf{h}_j = \\mathbf{W}_j \\cdot + \\mathbf{b}_j 和一个对在各元素操作的非线性激活函数 \\Lambda_j \\Lambda_j 。因此，复合函数可以写作 \\mathbf{f}_i = \\Lambda_j \\circ \\mathbf{h}_j \\mathbf{f}_i = \\Lambda_j \\circ \\mathbf{h}_j 。于是，整个非线性的函数可以表述为： \\begin{equation} \\begin{aligned} \\mathcal{F} = \\Lambda_M \\circ \\mathbf{h}_M \\circ \\Lambda_{M-1} \\circ \\mathbf{h}_{M-1} \\circ \\cdots \\Lambda_1 \\circ \\mathbf{h}_1. \\end{aligned} \\end{equation} 例如，对函数 \\begin{align} \\mathcal{F}(\\mathbf{x}) = \\exp( \\mathbf{A} \\log ( | \\mathbf{B} \\mathbf{x} + \\mathbf{c} | ) ). \\end{align} 可以分解为： \\mathbf{h}_1 (\\mathbf{x}) = \\mathbf{B} \\mathbf{x} + \\mathbf{c} \\mathbf{h}_1 (\\mathbf{x}) = \\mathbf{B} \\mathbf{x} + \\mathbf{c} ； \\Lambda_1 (\\mathbf{h}_1) = \\log ( | \\mathbf{h}_1 | ) \\Lambda_1 (\\mathbf{h}_1) = \\log ( | \\mathbf{h}_1 | ) ； \\mathbf{h}_2 (\\Lambda_1) = \\mathbf{A} \\Lambda_1 \\mathbf{h}_2 (\\Lambda_1) = \\mathbf{A} \\Lambda_1 ； \\Lambda_2 (\\mathbf{h}_2) = \\exp ( \\mathbf{h}_2 ) \\Lambda_2 (\\mathbf{h}_2) = \\exp ( \\mathbf{h}_2 ) 。 实际上，当然还存在更复杂的情况，例如，一个非线性函数 \\mathbf{f}_j \\mathbf{f}_j 是两个非线性函数的和、积、商，或是某函数导数的范数等……但原则上，这些函数都可以写作上述（多个）可分解复合函数的（联合）变换。本质上，函数中的任何参数，都可以看作是在参与一个仿射变换。因此，任何函数只要能写出解析式，理论上就能分解为（多个）上述的可分解函数的形式。 相信有一点功底的读者都可以看出， (2) (2) 其实就是一个神经网络的表达式。换言之，只要知道一个函数的解析式，我们就可以用一个或多个神经网络来为其建模。虽然我们可能不知道这个函数里具体的参数值，但通过对网络训练，我们可以让网络的参数回归到函数的参数上。","text_tokens":["相信","|","其中","于是","(","参数值","操作","为","对","可分解","：",".","形式","end","用","变换","存在","联合","，","式","表达","其","包含","{","线性","和","复杂","写作","例如","1","看出","；","激活","到","m","log","原则上","不","就是","在","cdot","c","情况","任何","f","表达式","只要","上","整个","这样","分解","可分","某","回归","来","导数","元素","可能","复合","各","原则","本质","我们","功底","神经网络","只","对于","这个","理论","lambda","参数","商","exp","解析","a","通过","aligned","积","begin","j","equation","w","）","函数","_","的","范数","（","仿射变换","神经","cdots","x","能","知道","还","分解成","里","网络","参与","\\","看作"," ","有","多个","…","h","因此","都","读者","就","等","mathbf","或是","其实","每个","让","i","+","具体","写出","非线性","仿射","}","实际","可以","mathcal","2","训练",")","两个","建模","虽然","-","换言之","当然","=","。","数值","这些","更","circ","实际上","align","但","达式","、","一个","假设","是","或","b","神经网","上述","一点","中","表述"],"title":"非线性解析函数的分解","title_tokens":["的","解析","分解","非线性","线性","函数"]},{"location":"book-1-x/chapter-1/nonlinear-regression/#_5","text":"考虑一组三角函数的线性组合，使得列向量 \\mathbf{x} \\in \\mathbb{R}^T \\mathbf{x} \\in \\mathbb{R}^T 映射到列向量 \\mathbf{y} \\in \\mathbb{R}^T \\mathbf{y} \\in \\mathbb{R}^T ，其中 \\mathbf{x} \\mathbf{x} ， \\mathbf{y} \\mathbf{y} 均为时间域上的变量，则： \\begin{align} \\mathbf{y} = \\sum_{i=1}^N a_i \\cos ( \\omega_i \\mathbf{x} + \\varphi_i ). \\end{align} 如果我们将其写成矩阵的形式，应当有 \\begin{align} \\mathbf{y} = \\cos ( \\mathbf{x} \\boldsymbol{\\omega}^T + \\mathbf{1} \\boldsymbol{\\varphi}^T ) \\mathbf{a}. \\end{align} 设若我们有大量的样本 (\\mathbf{x}_k,~\\mathbf{y}_k) (\\mathbf{x}_k,~\\mathbf{y}_k) ，但我们不知道参数 \\boldsymbol{\\omega},~\\boldsymbol{\\varphi},~\\mathbf{a} \\boldsymbol{\\omega},~\\boldsymbol{\\varphi},~\\mathbf{a} 。若我们想在频率域上拟合出该模型的参数，则根据 (1) (1) ，该问题可以写作： \\begin{equation} \\begin{aligned} \\arg \\min_\\limits{\\boldsymbol{\\omega},~\\boldsymbol{\\varphi},~\\mathbf{a}} &\\sum_{k=1}^K \\lVert \\mathrm{Re}\\{\\mathbf{Y}_k - \\hat{\\mathbf{Y}}_k \\} \\rVert_2^2 + \\lVert \\mathrm{Im}\\{\\mathbf{Y}_k - \\hat{\\mathbf{Y}}_k \\} \\rVert^2_2,\\\\ \\mathrm{s.t.}~&\\mathbf{Y}_k = \\mathrm{FFT}(\\mathbf{y}_k), \\\\ &\\hat{\\mathbf{Y}}_k = \\mathrm{FFT}(\\cos ( \\mathbf{x}_k \\boldsymbol{\\omega}^T + \\mathbf{1} \\boldsymbol{\\varphi}^T ) \\mathbf{a}). \\end{aligned} \\end{equation} 其中，FFT指 快速傅里叶变换 ，虽然FFT是一个线性变换，但显然，该问题是一个非线性问题，这是由于预测值的表达式 \\hat{\\mathbf{y}} \\hat{\\mathbf{y}} 的表达式 (5) (5) 是非线性的。 由于表达式 (5) (5) 是一个显式函数，相比上一节求取低秩近似的仿射变换，我们可以知道，即使该问题即使存在多个不同的 \\mathbf{x}_k \\mathbf{x}_k 对应同一个 \\mathbf{y}_k \\mathbf{y}_k ，也不影响我们对问题的求解（即训练得到的参数能和真实参数产生相同的输出）。然而，从这里的参数的定义可以看出，我们在这个问题中使用的参数是非常低秩的（所有的参数秩均为1），这将导致这个问题的解具有高度的不确定性，许多不同的参数组 \\boldsymbol{\\omega},~\\boldsymbol{\\varphi},~\\mathbf{a} \\boldsymbol{\\omega},~\\boldsymbol{\\varphi},~\\mathbf{a} 均能达到相同的效果。例如，我们已知三个参数向量是长度相同的，若我们选取三个向量各自的第 i i 个元素，和其对应的第 j j 个元素相互交换（例如 \\omega_i \\leftrightarrow \\omega_j \\omega_i \\leftrightarrow \\omega_j ），则根据 (4) (4) ，这两个不同的解均能产生相同的效果。另一个例子是，由于余弦函数具有周期性，对 \\boldsymbol{\\varphi} \\boldsymbol{\\varphi} 的任意元素 \\varphi_i \\varphi_i ，即使令 \\varphi_i = \\varphi_i + 2 \\pi \\varphi_i = \\varphi_i + 2 \\pi ，仍不影响拟合的效果。因此，通过 (6) (6) 求解的向量 \\boldsymbol{\\varphi} \\boldsymbol{\\varphi} 也具有不确定性。 根据我们前面提到的对非线性解析函数的分解方法，该问题的模型可以分解为： \\mathbf{h}_1 (\\mathbf{x})= \\mathbf{x} \\boldsymbol{\\omega}^T + \\mathbf{1} \\boldsymbol{\\varphi}^T \\mathbf{h}_1 (\\mathbf{x})= \\mathbf{x} \\boldsymbol{\\omega}^T + \\mathbf{1} \\boldsymbol{\\varphi}^T ； \\Lambda_1 (\\mathbf{h}_1) = \\cos ( \\mathbf{h}_1 ) \\Lambda_1 (\\mathbf{h}_1) = \\cos ( \\mathbf{h}_1 ) ； \\mathbf{h}_2 (\\Lambda_1) = \\Lambda_1 \\mathbf{a} \\mathbf{h}_2 (\\Lambda_1) = \\Lambda_1 \\mathbf{a} ； \\hat{\\mathbf{Y}} = \\Lambda_2 (\\mathbf{h}_2) = \\mathrm{FFT} ( \\mathbf{h}_2 ) \\hat{\\mathbf{Y}} = \\Lambda_2 (\\mathbf{h}_2) = \\mathrm{FFT} ( \\mathbf{h}_2 ) 。","text_tokens":["第","in","其中","(","re","前面","应当","为","对","从","：","映射","一节","均",".","s","傅里叶","非常","形式","真实","这","end","一组","变换","存在","，","其","表达","交换","时间","显式","{","线性","~","和","写作","leftrightarrow","6","例如","1","看出","写成","；","rvert","相同","不","将","相比","在","设若","方法","定义","同一","使用","确定性","cos","产生","求取","指","t","达到","这里","求解","表达式","周期","对应","线性变换","影响","预测值","上","不同","这是","秩均","输出","想","分解","组","列","^","到列","许多","arg","元素","频率","所有","解","互交","三角函数","我们","个","这个","出该","lambda","参数","n","a","组合","秩","解析","通过","aligned","使得","begin","即使","显然","任意","j","equation","选取","另","近似","）","函数","_","的",",","拟合","（","例子","效果","仿射变换","k","域","变量","线性组合","然而","由于","x","能","知道","若","5","三角","boldsymbol","导致","具有","高度","mathrm","预测","仍","快速","omega","也","\\","低","各自"," ","有","多个","h","该","&","因此","解均","余弦","同一个","不确定性","长度","考虑","向量","mathbf","令","相互交换","非常低","i","+","周期性","pi","limits","大量","im","非线性","仿射","}","min","训练","可以","如果","2","确定",")","得到","根据","已知","两个","sum","样本","4","虽然","-","定性","=","varphi","r","mathbb","。","问题","则","矩阵","align","但","三个","达式","lvert","一个","是","y","fft","即","提到","模型","hat","中","相互"],"title":"本节问题","title_tokens":["本","问题","节"]},{"location":"book-1-x/chapter-1/nonlinear-regression/#_6","text":"我们已经知道，该问题可以建立成一个两层的模型，两层的变换函数和激活函数分别为 (\\mathbf{h}_1,~\\Lambda_1) (\\mathbf{h}_1,~\\Lambda_1) , (\\mathbf{h}_2,~\\Lambda_2) (\\mathbf{h}_2,~\\Lambda_2) 。然而，实现该模型仍然存在技术问题。即，神经网络中，并未定义 \\mathbf{h}_1,~\\mathbf{h}_2,~\\Lambda_2 \\mathbf{h}_1,~\\mathbf{h}_2,~\\Lambda_2 的层API，因此，我们必须自己来实现这些功能。 这一节讨论的内容更偏向于技术实现，而且对新入门的读者而言具有一定的难度。但本节讨论的技术，即自定义网络层，实在是非常广泛地应用在Keras API的用户中。例如，著名的Residual network和Inception network，在Tensorflow-Keras API中均未提供现成的API，需要读者自行设法构造。 熟悉旧版Tensorflow的用户，可能会发现，在实现自定义API的过程上，旧版API使用起来更容易上手；然而，Keras式的API也有其好处，那就是强制用户必须按照规范、统一的标准处理API的定义和接口，使得用户更容易建立规范的编写习惯。","text_tokens":["好处","(","过程","用户","为","对","手","自己","一节","讨论","非常","实现","这","变换","存在","式","，","其","{","keras","~","tensorflow","两层","和","入门","现成","例如","1","；","激活","设法","就是","在","定义","使用","内容","规范","residual","api","network","上","新","难度","技术","会","来","inception","可能","构造","必须","自定","我们","分别","网络层","神经网络","层","标准","偏向","lambda","自行","应用","成","提供","使得","已经","按照","函数","_","的",",","广泛","本节","神经","容易","然而","功能","熟悉","知道","中均","未","具有","那","地","网络","建立","也","\\","一定"," ","有","h","仍然","于","该","因此","而言","统一","起来","读者","强制","mathbf","自定义","实在","发现","}","可以","著名","2","需要",")","处理","旧版","-","。","问题","这些","更","并未","但","编写","、","一个","习惯","是","即","模型","神经网","中","而且","接口"],"title":"解非线性回归问题","title_tokens":["问题","非线性","回归","解","线性"]},{"location":"book-1-x/chapter-1/nonlinear-regression/#_7","text":"自定义Keras层的方法可以参照： 编写你自己的Keras层 - Keras中文文档 编写好的层是一个类API，可以同时被顺序模型或类模型调用。","text_tokens":["自定义","api","文档","或类","自己","：","的","可以","类","，","-","顺序","keras","。","编写","你","一个","参照","被","自定"," ","是","中文","好","模型","方法","层","定义","调用","同时"],"title":"自定义网络层","title_tokens":["自定","自定义","网络层","网络","定义"]},{"location":"book-1-x/chapter-1/nonlinear-regression/#_8","text":"让我们观察Tensorflow-keras模型对最简单的层，全连接层 Dense 的定义（我们之前也分别在顺序模型和类模型中使用过该API）。下面的内容摘自 Tensorflow源码 ： import 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from tensorflow.python.eager import context from tensorflow.python.framework import common_shapes from tensorflow.python.framework import ops from tensorflow.python.framework import tensor_shape from tensorflow.python.keras import activations from tensorflow.python.keras import backend as K from tensorflow.python.keras import constraints from tensorflow.python.keras import initializers from tensorflow.python.keras import regularizers from tensorflow.python.keras.engine.base_layer import Layer from tensorflow.python.keras.engine.input_spec import InputSpec from tensorflow.python.keras.utils import conv_utils from tensorflow.python.keras.utils import generic_utils from tensorflow.python.keras.utils import tf_utils from tensorflow.python.ops import array_ops from tensorflow.python.ops import gen_math_ops from tensorflow.python.ops import math_ops from tensorflow.python.ops import nn from tensorflow.python.ops import nn_ops from tensorflow.python.ops import standard_ops from tensorflow.python.util.tf_export import tf_export class Dense 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @tf_export ( 'keras.layers.Dense' ) class Dense ( Layer ): def __init__ ( self , units , activation = None , use_bias = True , kernel_initializer = 'glorot_uniform' , bias_initializer = 'zeros' , kernel_regularizer = None , bias_regularizer = None , activity_regularizer = None , kernel_constraint = None , bias_constraint = None , ** kwargs ) def build ( self , input_shape ) def call ( self , inputs ) def compute_output_shape ( self , input_shape ) def get_config ( self ) doc string 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class Dense ( Layer ): \"\"\"Just your regular densely-connected NN layer. `Dense` implements the operation: `output = activation(dot(input, kernel) + bias)` where `activation` is the element-wise activation function passed as the `activation` argument, `kernel` is a weights matrix created by the layer, and `bias` is a bias vector created by the layer (only applicable if `use_bias` is `True`). Note: if the input to the layer has a rank greater than 2, then it is flattened prior to the initial dot product with `kernel`. Example: # as first layer in a sequential model: model = Sequential() model.add(Dense(32, input_shape=(16,))) # now the model will take as input arrays of shape (*, 16) # and output arrays of shape (*, 32) # after the first layer, you don't need to specify # the size of the input anymore: model.add(Dense(32)) Arguments: units: Positive integer, dimensionality of the output space. activation: Activation function to use. If you don't specify anything, no activation is applied (ie. \"linear\" activation: `a(x) = x`). use_bias: Boolean, whether the layer uses a bias vector. kernel_initializer: Initializer for the `kernel` weights matrix. bias_initializer: Initializer for the bias vector. kernel_regularizer: Regularizer function applied to the `kernel` weights matrix. bias_regularizer: Regularizer function applied to the bias vector. activity_regularizer: Regularizer function applied to the output of the layer (its \"activation\").. kernel_constraint: Constraint function applied to the `kernel` weights matrix. bias_constraint: Constraint function applied to the bias vector. Input shape: nD tensor with shape: `(batch_size, ..., input_dim)`. The most common situation would be a 2D input with shape `(batch_size, input_dim)`. Output shape: nD tensor with shape: `(batch_size, ..., units)`. For instance, for a 2D input with shape `(batch_size, input_dim)`, the output would have shape `(batch_size, units)`. \"\"\" Dense.__init__ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Dense ( Layer ): def __init__ ( self , units , activation = None , use_bias = True , kernel_initializer = 'glorot_uniform' , bias_initializer = 'zeros' , kernel_regularizer = None , bias_regularizer = None , activity_regularizer = None , kernel_constraint = None , bias_constraint = None , ** kwargs ): if 'input_shape' not in kwargs and 'input_dim' in kwargs : kwargs [ 'input_shape' ] = ( kwargs . pop ( 'input_dim' ),) super ( Dense , self ) . __init__ ( activity_regularizer = regularizers . get ( activity_regularizer ), ** kwargs ) self . units = int ( units ) self . activation = activations . get ( activation ) self . use_bias = use_bias self . kernel_initializer = initializers . get ( kernel_initializer ) self . bias_initializer = initializers . get ( bias_initializer ) self . kernel_regularizer = regularizers . get ( kernel_regularizer ) self . bias_regularizer = regularizers . get ( bias_regularizer ) self . kernel_constraint = constraints . get ( kernel_constraint ) self . bias_constraint = constraints . get ( bias_constraint ) self . supports_masking = True self . input_spec = InputSpec ( min_ndim = 2 ) Dense.build 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Dense ( Layer ): def build ( self , input_shape ): input_shape = tensor_shape . TensorShape ( input_shape ) if tensor_shape . dimension_value ( input_shape [ - 1 ]) is None : raise ValueError ( 'The last dimension of the inputs to `Dense` ' 'should be defined. Found `None`.' ) last_dim = tensor_shape . dimension_value ( input_shape [ - 1 ]) self . input_spec = InputSpec ( min_ndim = 2 , axes = { - 1 : last_dim }) self . kernel = self . add_weight ( 'kernel' , shape = [ last_dim , self . units ], initializer = self . kernel_initializer , regularizer = self . kernel_regularizer , constraint = self . kernel_constraint , dtype = self . dtype , trainable = True ) if self . use_bias : self . bias = self . add_weight ( 'bias' , shape = [ self . units ,], initializer = self . bias_initializer , regularizer = self . bias_regularizer , constraint = self . bias_constraint , dtype = self . dtype , trainable = True ) else : self . bias = None self . built = True Dense.call 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Dense ( Layer ): def call ( self , inputs ): inputs = ops . convert_to_tensor ( inputs ) rank = common_shapes . rank ( inputs ) if rank > 2 : # Broadcasting is required for the inputs. outputs = standard_ops . tensordot ( inputs , self . kernel , [[ rank - 1 ], [ 0 ]]) # Reshape the output back to the original ndim of the input. if not context . executing_eagerly (): shape = inputs . get_shape () . as_list () output_shape = shape [: - 1 ] + [ self . units ] outputs . set_shape ( output_shape ) else : outputs = gen_math_ops . mat_mul ( inputs , self . kernel ) if self . use_bias : outputs = nn . bias_add ( outputs , self . bias ) if self . activation is not None : return self . activation ( outputs ) # pylint: disable=not-callable return outputs Dense.compute_output_shape 1 2 3 4 5 6 7 8 9 class Dense ( Layer ): def compute_output_shape ( self , input_shape ): input_shape = tensor_shape . TensorShape ( input_shape ) input_shape = input_shape . with_rank_at_least ( 2 ) if tensor_shape . dimension_value ( input_shape [ - 1 ]) is None : raise ValueError ( 'The innermost dimension of input_shape must be defined, but saw: %s ' % input_shape ) return input_shape [: - 1 ] . concatenate ( self . units ) Dense.get_config 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Dense ( Layer ): def get_config ( self ): config = { 'units' : self . units , 'activation' : activations . serialize ( self . activation ), 'use_bias' : self . use_bias , 'kernel_initializer' : initializers . serialize ( self . kernel_initializer ), 'bias_initializer' : initializers . serialize ( self . bias_initializer ), 'kernel_regularizer' : regularizers . serialize ( self . kernel_regularizer ), 'bias_regularizer' : regularizers . serialize ( self . bias_regularizer ), 'activity_regularizer' : regularizers . serialize ( self . activity_regularizer ), 'kernel_constraint' : constraints . serialize ( self . kernel_constraint ), 'bias_constraint' : constraints . serialize ( self . bias_constraint ) } base_config = super ( Dense , self ) . get_config () return dict ( list ( base_config . items ()) + list ( config . items ())) 为了便于读者阅读，我们将它按照重定义的方法分成了几片不同的代码。下面我们来分别观察不同代码里实现的内容。","text_tokens":["42","29","17","trainable","18","defined","size","27","passed","class","源码","add","tensordot","和","after","shape","layers","了","观察","take","1","'","engine","连接","required","使用","argument","weight","int","initializer","26","least","32","constraints","13","get","serialize","would","integer","compute","is","units","flattened","product","层","output","35","mul","tf","_","bias","k","24","context","39","model","顺序","example","have","5","过该","has","applied","31","doc","then","10","}","dict","37","def","38","4","ops","be","back","2d","19","(","valueerror","arrays","kwargs","matrix",".","*","build","at","most","，","input","tensorflow","eagerly","return","use","last","44","将","anymore","rank","disable","uniform","t","api","self","reshape","几片","specify","positive","ndim","conv","value","else","utils",":","mat","executing","import","but","[","分别","util","applicable","list","greater","not","20","set","whether","便于","built","prior","重","里","connected",">","ie","分成","21","implements","+","23","min","12","array","supports","situation","下面","gen","as","11","43","uses","tensor","14","created","对","：","28","function","s","22","之前","实现","全","must","0","pop","to","nn","在","定义","内容","34","dimension","if","\"","`","inputs","sequential","...","来","简单","activity","will","dense","batch","activations","none","only","dim","no","masking","now","element","constraint","original","than","note","regularizer","base","25","string","spec","your","anything","layer","按照","）","30","的",",","15","of","true","x","broadcasting","nd","也","common","space","backend","glorot","41","让","为了",".__","tensorshape","类","2","generic","9","代码","最","linear","boolean","initializers","kernel","16","arguments","the","模型","call","concatenate","regularizers","in","regular","摘自","inputspec","activation","阅读","%","callable","shapes","from","{","keras","by","6","zeros","dimensionality","config","outputs","33","方法","pylint","不同","where","40","for","you","its","dot","axes","我们","__","operation","initial","3","super","a","convert","first","dtype","items","（","it","with","don","export","raise","should","math","standard"," ","vector","wise","读者","init","]","36","and","instance","它","@","just","#",")","7","densely","-","8","=","。","..","weights","innermost","found","saw","framework","python","need","中","eager"],"title":"学习一个完全规范化的风格","title_tokens":["的","完全","范化","学习","风格","一个","规范","规范化"]},{"location":"book-1-x/chapter-1/nonlinear-regression/#_9","text":"首先，在 __init__ 方法中，定义了用来初始化该层的所有可选参数。从这一段代码，可以观察到以下结论： units 是 Dense 的输出维度，是唯一一个必选参量，并用 int() 强制转换的方式确保输入的是整数。 除了布尔类型的输入，其他所有的输入都使用 tensorflow.python.keras 下的对应方法保护起来。例如， kernel_regularizer 的实现通过 keras.regularizers 方法初始化。这是为了确保用户使用该接口时，既可以使用字符串指定正则化器，也可以通过一个现成的正则化器实例来指定。 supports_masking 和 input_spec 这两个量由类本身决定，不受用户初始化参数的影响。 input_spec 用来限定输入网络的张量必须具有哪些属性，参见官方文档对 tf.keras.layers.InputSpec 的说明。 supports_masking 用来表示该输入是否支持 Masking 层，参见 Masking - Keras中文文档 对该层的介绍。它主要用来取消时序模型（一般是RNN/LSTM）中缺失的时间点数据对网络结果的影响。一般来说，一个与时序无关的（或者称为时不变(timeless)的）模型，直接设该值为True即可。 特别地， activity_regularizer 通过覆盖输入参量的默认值来实现。这是因为在 Dense 的父类 Layer 中，已经定义过 activity_regularizer 。其他的参量不能通过这种方式实现，是因为它们都跟新加入的参数有关。","text_tokens":["regularizers","一般来说","(","用户","因为","为","对","既","从","：","保护","inputspec","表示","与",".","加入","实现","这","参见","初始化","，","数据","时间","值","keras","input","默认","属性","首先","必选","tensorflow","和","支持","其他","layers","了","一段","观察","并用","例如","现成","到","不","跟","覆盖","在","方法","定义","是否","使用","设该","时序","可","称为","点","int","对应","主要","影响","哪些","文档","唯一","取消","时","新","这是","即可","输出","限定","实例","决定","来","张量","activity","介绍","布尔","dense","结果","这种","所有","units","特别","缺失","必须","masking","选","timeless","__","层","化器","/","用来","指定","regularizer","参数","由类","字符串","通过","spec","父类","整数","layer","已经","）","tf","转换","_","的","一般","无关","（","结论","参量","rnn","初始","true","受","具有","地","网络","直接","也","方式"," ","官方","中文","该","都","强制","起来","该层","init","输入","过","它们","为了","默认值","它","lstm","或者","来说","可以","说明",")","除了","本身","两个","是因为","以下","supports","字符","代码","-","。","确保","下","kernel","正则","一个","不能","不变","维度","是","python","量","有关","类型","模型","中","接口"],"title":"初始化方法","title_tokens":["初始","方法","初始化"]},{"location":"book-1-x/chapter-1/nonlinear-regression/#_10","text":"接下来，让我们观察 build 方法。在该方法中，我们实现了网络中各参数的构造过程。 首先，通过 input_shape 来得到输入张量的形状。在本例中，特别检查了 input_shape 的规范性，确保输入数据的最后一个维度值为已知。因为， Dense 的API允许用户只通过输入来自上一层的张量，来推断全连接层的输入维度。特别地，如果我们的层有多个输入， input_shape 会是一个 list 类型。 接下来，通过 self.add_weight 或 self.add_variable 来添加参数。该方法的用法参见官方文档中的 Layers.add_weight 。它接受包括初始化器 initializer ，正则化器 regularizer 等一系列参数，这些参数都要求必须是具有回调属性的实例。这一条件我们已经在 __init__ 方法中满足了。 最后，设定 self.built 为 True 。事实上，Keras推荐我们使用类似 super ( Dense , self ) . build ( input_shape ) 的方式来完成这一设置，这种做法和显式地设定 self.built 等价。","text_tokens":["形状","过程","(","用户","因为","一层","为",".","build","实现","全","参见","初始化","最后","，","数据","显式","input","add","keras","属性","首先","和","shape","layers","了","观察","本例","系列","完成","连接","在","下来","方法","使用","weight","规范","检查","api","initializer","这一","self","文档","上","来自","允许","variable","实例","要求","会","来","张量","用法","一系列","dense","这种","添加","特别","各","事实","包括","构造","必须","接下","我们","设置","只","__","层","化器","等价","regularizer","参数","list","super","通过","条件","已经","值为","_","接下来","的",",","范性","回调","事实上","初始","true","接受","器","具有","built","规范性","地","网络","方式"," ","有","多个","官方","该","推断","类似","都","init","输入","等","让","它","推荐","如果",")","得到","已知","设定","。","做法","这些","确保","正则","一个","维度","是","满足","或","类型","一系","中"],"title":"构造方法","title_tokens":["构造","方法","构造方法"]},{"location":"book-1-x/chapter-1/nonlinear-regression/#_11","text":"接下来观察 call 方法。该方法接受的是该层实际输入的张量，同时也输出一个张量，该输出张量即使该层的输出结果。可以说，在该方法中，我们才正式开始实现层的实际功能。 在该范例中，该方法的实现是通过Tensorflow最底层的标准API。这些API对用户来说是封装起来的，一般情况下用户不需要使用它们。实际上，该方法实现的就是 \\mathbf{y} = \\mathbf{W} \\mathbf{x} + \\mathbf{b} \\mathbf{y} = \\mathbf{W} \\mathbf{x} + \\mathbf{b} 的过程。这种代码风格显得颇为繁琐，但是它提供了精密的参数检查和高效的API操作。我们不会讨论这段代码的具体实现细节，因为它既然是被封装的API，我们一般来说就不需要调用它们实现功能（除非我们需要修改使用同样被封装的底层API所编写的模块）。等价地，我们分别介绍Keras API和Tensorflow API如何做到相同的效果。 首先是Keras API版本的等效代码，它修改自 Keras中文文档 ： Dense.call 1 2 3 4 5 6 7 def call ( self , inputs ): res = K . dot ( inputs , self . kernel ) if self . use_bias : res = res + self . bias if self . activation is not None : res = self . activation ( res ) return res 接下来是Tensorflow API版本的等效代码， Dense.call 1 2 3 4 5 6 7 8 9 def call ( self , inputs ): inputs = tf . convert_to_tensor ( inputs ) rank = tf . rank ( inputs ) res = tf . tensordot ( inputs , self . kernel , [[ rank - 1 ], [ 0 ]]) if self . use_bias : res = tf . nn . bias_add ( inputs , self . bias ) if self . activation is not None : res = self . activation ( res ) return res 与Keras API的实现相比，Tensorflow API主要区别是使用 tf.tensordot 时需要指定执行矩阵计算的两轴。实际上，使用Tensorflow API对已经较为熟悉Tensorflow旧版API的用户是十分亲切的，它使我们找回了当初自己编写中层API的感觉。","text_tokens":["一般来说","过程","(","使","用户","因为","操作","最底层","对","自己","：","讨论","与",".","做到","实现","activation","这","既然","，","范例","除非","0","{","keras","add","较为","tensordot","首先","tensorflow","但是","和","return","中层","use","6","了","观察","显得","1","等效","同样","相同","两轴","不","相比","就是","to","nn","rank","在","下来","方法","风格","十分","使用","同时","不会","段","情况","检查","颇为","当初","api","self","主要","if","文档","自","时","输出","inputs","张量","介绍","执行","检查和","亲切","dense","结果","is","这种","none","dot",":","接下","封装","我们","[","分别","如何","res","层","高效","标准","等价","3","指定","参数","通过","convert","提供","即使","说","繁琐","已经","w","）","tf","_","接下来","的","一般",",","not","（","效果","bias","k","感觉","熟悉","功能","接受","x","5","模块","地","也","\\","被"," ","中文","该","起来","才","精密","所","该层","就","输入","]","它们","mathbf","+","具体","它","}","来说","实际","可以","需要","2",")","旧版","7","def","4","代码","9","-","开始","8","=","。","这些","底层","修改","矩阵","下","实际上","kernel","编写","版本","一个","正式","是","y","b","区别","tensor","调用","call","中","细节","计算","找回"],"title":"回调方法","title_tokens":["回调","方法"]},{"location":"book-1-x/chapter-1/nonlinear-regression/#_12","text":"接下来观察 compute_output_shape 方法。我们知道Tensorflow-Keras支持对每一层的输入输出作形状推断，而形状推断的具体实现就在这一步。 问题 为什么我们需要定义这个方法？难道我们不可以直接通过对输出张量计算 K.shape(output) 或 tf.shape(output) 来确定输出形状吗？ 这是由于，对Tensorflow-Keras而言，推断网络各层的形状和推断网络各层的张量是两码事。定义该方法能够确保我们在不调用任何一个 call 方法的前提下，推断出整个网络各层的输入、输出形状。 这里实现这一方法的过程仍然是调用Tensorflow的最底层API。事实上，Keras API对这一方法的输出并没有严格的要求，它可以是一个 tf.Shape ，可以是一个 list / tuple ，还可以是将两者元素混合在一起的 list 。我们不考虑对输入形状进行这些检查，那么，一个简单的，Keras风格的改写是 Dense.compute_output_shape 1 2 def compute_output_shape ( self , input_shape ): return ( * input_shape [:, - 1 ], self . units ) 或者我们可以更规范一点，使用Tensorflow API来确保该方法的输入、输出和具体操作都是对 tf.Shape 进行的 Dense.compute_output_shape 1 2 3 4 class Dense ( Layer ): def compute_output_shape ( self , input_shape ): input_shape = tensor_shape . TensorShape ( input_shape ) return input_shape [: - 1 ] . concatenate ( self . units )","text_tokens":["？","形状","(","过程","一层","操作","最底层","对",".","class","*","实现","这","严格","，","推断出","两者","keras","输入输出","那么","input","tensorflow","支持","和","shape","return","观察","1","不","将","在","下来","方法","定义","tuple","风格","使用","规范","检查","这里","任何","api","这一","self","整个","没有","这是","输出","要求","张量","来","简单","compute","dense","各层","元素","改写","体操","units","事实","每",":","接下","前提","我们","[","这个","/","3","list","并","通过","而","output","layer","tf","_","接下来","的","为什么",",","k","一","事实上","由于","知道","还","两码事","网络","直接"," ","两码","仍然","该","推断","而言","都","吗","就","输入","考虑","]","难道","具体","它","或者","tensorshape","进行","需要","一步","可以","确定","2","作",")","一起","def","4","混合","-","什么","能够","具体操作","=","。","问题","这些","更","底层","确保","下","、","一个","是","或","tensor","一点","call","调用","计算","concatenate"],"title":"输出形状方法","title_tokens":["方法","形状","输出"]},{"location":"book-1-x/chapter-1/nonlinear-regression/#_13","text":"最后，在 get_config 中，我们将我们自定义的所有参数实例，通过 serialize 方法加入到该层的参数设置字典中。实现这一步是颇为重要的（但是在 Keras中文文档 中并未提及），它允许我们将我们自己定义的网络层编译成一个包含设置信息的字典，并允许我们通过该字典重构出具有相同参数设置的层来，参见： 关于Keras网络层 - Keras中文文档 例如，对一个 Dense 层，通过该方法重构的步骤是 1 2 3 layer = Dense ( 32 ) config = layer . get_config () reconstructed_layer = Dense . from_config ( config ) 综上，我们可以从官方代码如何定义 Dense 层学习到我们自己应该如何定义类似的层。事实上，我们建议读者在自定义任何层之前，先选择一个与我们要自定义的层形式相似的层，阅览官方代码，了解定义一个这样的层大致的步骤，然后再开始实际行动。","text_tokens":["建议","(","对","自己","：","从","然后","与",".","加入","实现","之前","形式","这","步骤","再","出","参见","最后","，","from","包含","keras","但是","例如","1","到","config","相同","将","在","方法","定义","颇为","应该","任何","文档","32","编译","get","允许","这样","实例","serialize","重要","译成","来","为重","信息","dense","reconstructed","字典","所有","事实","要","自定","我们","设置","网络层","如何","参数设置","层","阅览","实际行动","3","参数","并","选择","通过","了解","layer","先","）","综上","大致","_","的","（","事实上","提及","相似","编译成","具有","网络","颇为重要","行动"," ","官方","中文","该","类似","读者","自定义","它","学习","重构","实际","可以","一步","2",")","代码","-","开始","=","。","并未","一个","是","关于","中"],"title":"设置提取方法","title_tokens":["方法","提取","设置"]},{"location":"book-1-x/chapter-1/nonlinear-regression/#_14","text":"接下来，我们考虑来自己构造一个层API。该层的表达式为： \\begin{align} \\mathbf{y} = \\eta ( \\mathbf{x} \\boldsymbol{\\omega}^T + \\mathbf{1} \\boldsymbol{\\varphi}^T ), \\end{align} 这里 \\mathbf{x} \\mathbf{x} 为输入的列向量（但是注意在代码中它是行向量）， \\mathbf{1} \\mathbf{1} 是一个与 \\mathbf{x} \\mathbf{x} 形状相同的，值全为1的向量； \\boldsymbol{\\omega},~\\boldsymbol{\\varphi} \\boldsymbol{\\omega},~\\boldsymbol{\\varphi} 为可训练的参数，而 \\eta(\\cdot) \\eta(\\cdot) 是一个应用在元素级的激活函数。我们考虑实现以下功能： 该层输入一个形状为 [ N , L ] 的向量组，输出一个形状为 [ N , L , M ] 的矩阵组，其中 M 是参数 \\boldsymbol{\\omega} \\boldsymbol{\\omega} 的长度。因此，该层不需要获取输入向量的形状，但需要定义输出矩阵的列数 M 。换言之，该层的作用是将向量升维成低秩矩阵； 参数 \\boldsymbol{\\omega},~\\boldsymbol{\\varphi} \\boldsymbol{\\omega},~\\boldsymbol{\\varphi} 都可以指定初始化器、正则化器和限制条件，就像 Dense 层一样； 可以选择是否使用 \\boldsymbol{\\varphi} \\boldsymbol{\\varphi} ，就像在 Dense 层我们可以选择是否使用 biase 一样； 激活函数 \\eta(\\cdot) \\eta(\\cdot) 可以是一个任意的激活函数，并且允许我们为它添加正则化器。 综上，我们定义该层为 class UpDimAffine ( Layer ): UpDimAffine.__init__ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def __init__ ( self , units , activation = None , use_bias = True , kernel_initializer = 'glorot_uniform' , bias_initializer = 'zeros' , kernel_regularizer = None , bias_regularizer = None , activity_regularizer = None , kernel_constraint = None , bias_constraint = None , ** kwargs ): if 'input_shape' not in kwargs and 'input_dim' in kwargs : kwargs [ 'input_shape' ] = ( kwargs . pop ( 'input_dim' ),) super ( UpDimAffine , self ) . __init__ ( activity_regularizer = regularizers . get ( activity_regularizer ), ** kwargs ) self . units = int ( units ) self . activation = activations . get ( activation ) self . use_bias = use_bias self . kernel_initializer = initializers . get ( kernel_initializer ) self . bias_initializer = initializers . get ( bias_initializer ) self . kernel_regularizer = regularizers . get ( kernel_regularizer ) self . bias_regularizer = regularizers . get ( bias_regularizer ) self . kernel_constraint = constraints . get ( kernel_constraint ) self . bias_constraint = constraints . get ( bias_constraint ) self . supports_masking = True self . input_spec = InputSpec ( min_ndim = 2 ) UpDimAffine.build 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def build ( self , input_shape ): input_shape = tf . TensorShape ( input_shape ) self . kernel = self . add_weight ( 'kernel' , shape = [ 1 , self . units ], initializer = self . kernel_initializer , regularizer = self . kernel_regularizer , constraint = self . kernel_constraint , dtype = self . dtype , trainable = True ) if self . use_bias : self . bias = self . add_weight ( 'bias' , shape = [ 1 , self . units ], initializer = self . bias_initializer , regularizer = self . bias_regularizer , constraint = self . bias_constraint , dtype = self . dtype , trainable = True ) else : self . bias = None super ( UpDimAffine , self ) . build ( input_shape ) UpDimAffine.call 1 2 3 4 5 6 7 8 9 10 def call ( self , inputs ): inputs = tf . expand_dims ( tf . convert_to_tensor ( inputs ), - 1 ) rank = inputs . get_shape () . ndims res = tf . tensordot ( inputs , self . kernel , [[ rank - 1 ], [ 0 ]]) if self . use_bias : varbias = tf . tensordot ( tf . ones_like ( inputs ), self . bias , [[ rank - 1 ], [ 0 ]]) res = tf . add ( res , varbias ) if self . activation is not None : res = self . activation ( res ) return res UpDimAffine.compute_output_shape 1 2 3 def compute_output_shape ( self , input_shape ): input_shape = tensor_shape . TensorShape ( input_shape ) return input_shape . concatenate ( self . units ) UpDimAffine.get_config 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def get_config ( self ): config = { 'units' : self . units , 'activation' : activations . serialize ( self . activation ), 'use_bias' : self . use_bias , 'kernel_initializer' : initializers . serialize ( self . kernel_initializer ), 'bias_initializer' : initializers . serialize ( self . bias_initializer ), 'kernel_regularizer' : regularizers . serialize ( self . kernel_regularizer ), 'bias_regularizer' : regularizers . serialize ( self . bias_regularizer ), 'activity_regularizer' : regularizers . serialize ( self . activity_regularizer ), 'kernel_constraint' : constraints . serialize ( self . kernel_constraint ), 'bias_constraint' : constraints . serialize ( self . bias_constraint ) } base_config = super ( UpDimAffine , self ) . get_config () return dict ( list ( base_config . items ()) + list ( config . items ())) 这组定义完全启发自 Dense 的定义，因此改动其实不多，与 Dense 相比，主要的区别是 call 方法的实现。特别地，与 Dense 相同的是，我们使用 tf.tensordot 来指定对两个高维度的张量，取前一个张量的最后一维和第二个张量的第一维来进行矩阵乘法。","text_tokens":["regularizers","in","形状","其中","(","14","17","trainable","改动","18","为","inputspec","对","自己","：","kwargs","与",".","class","*","22","build","实现","activation","end","初始化","最后","，","表达","值","0","{","input","add","~","tensordot","但是","和","shape","return","use","6","zeros","1","高","启发","；","激活","'","m","相同","config","不","将","相比","维和","pop","to","rank","在","下来","方法","定义","是否","使用","uniform","可","获取","weight","cdot","t","这里","int","api","表达式","initializer","self","主要","列数","if","二个","第二个","自","constraints","13","行向量","get","允许","输出","serialize","inputs","组","列","^","来","ndim","张量","activity","dense","compute","else","元素","ndims","is","activations","添加","none","units","特别","dim","构造",":","masking","接下","我们","[","__","res","层","constraint","化器","第一","指定","3","参数","regularizer","base","应用","n","super","秩","dtype","list","选择","spec","convert","而","并且","begin","output","layer","条件","任意","）","综上","tf","函数","接下来","的",",","_","not","（","20","items","bias","一","功能","初始","15","true","x","器","5","作用","boldsymbol","l","ones","注意","地","omega","eta","varbias","\\","低"," ","像","21","因此","都","like","biase","维来","glorot","长度","该层","就","输入","考虑","]","init","向量","mathbf","升维成","其实","乘法","and","10","+","多",".__","它","级","updimaffine","一样","}","tensorshape","expand","min","第二","进行","训练","需要","可以","2","12","dict",")","dims","7","两个","def","以下","supports","4","代码","9","-","换言之","8","这组","=","varphi","。","完全","矩阵","initializers","align","但","kernel","取前","达式","、","正则","一个","16","11","维度","是","y","限制","区别","全为","tensor","中","call","19","concatenate"],"title":"自定义第一层","title_tokens":["自定","自定义","一层","第一层","定义","第一"]},{"location":"book-1-x/chapter-1/nonlinear-regression/#_15","text":"第二层的表达式为： \\begin{equation} \\begin{aligned} \\mathbf{y}_1 = \\mathrm{Re}\\{ \\mathrm{FFT}( \\mathbf{x} \\mathbf{a} ) \\}, \\\\ \\mathbf{y}_2 = \\mathrm{Im}\\{ \\mathrm{FFT}( \\mathbf{x} \\mathbf{a} ) \\}, \\end{aligned} \\end{equation} 这里 \\mathbf{x} \\mathbf{x} 为输入的矩阵， \\mathrm{FFT}(\\cdot) \\mathrm{FFT}(\\cdot) 是快速傅里叶变换。我们使用 \\mathbf{y}_1 \\mathbf{y}_1 和 \\mathbf{y}_2 \\mathbf{y}_2 来表示输出是具有两个通道的向量。我们考虑实现以下功能： 该层输入一个形状为 [ N , L , M ] 的向量组，输出一个形状为 [ N , l , 2 ] 的矩阵组，其中 L 在 l 为奇数时，取 (L+1)/2 ；在 L 为偶数时，取 L/2+1 ； 2 是两个通道，分别表示傅里叶变换的实部值和虚部值，同时，从输出可以看出傅里叶变换将使信号长度折半； 参数只有 \\mathbf{a} \\mathbf{a} ，它可以指定初始化器、正则化器和限制条件，就像 Dense 层一样； 我们不使用两输出的形式，而是使用单输出、两通道的形式来定义该层，是为了方便处理后续的步骤（计算损失函数）。 这里我们介绍一种新的定义层的方法，即“使用层来定义层”。该层定义为 class FFTAffine ( Layer ): FFTAffine.__init__ 1 2 3 4 5 6 7 8 9 10 11 def __init__ ( self , kernel_initializer = 'glorot_uniform' , kernel_regularizer = None , kernel_constraint = None , ** kwargs ): if 'input_shape' not in kwargs and 'input_dim' in kwargs : kwargs [ 'input_shape' ] = ( kwargs . pop ( 'input_dim' ),) super ( FFTAffine , self ) . __init__ ( ** kwargs ) self . kernel_initializer = initializers . get ( kernel_initializer ) self . kernel_regularizer = regularizers . get ( kernel_regularizer ) self . kernel_constraint = constraints . get ( kernel_constraint ) self . supports_masking = True self . input_spec = InputSpec ( min_ndim = 3 ) FFTAffine.build 1 2 3 4 5 6 7 8 def build ( self , input_shape ): input_shape = tf . TensorShape ( input_shape ) self . layer_Dense = tf . keras . layers . Dense ( 1 , use_bias = False , kernel_initializer = self . kernel_initializer , kernel_regularizer = self . kernel_regularizer , kernel_constraint = self . kernel_constraint ) self . layer_Dense . build ( input_shape ) super ( FFTAffine , self ) . build ( input_shape ) FFTAffine.call 1 2 3 4 5 6 7 def call ( self , inputs ): res = tf . squeeze ( self . layer_Dense ( inputs ), - 1 ) res = tf . signal . rfft ( res ) res_r = tf . expand_dims ( tf . real ( res ), - 1 ) res_i = tf . expand_dims ( tf . imag ( res ), - 1 ) res = tf . concat ([ res_r , res_i ], - 1 ) return res FFTAffine.compute_output_shape 1 2 3 4 5 6 7 8 9 10 def compute_output_shape ( self , input_shape ): input_shape = tf . TensorShape ( input_shape ) shape_lst = input_shape . as_list () if shape_lst [ - 2 ] is None : return input_shape [: - 1 ] . concatenate ( 2 ) else : if shape_lst [ - 2 ] % 2 == 0 : return input_shape [: - 2 ] . concatenate ( shape_lst [ - 2 ] // 2 + 1 ) . concatenate ( 2 ) else : return input_shape [: - 2 ] . concatenate (( shape_lst [ - 2 ] + 1 ) // 2 ) . concatenate ( 2 ) FFTAffine.get_config 1 2 3 4 5 6 7 8 def get_config ( self ): config = { 'kernel_initializer' : initializers . serialize ( self . kernel_initializer ), 'kernel_regularizer' : regularizers . serialize ( self . kernel_regularizer ), 'kernel_constraint' : constraints . serialize ( self . kernel_constraint ) } base_config = super ( FFTAffine , self ) . get_config () return dict ( list ( base_config . items ()) + list ( config . items ())) 首先，我们需要观察的是 __init__ 和 get_config 两个方法。由于该层只有一个参数 \\mathbf{a} \\mathbf{a} ，我们因此只需要为它指定初始化器、正则化器和限制条件即可。这一步和之前处理第一层的情况相似。 接下来，观察 build ，与定义第一层情况不同的是，在这里我们不是使用基本API (例如 add_weights )，而是来自 tf.keras.layers 的层API， Dense 。我们将初始化时构建的三个实例馈入 Dense 的参数中。并且，在这一阶段，我们不调用 Dense 处理张量，而是直接获取 Dense 的实例。 提示 注意我们在这里手动调用了 self.layer_Dense.build(input_shape) 。 在一些行内的人眼里，这一步是不可或缺的，因为只有调用了 build 方法，我们定义的 Dense 类才会实例化其内的参数。但事实不完全如此，即使我们去掉这一行，即不调用 Dense 的 build 方法，效果也完全一样。这是因为 Dense 的父类 Layer （当然也是我们继承的父类）具有检查 self.built 是否为 True 的能力，并在调用某些方法的时候，如果发现 self.built 为 False ，则自动调用 build 。这属于 build 方法的隐式调用。 虽然如此，我们仍然提倡用户一定要手动定义 build 。其一是因为，这种显式的定义在逻辑上是通顺、符合人的直觉的；其二是因为，我们不能完全确保自定义层里的所有子层的 build 方法一定会在任何情况下都能隐式触发。况且，这种做法是完全可行的，活用 compute_output_shape 或 tf.shape 等方法，我们可以做到手动触发一个有多个子层的自定义层中的所有子层的 build 方法。 提示 有些行内的人指出，在使用 build 方法时，应当显式地将子层的可训练、不可训练参数都反馈给自定义层的参数表（参见 StackOverflow的讨论串 ），具体的操作如下： self . _trainable_weights = self . layer_Dense . trainable_weights self . _non_trainable_variables = self . layer_Dense . non_trainable_variables 然而必须指出的是，这种做法是不正确的。因为观察 源代码 可以发现， trainable_weights 和 non_trainable_variables 都是封装好的属性方法。私有变量 _trainable_weights 和 _non_trainable_variables 与前者不同的是，这两个私有变量包含的是 直属于本层的可训练、不可训练变量 ；但前者的实现分别是 本层和本层的所有子层的所有可训练、不可训练变量 。因此，将子层的所有变量加诸自定义层的直属变量里，是多余、且容易造成误解的做法。 观察 call 方法，在该方法里，我们首先将维度为 [ N , L , M ] 的参数通过无bias的全连接层映射到 [ N , L , 1 ] ，再压缩最后一维度，得到维度为 [ N , L ] 的向量，通过Tensorflow自带的实值FFT变换函数 tf.signal.rfft ，得到复数域的输出 [ N , l ] ，对该输出分别取实部和虚部，再将两实值化的结果以通道的形式并在一起，最终我们就得到两通道的输出 [ N , l , 2 ] 。其中，第一个通道是傅里叶变换的实部，第二个通道是傅里叶变换的虚部。 信息 实际上，Tensorflow的官方教程给出了一种自定义层的范例，参看 Custom layers 。在这一范例中，使用 tf.keras.Model 定义一个有多个子层的模型，且该模型的使用方法和 Layer 一样。从某种程度上，这种方法比我们使用的方法更简洁。然而，需要指出的是， Model类继承 - Keras中文文档 也提到了这种做法，但使用 Model 类继承会导致网络具体实现的细节变得不可追索，具体而言就是形如 Model.to_json 、 Model.to_yaml 、 Model.get_config 和 Model.save 等方法变得不可用。 我们的这种做法则不存在这个问题，因为我们在每个自定义层里都定义了 get_config 方法，从而使得我们可以像使用内置的层API一样来使用它们。 最后，观察 compute_output_shape 方法，在这里，我们需要推断经过傅里叶变换后，输出向量的长度。特别地，我们需要考虑到，输入向量的长度已知和未知两种不同情况下的处理方式。","text_tokens":["可行","一种","形状","其中","trainable","误解","一层","映射","程度","class","形式","end","参见","初始化","存在","squeeze","后续","显式","且","包含","add","和","shape","layers","了","观察","1","看出","；","'","压缩","直","连接","下来","使用","同时","cdot","情况","二个","initializer","变得","constraints","时","get","实例","serialize","会","张量","compute","结果","is","封装","损失","层","这个","化器","第一","继承","fftaffine","real","时候","aligned","output","使得","tf","_","接下来","二层","bias","model","一些","5","具有","手动","去掉","\\","官方","仍然","而言","第二层","该层","数表","如","等","参数表","10","串","发现","私有","}","训练","可以","dict","得到","一起","已知","def","4","虽然","不可或缺","其内","实际上","不能","是","signal","某种","好","细节","计算","从而","(","构建","用户","因为","应当","不是","馈入","从","kwargs","傅里叶",".","*","build","再","这","变换","表达","，","input","属性","首先","tensorflow","return","use","化","两种","将","教程","uniform","可","表达式","api","self","第二个","提倡","文档","新","来自","一行","组","加诸","ndim","介绍","else","这种","所有","复数","特别","要",":","如此","自定","接下","[","分别","有些","res","list","第一个","并","经过","non","equation","函数","variables","not","效果","逻辑","功能","由于","源代码","奇数","器","信号","“","built","能力","前者","里","注意","给","像","因此","都","长度","考虑","mathbf","i","+","im","况且","min","后","多余","dims","supports","类才","r","层里","做法","完全","矩阵","as","达式","一个","11","y","fft","提到","未知","第一层","调用","虚部值","false","使","操作","对","：","表示","与","做到","实现","偶数","之前","全","0","本层","不可","实值","例如","无","提示","m","pop","给出","内置","直觉","to","在","定义","造成","获取","检查","符合","if","上","custom","inputs","来","最终","形","dense","实部","none","事实","眼里","dim","必须","masking","折半","将子层","constraint","两","/","实部值","指定","regularizer","base","spec","父类","并且","即使","layer","触发","）","活","的",",","域","容易","变量","一","然而","初始","true","x","相似","l","imag","快速","地","也","一定","该","推断","”","glorot","json","向量","人","它们","为了",".__","具体","tensorshape","类","2","如果","处理","是因为","单","以下","9","代码","取实部","自动","更","确保","以","initializers","但","kernel","阶段","concat","维度","或","限制","其一","子层","模型","call","基本","concatenate","regularizers","lst","stackoverflow","in","re","为","比","inputspec","讨论","步骤","某些","%","用","最后","范例","{","keras","6","自带","到","config","不","正确","save","就是","其二","方法","是否","通顺","这里","rfft","任何","不同","即可","反馈","通道","追索","输出","参看","层来","属于","信息","方便","我们","如下","__","只","3","参数","super","n","a","通过","begin","条件","指出","items","（","某种程度","直属","取","能","再压缩","导致","mathrm","yaml","或缺","直接","网络","层中","方式","虚部"," ","有","多个","中文","就","输入","]","init","每个","and","自定义","它","只有","一样","expand","第二","实际","需要","一步",")","行内","两个","7","而是","-","8","当然","=","。","问题","则","下","简洁","三个","weights","正则","、","即","隐式","实值化","中"],"title":"自定义第二层","title_tokens":["自定","二层","自定义","第二层","定义","第二"]},{"location":"book-1-x/chapter-1/nonlinear-regression/#_16","text":"注意，在两个自定义层都定义好后，需要在两层定义的最后，加上如下代码： customObjects = { 'FFTAffine' : FFTAffine , 'UpDimAffine' : UpDimAffine } 该字典提供了一个索引表，将字符串形式的层名称映射到具体实现的类Object上。我们在任何涉及读取层的设置，例如 from_json 、 load_model 等方法中，都需要传入该索引表，确保Keras知道如何从配置文件里恢复出我们自定义的层。 如下代码提供了一个简单的两个自定义层叠加在一起的测试 test_layers 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import numpy as np def test_layers (): # Set model and see the summary of the model model = tf . keras . models . Sequential ([ UpDimAffine ( 10 , use_bias = True , activation = tf . math . cos , input_shape = ( 5 ,)), FFTAffine ( trainable = False ) ]) model . compile ( optimizer = optimizers . Adam ( 0.01 ), loss = tf . keras . losses . mean_squared_error , metrics = [ tf . keras . metrics . mean_squared_error ] ) model . summary () model . save ( 'my_model.h5' ) # perform the test var_input = np . ones ([ 2 , 5 ]) var_output = model . predict ( var_input ) print ( var_input . shape , var_output . shape ) print ( var_output ) test_layers () Output _________________________________________________________________ Layer ( type ) Output Shape Param # ================================================================= up_dim_affine ( UpDimAffine ) ( None, 5 , 10 ) 20 _________________________________________________________________ fft_affine ( FFTAffine ) ( None, 3 , 2 ) 10 ================================================================= Total params: 30 Trainable params: 20 Non-trainable params: 10 _________________________________________________________________ ( 2 , 5 ) ( 2 , 3 , 2 ) [[[ -3.25903225e+00 5 .96046448e-08 ] [ 1 .05201025e-07 -5.80141695e-08 ] [ 3 .23036957e-08 -3.17865378e-08 ]] [[ -3.25903225e+00 5 .96046448e-08 ] [ 1 .05201025e-07 -5.80141695e-08 ] [ 3 .23036957e-08 -3.17865378e-08 ]]] Bug 注意，Tensorflow目前的版本(r1.13)仍然有不完善之处。在上述测试中，如果我们把 tf.keras.losses.mean_squared_error 替换成 tf.keras.MeanSquaredError ，虽然该测试能正常跑通，但接下来读取已保存的网络时则会报错。这是由于目前版本的Tensorflow使用了部分废旧的API来定义读取配置的函数，在Github上的某个 讨论串 ，有人已经给出了解决方案，但仍然需要等候被新版Tensorflow采纳才能生效。 该测试首先通过顺序模型，引入了我们自定义的两个层，然后通过 summary 显示模型的详细结构，并通过 save 保存整个网络的模型配置以及具体的参数值。接下来使用一个值全为1的，形状为 [ 2 , 5 ] 的输入来测试该模型，并记录测试结果，与我们的预期完全相符。 同时，我们在设置两层的时候，刻意地令第二层的参数不可训练，实际显示的结果表明，该设置是成功的。第二个函数的10个参量确实在模型的记录里显示为不可训练的。 信息 关于如何保存网络，我们会在下一章详细展开。 接下来，为了证明我们的自定义层能完全正常地工作，我们进行读取测试， test_read 1 2 3 4 5 6 7 8 9 10 11 import numpy as np def test_read (): customObjects [ 'cos' ] = tf . math . cos new_model = tf . keras . models . load_model ( 'my_model.h5' , custom_objects = customObjects ) new_model . summary () var_input = np . ones ([ 2 , 5 ]) var_output = new_model . predict ( var_input ) print ( var_input . shape , var_output . shape ) print ( var_output ) test_read () Output _________________________________________________________________ Layer ( type ) Output Shape Param # ================================================================= up_dim_affine ( UpDimAffine ) ( None, 5 , 10 ) 20 _________________________________________________________________ fft_affine ( FFTAffine ) ( None, 3 , 2 ) 10 ================================================================= Total params: 30 Trainable params: 20 Non-trainable params: 10 _________________________________________________________________ ( 2 , 5 ) ( 2 , 3 , 2 ) [[[ -3.25903225e+00 5 .96046448e-08 ] [ 1 .05201025e-07 -5.80141695e-08 ] [ 3 .23036957e-08 -3.17865378e-08 ]] [[ -3.25903225e+00 5 .96046448e-08 ] [ 1 .05201025e-07 -5.80141695e-08 ] [ 3 .23036957e-08 -3.17865378e-08 ]]] 在该测试里，我们的模型从配置到参数，都完完全全是从文件 my_model.h5 中读取的。注意我们馈入 customObjects 给 load_model ，使Keras能发现我们自己定义的层。同时， customObjects 还需要添加 tf.math.cos 函数，这是因为该激活函数同样不在Keras内置的几种基本的激活函数之列。 我们用完全相同的输入来测试模型的输出，得到的结果和我们上一个测试完全一致，说明对该模型（包括我们自定义的两层）的保存是成功的。 观察两个测试的输出值，我们会发现，对三维的输出，在确定后两维下标 a, b 的情况下 [:, a , b ] 的输出都是一样的。这是因为，第一维反映的是向量组中不同向量的测试结果，而我们馈入模型的向量组是两个值均为1的长度为5的向量。由于这两个向量完全相同，其对应的输出也完全相同。","text_tokens":["形状","17","trainable","记录","18","映射","形式","测试","涉及","工作","和","部分","shape","0.01","layers","了","报错","观察","customobjects","1","'","相同","证明","下来","使用","同时","情况","param","时则","二个","整个","meansquarederror","13","两维","5.80141695","会","结果","表","summary","层","地令","第一","96046448e","read","fftaffine","时候","test","字符串","output","error","换成","optimizers","tf","_","3.25903225","接下来","二层","参量","bias","model","文件","顺序","知道","08","5","my","00","仍然","第二层","某个","_________________________________________________________________","等","10","var","串","发现","}","训练","完完全全","说明","一起","得到","def","4","虽然","替换成","h5","是","b","load","全为","显示","19","(","因为","馈入","从",".","这","引入","，","23036957e","解决方案","input","首先","tensorflow","两层","adam","use","激活","配置文件","同样","将","替换","完全一致","几种","cos","r1","api","对应","第二个","affine","predict","type","numpy","方案","配置",":","自定","接下","import","设置","github","[","losses","并","non","提供","print","才能","是从","函数","20","传入","set","由于","里","ones","注意","给","21","都","维","长度","+","后","12","数值","完全","有人","as","版本","一个","11","fft","关于","参数值","14","false","使","对","自己","：","然后","bug","与","e","objects","实现","出","组是","完善","其","读取","不可","生效","例如","加上","给出","内置","在","定义","以及","值均","上","新版","加在一起","np","正常","这是","确实","custom","sequential","列","来","简单","none","保存","dim","恢复","3.17865378","下标","目前","展开","up","而","loss","layer","已经","）","30","反映","see","的",",","相符","15","of","object","true","05201025e","还","地","也","该","json","完全相同","07","向量","compile","为了","已","具体","mean","updimaffine","total","进行","类","2","如果","确定","是因为","9","代码","params","metrics","确保","但","16","采纳","the","模型","上述","基本","squared","层叠","为","讨论","models","activation","一章","用","最后","from","值","{","keras","结果表明","解决","6","到","索引","不","save","方法","层能","任何","名称","跑通","不同","输出","刻意","信息","成功","字典","添加","perform","包括","把","我们","如下","表明","如何","个","3","参数","a","通过","（","能","new","废旧","网络","math","结构","三维","被"," ","有","输入","]","组中","自定义","and","等候","一致","一样","预期","#","第二","加在","实际","需要",")","处","两个","7","好后","字符","之","-","8","=","。","下","、","详细","中","optimizer"],"title":"检测效果","title_tokens":["效果","检测"]},{"location":"book-1-x/chapter-1/nonlinear-regression/#_17","text":"我们仍然使用自动生成的数据。我们重新继承了自 第一节：线性分类 里定义的数据集生成类，新定义的数据集生成器 class TestDataFFTSet ( TestDataSet ): dparser.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class TestDataFFTSet ( TestDataSet ): ''' A generator of the data set for testing the non-linear regression model. y = cos(x w^T + 1 p^T) a ''' def __init__ ( self , scale_x , len_x , omega , phi , a ): ''' Initialize the data generator. scale_x: the scale of input vector. len_x: the length of input vector. omega (w) [1 x N]: the inner linear transformation. phi (p) [1 x N]: the inner bias. a [N x 1]: the outer linear transormation. ''' self . s_x = 2 * scale_x self . omega = omega self . phi = phi self . a = a self . len_x = len_x self . config ( train = True , batch = 100 , noise = 0.0 ) def mapfunc ( self , x ): xu = np . expand_dims ( x , - 1 ) y1 = np . tensordot ( xu , self . omega , ( 2 , 0 )) y1 = np . cos ( y1 + np . tensordot ( np . ones_like ( xu ), self . phi , ( 2 , 0 ))) y2 = np . squeeze ( np . tensordot ( y1 , self . a , ( 2 , 0 )), axis =- 1 ) y2 = np . fft . rfft ( y2 ) y_r = np . expand_dims ( np . real ( y2 ), - 1 ) y_i = np . expand_dims ( np . imag ( y2 ), - 1 ) y = np . concatenate ([ y_r , y_i ], axis =- 1 ) return y def next_train ( self ): ''' Get the next train batch: (x, y) ''' x = self . next_test () y = self . mapfunc ( x ) return x , y 我们新定义的这个数据生成器，与以往的一个不同在于，其定义了 mapfunc 方法；而产生训练数据的原理，是用 mapfunc 将产生的测试数据（只有输入 \\mathbf{x} \\mathbf{x} ）映射到输出 \\mathbf{Y} \\mathbf{Y} 。这个数据集可以通过迭代不断产生随机数据，也可以通过 mapfunc 来将任意给定的向量 \\mathbf{x} \\mathbf{x} 转换成 (6) (6) 定义的频域输出 \\hat{\\mathbf{Y}} \\hat{\\mathbf{Y}} 。 特别地，这里计算矩阵的时候，不使用 np.matmul 而是 np.tensordot ，和我们为第一层定义的时候使用 tf.tensordot 的原因相同。该函数支持对两个高维度的张量，取其中的两个维度分别计算矩阵乘法。 接下来测试数据集的输出效果 dparser.py 1 2 3 4 5 6 7 8 9 10 11 def test_dataset (): omega = 3 * np . random . random ([ 1 , 12 ]) phi = 2 * np . random . random ([ 1 , 12 ]) a = np . random . normal ( 0 , 1 , [ 12 , 1 ]) dataSet = TestDataFFTSet ( 1 , 10 , omega , phi , a ) dIter = iter ( dataSet ) for i in range ( 10 ): x , y = next ( dIter ) print ( y . shape , np . abs ( y [ 0 , ... , 0 ] + 1j * y [ 0 , ... , 1 ])) test_dataset () Output ( 100 , 6 , 2 ) [ 14 .29735734 9 .75982541 4 .73928941 6 .83158726 5 .16604991 0 .66256222 ] ( 100 , 6 , 2 ) [ 9 .32749042 5 .68157606 4 .86524786 11 .17296633 6 .37133611 7 .68757874 ] ( 100 , 6 , 2 ) [ 3 .97163879 9 .35646167 1 .43682653 4 .49838507 7 .39721013 4 .34096144 ] ( 100 , 6 , 2 ) [ 6 .56389599 5 .59993345 8 .19466732 0 .72835593 5 .01080391 9 .0552016 ] ( 100 , 6 , 2 ) [ 9 .71065508 3 .08608948 8 .72857359 9 .47081321 4 .87269945 7 .02108589 ] ( 100 , 6 , 2 ) [ 6 .05645098 6 .05961698 2 .98397442 8 .83888829 2 .91282992 5 .07843238 ] ( 100 , 6 , 2 ) [ 5 .11452286 1 .34310476 4 .15953687 3 .43588933 1 .7484992 0 .21387424 ] ( 100 , 6 , 2 ) [ 0 .63167972 8 .34622626 6 .21582338 5 .01146157 1 .50978382 1 .18373357 ] ( 100 , 6 , 2 ) [ 5 .88872479 6 .18109798 6 .97300166 4 .48064652 8 .13842369 6 .01989667 ] ( 100 , 6 , 2 ) [ 1 .28678976 3 .08831315 5 .3226707 0 .86784854 7 .83722167 0 .98692777 ] 我们产生的数据长度为10，参数的长度为12，我们在测试代码中，显示每次生成batch中，第一个样本的频谱强度。测试结果显示，频谱强度分布较为合理，且FFT后的数据长度为6=10/2+1，符合我们的预期。","text_tokens":["其中","29","17","18","一层","83722167","75982541","一节","27","映射","class","测试","squeeze","且","0.0","线性","63167972","tensordot","生成器","和","shape","了","1","高","08831315","'","；","相同","generator","下来","dataset","使用","26","32","inner","37133611","13","get","18109798","频谱","^","张量","结果","迭代","noise","这个","第一","继承","real","时候","test","output","39721013","换成","35","任意","01989667","w","tf","转换","_","axis","接下来","bias","以往","24","39","model","分类","5","\\","transformation","47081321","34622626","仍然","31","强度","乘法","10","66256222","100","72857359","}","29735734","训练","可以","37","def","38","train","4","initialize","重新","是","87269945","显示","计算","19","(","32749042","分布","86784854",".","*","19466732","，","dparser","matmul","testdataset","input","testing","return","将","在于","结果显示","xu","3226707","cos","t","diter","49838507","self","原理","68757874","新","18373357","34310476","02108589","特别",":","接下","[","分别","72835593","y1","随机","第一个","21387424","non","print","函数","20","效果","set","73928941","里","转换成","ones","omega","97300166","28678976","21","like","长度","测试代码","mathbf","i","+","23","05961698","后","12","dims","range","r","矩阵","一个","11","y","fft","34096144","第一层","98692777","14","原因","对","：","28","与","s","22","mapfunc","43682653","其","0","11452286","支持","abs","在","定义","56389599","测试数据","产生","34","符合","91282992","np","01080391","1j","...","来","batch","59993345","testdatafftset","/","25","21582338","而","83158726","scale","30","）","的",",","15","of","true","x","imag","地","17296633","也","成器","该","向量","类","2","集","9","代码","样本","给定","linear","自动","0552016","50978382","16","py","13842369","维度","random","the","合理","hat","concatenate","in","y2","data","normal","为","48064652","每次","用","length","数据","{","较为","35646167","05645098","6","phi","到","config","不","不断","33","方法","rfft","这里","自","15953687","97163879","不同","输出","71065508","for","iter","我们","生成","regression","__","outer","07843238","3","参数","n","a","频域","通过","len","transormation","86524786","（","p","取","98397442","88872479"," ","7484992","vector","08608948","init","输入","]","第一节","36","01146157","只有","expand","预期",")","7","两个","83888829","而是","-","8","16604991","=","。","43588933","next","中","68157606"],"title":"数据生成","title_tokens":["数据","生成"]},{"location":"book-1-x/chapter-1/nonlinear-regression/#_18","text":"与 上一节 相似，我们在本节使用的仍然是回归模型，因此，在主程序部分的代码改动不大。我们定义新的类 class NonLinRegHandle ( ext . AdvNetworkBase ): ，其中核心部分（构造方法）的代码如下： class NonLinRegHandle 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def construct ( self ): ''' Construct a linear model and set the optimizer as Adam ''' # Construction input = tf . keras . Input ( shape = ( INPUT_SHAPE ,), dtype = tf . float32 ) upAff = ext . UpDimAffine ( PARAMS_SHAPE , use_bias = True , kernel_initializer = tf . keras . initializers . RandomUniform ( minval = 0.0 , maxval = 3.0 ), bias_initializer = tf . keras . initializers . RandomUniform ( minval = 0.0 , maxval = 2.0 ), kernel_constraint = tf . keras . constraints . NonNeg (), bias_constraint = tf . keras . constraints . NonNeg (), activation = tf . math . cos , name = 'up_dim_affine' )( input ) dnAff = ext . FFTAffine ( name = 'fft_affine' )( upAff ) self . model = tf . keras . Model ( inputs = input , outputs = dnAff ) # Set optimizer self . model . compile ( optimizer = self . optimizer ( self . optimizerName , self . lr ), loss = tf . keras . losses . mean_squared_error , metrics = [ self . relation ] ) self . model . summary () 在这个模型中，除了输入层以外，其余的两层都分别是我们自定义的层。第一个层内有参数 \\boldsymbol{\\omega},~\\boldsymbol{\\phi} \\boldsymbol{\\omega},~\\boldsymbol{\\phi} ，我们对这两个参数均加上了必须为正数的严格限制条件，同时对 \\boldsymbol{\\omega} \\boldsymbol{\\omega} ，我们使用均匀分布 U(0.0,~3.0) U(0.0,~3.0) 对其初始化，对 \\boldsymbol{\\phi} \\boldsymbol{\\phi} ，我们使用均匀分布 U(0.0,~2.0) U(0.0,~2.0) 对其初始化。在该层的最后，使用 \\cos(\\cdot) \\cos(\\cdot) 函数作为激活函数。 第二层内有参数 \\mathbf{a} \\mathbf{a} ，我们直接使用默认的初始化器来对其初始化。 实际测试的过程中，我们发现上一节定义的 相关系数 仍有缺陷。具体体现在，当两个被对比的向量中任何一个向量的某一维度的样本分布在方差为0时，分母 \\sigma_1^{(i)} \\sigma_2^{(i)} = 0 \\sigma_1^{(i)} \\sigma_2^{(i)} = 0 （其中 i i 表示向量的某一维度），从而导致该系数无法计算出结果。故而，我们考虑对其修正，在计算各维度相关系数的平均值时，排除掉那些无法计算相关系数的维度，改进后的代码如下： class NonLinRegHandle 1 2 3 4 5 6 7 8 9 10 @staticmethod def relation ( y_true , y_pred ): m_y_true = tf . keras . backend . mean ( y_true , axis = 0 ) m_y_pred = tf . keras . backend . mean ( y_pred , axis = 0 ) s_y_true = tf . keras . backend . sqrt ( tf . keras . backend . mean ( tf . keras . backend . square ( y_true ), axis = 0 ) - tf . keras . backend . square ( m_y_true )) s_y_pred = tf . keras . backend . sqrt ( tf . keras . backend . mean ( tf . keras . backend . square ( y_pred ), axis = 0 ) - tf . keras . backend . square ( m_y_pred )) s_denom = s_y_true * s_y_pred s_numer = tf . keras . backend . mean ( y_true * y_pred , axis = 0 ) - m_y_true * m_y_pred s_index = tf . keras . backend . greater ( s_denom , 0 ) return tf . keras . backend . mean ( tf . boolean_mask ( s_numer , s_index ) / tf . boolean_mask ( s_denom , s_index ))","text_tokens":["从而","改动","其中","(","14","17","minval","squared","18","分布","过程","系数","对比","为","numer","mask","对","一节","：","sigma","与","表示",".","class","22","均匀","s","*","activation","测试","关系","这","严格","出","其余","2.0","参数均","，","其","初始化","最后","0","0.0","input","keras","{","~","默认","两层","部分","adam","shape","maxval","平均","ext","use","return","6","了","staticmethod","1","加上","sqrt","phi","'","nonlinreghandle","激活","无法","m","不","定义新","正数","在","outputs","方法","定义","relation","使用","construction","cos","同时","cdot","任何","initializer","self","上","constraints","affine","时","13","程序","square","inputs","construct","回归","某","^","那些","掉","方差","器来","结果","denom","各","dim","nonneg","lr",":","构造","自定","必须","我们","作为","[","分别","如下","summary","层","constraint","这个","index","losses","第一","/","3","fftaffine","参数","第一个","greater","advnetworkbase","a","up","error","loss","条件","分母","核心","构造方法","）","tf","_","的",",","dtype","函数","（","20","3.0","二层","本节","bias","24","set","model","一","15","初始","true","缺陷","相似","upaff","5","相关","optimizername","boldsymbol","仍","导致","故而","大","omega","直接","math","本分","\\","被","以外"," ","有","axis","仍然","该","21","因此","backend","都","第二层","输入","]","考虑","向量","compile","mathbf","and","自定义","10","相关系数","i","排除","具体","mean","23","dnaff","发现","体现","样本分布","updimaffine","层内","@","pred","}","后","#","第二","float32","类","12","2","实际",")","除了","7","两个","def","均值","平均值","4","代码","9","样本","-","8","=","当","。","linear","boolean","name","params","metrics","randomuniform","修正","主程序","内有","initializers","均匀分布","kernel","as","16","一个","11","u","维度","是","改进","y","限制","the","fft","模型","中","optimizer","计算","19"],"title":"定义类模型","title_tokens":["类","定义","模型"]},{"location":"book-1-x/chapter-1/nonlinear-regression/#_19","text":"在调试阶段，我们采用随机生成的参数作为真值。其中， \\boldsymbol{\\omega} \\in U(0.0,~3.0) \\boldsymbol{\\omega} \\in U(0.0,~3.0) , \\boldsymbol{\\phi} \\in U(0.0,~2.0) \\boldsymbol{\\phi} \\in U(0.0,~2.0) ， \\mathbf{a} \\in N(0.0,~1.0) \\mathbf{a} \\in N(0.0,~1.0) 。然后，我们生成大量的 (\\mathbf{x},~\\mathbf{Y}) (\\mathbf{x},~\\mathbf{Y}) ，其中 \\mathbf{x} \\in U(-3.0,~3.0) \\mathbf{x} \\in U(-3.0,~3.0) 。注意在这个问题里，模型的输入输出向量是等长的，参数的长度不影响输出向量的长度。我们将参数的长度固定为10个元素，并定义如下函数 class NonLinRegHandle 1 2 3 4 5 6 7 8 9 10 def groupSort ( * params ): sortind = np . argsort ( params [ 0 ]) . flatten () res = [] for p in params : if p . shape [ 0 ] > p . shape [ 1 ]: p = p [ sortind , :] else : p = p [:, sortind ] res . append ( p ) return res 该函数用于对一组相同长度的向量进行排序，这些向量不拘于行向量或列向量。排序的标准是第一个参数向量从小到大的顺序。定义该函数是为了修整我们的输出结果。在上文理论部分，我们已经说明，对于一组解，交换任意两个维度的值，不影响模型的效果。因此我们通过对预测值和真值分别进行排序，来评估两组解之间的差异程度。 class NonLinRegHandle 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 # Initialization omega = 3 * np . random . random ([ 1 , PARAMS_SHAPE ]) phi = 2 * np . random . random ([ 1 , PARAMS_SHAPE ]) a = np . random . normal ( 0 , 1 , [ PARAMS_SHAPE , 1 ]) dataSet = dp . TestDataFFTSet ( 3 , args . xLength , omega , phi , a ) # Generate a group of testing samples. if args . seed is not None : setSeed ( args . seed + 1000 ) dataSet . config ( batch = args . testBatchNum ) x , y = next ( dataSet ) # Set the data set for training. dataSet . config ( batch = args . trainBatchNum ) # Construct the model and train it. h = NonLinRegHandle ( xLength = args . xLength , learningRate = args . learningRate , epoch = args . epoch , steppe = args . steppe , optimizerName = args . optimizer ) h . construct () print ( 'Begin to train:' ) print ( '---------------' ) record = h . train ( iter ( dataSet )) # Generate a group of testing samples: dataSet . config ( batch = args . testBatchNum ) x2 = np . reshape ( np . linspace ( - 3 , 3 , args . xLength ), [ 1 , args . xLength ]) y2 = dataSet . mapfunc ( x2 ) x = np . concatenate ([ x , x2 ], axis = 0 ) y = np . concatenate ([ y , y2 ], axis = 0 ) # Check the testing results print ( 'Begin to test:' ) print ( '---------------' ) yp , loss_p , corr_p = h . test ( x , y ) # Check the regressed values w , p = h . model . get_layer ( name = 'up_dim_affine' ) . get_weights () b = h . model . get_layer ( name = 'fft_affine' ) . get_weights ()[ 0 ] # Resort data w , b , p = groupSort ( w , b , p ) # The solution omega , phi , a = groupSort ( omega , phi , a ) # The ground truth # Save if args . outputData is not None : np . savez_compressed ( args . outputData , epoch = record . epoch , loss = record . history [ 'loss' ], corr = record . history [ 'relation' ], test_x = x , test_y = y , pred_y = yp , pred_loss = loss_p , pred_corr = corr_p , W = w , p = p , b = b , omega = omega , phi = phi , a = a ) Output _________________________________________________________________ Layer ( type ) Output Shape Param # ================================================================= input_1 ( InputLayer ) ( None, 100 ) 0 _________________________________________________________________ up_dim_affine ( UpDimAffine ) ( None, 100 , 10 ) 20 _________________________________________________________________ fft_affine ( FFTAffine ) ( None, 51 , 2 ) 10 ================================================================= Total params: 30 Trainable params: 30 Non-trainable params: 0 _________________________________________________________________ Begin to train: --------------- Epoch 1 /20 500 /500 [==============================] - 3s 5ms/step - loss: 6 .8965 - relation: 0 .9842 Epoch 2 /20 500 /500 [==============================] - 2s 4ms/step - loss: 0 .0027 - relation: 1 .0000 Epoch 3 /20 500 /500 [==============================] - 2s 4ms/step - loss: 0 .0018 - relation: 1 .0000 Epoch 4 /20 500 /500 [==============================] - 2s 4ms/step - loss: 0 .0016 - relation: 1 .0000 Epoch 5 /20 500 /500 [==============================] - 2s 4ms/step - loss: 0 .0014 - relation: 1 .0000 Epoch 6 /20 500 /500 [==============================] - 2s 4ms/step - loss: 0 .0012 - relation: 1 .0000 Epoch 7 /20 500 /500 [==============================] - 2s 4ms/step - loss: 0 .0010 - relation: 1 .0000 Epoch 8 /20 500 /500 [==============================] - 2s 4ms/step - loss: 9 .0556e-04 - relation: 1 .0000 Epoch 9 /20 500 /500 [==============================] - 2s 4ms/step - loss: 7 .9935e-04 - relation: 1 .0000 Epoch 10 /20 500 /500 [==============================] - 2s 4ms/step - loss: 7 .0898e-04 - relation: 1 .0000 Epoch 11 /20 500 /500 [==============================] - 2s 4ms/step - loss: 6 .3418e-04 - relation: 1 .0000 Epoch 12 /20 500 /500 [==============================] - 2s 4ms/step - loss: 5 .6936e-04 - relation: 1 .0000 Epoch 13 /20 500 /500 [==============================] - 2s 4ms/step - loss: 5 .1473e-04 - relation: 1 .0000 Epoch 14 /20 500 /500 [==============================] - 2s 4ms/step - loss: 4 .6677e-04 - relation: 1 .0000 Epoch 15 /20 500 /500 [==============================] - 2s 4ms/step - loss: 4 .2542e-04 - relation: 1 .0000 Epoch 16 /20 500 /500 [==============================] - 2s 4ms/step - loss: 3 .8777e-04 - relation: 1 .0000 Epoch 17 /20 500 /500 [==============================] - 2s 4ms/step - loss: 3 .5603e-04 - relation: 1 .0000 Epoch 18 /20 500 /500 [==============================] - 2s 4ms/step - loss: 3 .2665e-04 - relation: 1 .0000 Epoch 19 /20 500 /500 [==============================] - 2s 4ms/step - loss: 3 .0134e-04 - relation: 1 .0000 Epoch 20 /20 500 /500 [==============================] - 2s 4ms/step - loss: 2 .7940e-04 - relation: 1 .0000 Begin to test: --------------- 11 /11 [==============================] - 0s 6ms/sample - loss: 2 .4728e-04 - relation: 1 .0000 Evaluated loss ( losses.MeanSquaredError ) = 0 .0002472764754202217 Evaluated metric ( Pearson ' s correlation ) = 0 .9999991 在测试阶段，我们除了生成10组随机数据以外，还生成了一组从 [-3, 3] [-3, 3] 之间均匀增长的数据。这组数据与我们之前使用的随机数据分布不同，通过检测该数据的输出结果，我们可以验证我们拟合的这个参数模型是否具有一定的鲁棒性。 输入向量 \\mathbf{x} \\mathbf{x} 的长度不但影响输出 \\mathbf{Y} \\mathbf{Y} 的长度，也影响FFT的精度。因此，我们通过使用不同的向量长度分别进行测试，并对测试结果进行评估。调用测试的代码如下： python lin-reg.py -sd 1 -do test/ { length } -xl { length } 通过指派不同的向量长度 {length} ，将输出保存到不同的文件里，以绘制它们的对比效果图。首先，我们观察训练过程的记录情况 损失函数 (MSE) 测度函数 (相关系数) 可以看见，收敛的速度非常快。并且随着数据向量长度的增加，损失函数收敛到的值也增加。这是由于傅里叶变换的影响。我们使用的傅里叶变换是还没有标准化后的数据，因此，随着输入向量的增长，傅里叶变换的精度也提高，导致低频部分的数值明显变大，从而导致损失函数的收敛值增加。而相关系数显示，预测输出和真实值之间的线性相关性迅速趋近于1，印证该训练过程非常快。 注意 需要重申的是，我们计算相关系数是基于不同样本的统计情况来确定的。因此为了估计出准确的的相关系数，我们的batch需要有足够多的样本。显然，1个样本的batch是无法用来计算相关系数的。这里我们的batch含有32个样本。 接下来运行测试集检查结果。我们对预测的频谱和真实频谱之间求均方根误差(RMSE)，结果如下： 均方根误差 (RMSE) 由 (4) (4) 知，我们的模型本质上其实是一个对向量个元素独立运算的函数，亦即元素级的函数。因此， (4) (4) 可以被改写成 \\begin{align} y(x) = \\sum_{i=1}^N a_i \\cos ( \\omega_i x + \\varphi_i ). \\end{align} 如果我们输入一组向量，值在 [-3, 3] [-3, 3] 之内从小到大均匀增长，那么对应的取傅里叶变换的输出向量，可以看成是响应 x \\in (-3,~3) x \\in (-3,~3) 的频谱。我们在上述测试过程中，虽然使用了不同的向量长度 L L ，但生成的最后一个测试向量 \\mathbf{x} \\mathbf{x} 均是在 x \\in (-3,~3) x \\in (-3,~3) 均匀采样得到的。因此，不同的向量长度的测试结果，对应的是不同精度的向量的频谱。在这里，我们可以把“精度”理解成采样率，精度更高的向量对应的采样率也就越高，所以频谱的范围也就越大。尽管在下面的各图中我们使用了角频率（在 0 \\sim \\pi 0 \\sim \\pi 之间）来表述频率，但需要厘清的是，它们对应的频谱宽度是不一样的。 我们将训练好的模型输出的频谱和真实数据生成的频谱对比，得到以下结果： 频谱响应 幅值 相位 L=10 L=100 L=500 L=1000 可见，我们的回归到的模型输出的频谱和真值的模型完全一致。 问题 如果一个模型在频域上对一个信号的回归是精确的，是否在原域上（即时域）的回归也是精确的？ 正是如此。因为，考虑FFT的逆变换iFFT，作为一个线性变换，iFFT毫无疑问满足Lipschitz连续条件。这意味着，如果一个信号的在频域上的回归结果满足 \\lVert \\hat{\\mathbf{Y}} - \\mathbf{Y} \\rVert < \\varepsilon \\lVert \\hat{\\mathbf{Y}} - \\mathbf{Y} \\rVert < \\varepsilon ，则必有在时域上满足 \\lVert \\hat{\\mathbf{y}} - \\mathbf{y} \\rVert < C\\varepsilon \\lVert \\hat{\\mathbf{y}} - \\mathbf{y} \\rVert < C\\varepsilon ，其中 C C 是一个有限的常量。 另一种思考方法是，iFFT和FFT互为逆变换，这说明这两者之间构成一一映射。如果两组信号的FFT相同，那么其对应的一一映射，iFFT，又或者说是原信号，是势必相同的。这意味着，如果一个模型能够在时域上回归到某组数据，那么其频域上也必然能回归到相同数据的频域表达，反之亦然。 最后，我们来观察三个参数向量的回归情况，比对不同测试回归到的参数向量和真值之间的差别，结果如下 \\boldsymbol{\\omega} \\boldsymbol{\\omega} \\boldsymbol{\\phi} \\boldsymbol{\\phi} \\mathbf{a} \\mathbf{a} 鉴于模型的解具有高度的不确定性，我们发现我们回归到的结果受到初始化值的影响非常严重。尽管我们的回归模型确实拟合出了原函数的特性，但回归到的参数却和真值有明显的区别。 本节虽然使用了一个高度不确定的、却又简单的非线性函数作为例子，但我们所希望传达的，主要有以下两个要点： 一个可以写成解析式的线性或非线性函数，可以轻易地被实现成Tensorflow-Keras模式下的可微模型。这种函数包括但不限于普通的 数学函数 （例如指数函数、三角函数、贝塞尔函数等）， 快速傅里叶变换 ， 离散余弦变换 ， 常规的线性代数操作 （例如行列式、特征值）， SVD分解 ，等等。这些函数全部都已经被Tensorflow实现出来，可以通过内置API任意组合。更重要的是，在本节中，我们没有定义任何求取导数、梯度的方法，因为上述的每一个Tensorflow内置API，都已经内置了解析级别的梯度的计算方法。因此，对于一些简单的非线性模型，用户可以完全不用关心反向传播的过程，而是合心定意在编写正向传播上。从某种程度上，这大大降低了求解非线性问题的难度。 本节重点揭示的，是如何优雅地完成一个自定义层。截至笔者写到目前为止(03/17/2019)，未见网络上有登载类似的、规范的教程。如果用户能习惯按照本节的方式，扩展Tensorflow-Keras API，会带来两大好处： 一些复杂的模块，例如Residual block，Inception block等，可以以封装好的形式利用起来，使得主程序的代码简洁干净； 使用和Keras源码一致的语言风格，确保我们编写的所有自定义API，都可以被Keras原生的存取工具（包括 to_json , save 等）正确地保存下来。 在后续的内容里，我们还会涉及自定义网络层的情况，但是我们就不会特别说明完整的定义流程。在本教程推进的过程中，我们会不断定义各种需要用到的网络层，从而不断丰富扩展模块 extension.py 的内容。到本教程结束的时候，我们期望能够建立一个对用户友好的、功能完善而又与Tensorflow-Keras源代码风格一致的扩展模块出来。这一模块将可以用来构建任何形式的Tensorflow工程。","text_tokens":["42","？","一种","其中","29","17","trainable","记录","18","或列","基于","对比","宽度","在上文","27","程度","映射","均","均匀","class","关心","形式","测试","源码","generate","含有","end","ifft","2.0","初始化","传达","涉及","后续","0.0","线性","印证","两组","和","相位","部分","shape","6677e","了","500","观察","常量","1","高","'","；","相同","范围","固定","linspace","两者之间","绘制","意味着","testbatchnum","下来","dataset","本","sortind","relation","变","使用","足够","确定性","不会","residual","c","情况","param","各种","预测值","26","32","8965","meansquarederror","13","意味","get","难度","rmse","扩展","无疑","construct","回归","频谱","^","会","compressed","不拘","运算","工程","收敛","普通","调试","语言","结果","改写","要点","is","1473e","反之亦然","封装","数学","三角函数","7940e","工具","某组","限于","厘清","损失","层","这个","inputlayer","第一","fftaffine","时候","test","output","使得","35","任意","svd","w","5ms","_","axis","接下来","6ms","4728e","完整","3.0","training","sd","24","39","model","truth","采用","文件","顺序","一些","5","9842","optimizername","相关","具有","三角","预测","原生","模块","建立","\\","或者说","精度","正向","各图","余弦","31","0898e","所","_________________________________________________________________","等","steppe","登载","10","看成","pi","统计","采样率","pred","明显","发现","大量","100","级","大大","}","yp","训练","可以","说明","37","得到","pearson","def","38","train","4","代数","虽然","results","定性","数据分布","方根","lipschitz","record","align","savez","角频率","lvert","大大降低","习惯","u","2019","0556e","是","某种","b","区别","轻易","好","argsort","由","亦","<","显示","计算","19","从而","好处","(","期望","构建","测试阶段","分布","因为","用户","系数","从","等等",".","傅里叶","*","非常","趋近","这","变换","，","交换","有限","表达","两大","5603e","两者","input","首先","却","tensorflow","testing","ground","return","线性代数","必然","4ms","44","rvert","完成","将","教程","完全一致","评估","降低","差异","cos","规范","求解","api","对应","sample","没有","affine","reshape","8777e","type","程序","互为","分解","真值","组","干净","else","一一","频率","这种","51","inception","所有","特别","可微","46","3418e","差别",":","如此","自定","接下","塞尔","[","分别","原域","对于","res","意在","标准","losses","势必","随机","第一个","并","毫无疑问","corr","non","思考","print","传播","写","显然","另","出来","函数","not","20","例子","效果","本节","set","learningrate","原","功能","由于","源代码","block","信号","“","boldsymbol","高度","9999991","里","大","注意","omega","xl",">","varepsilon","45","args","21","因此","类似","0027","不确定性","都","低频","长度","考虑","49","mathbf","其实","用到","i","+","验证","响应","23","反之","相关性","后","12","correlation","0016","sum","下面","反向","准确","数值","完全","可见","构成","带来","03","特征","编写","一个","11","43","满足","y","行列","fft","0010","调用","lin","指数","排序","过程","14","操作","优雅","0000","增加","对","：","然后","28","与","s","22","笔者","之前","关系","mapfunc","真实","实现","出","常规","完善","其","合心定","0","严重","但是","复杂","截至","例如","特征值","写成","无法","求均","行列式","内置","to","在","结束","resort","效果图","定义","逆变","内容","必有","丰富","特性","检查","check","34","所以","这一","从小到大","线性变换","if","0014","6936e","上","np","sim","行向量","这是","1.0","确实","重要","利用","来","简单","指数函数","2665e","batch","48","正是","none","友好","保存","dim","列式","指派","时域","0134e","testdatafftset","理论","/","目前","毫无","25","组合","up","0018","而","并且","loss","已经","layer","step","目前为止","reg","30","）","揭示","samples","的",",","按照","域","3s","15","of","初始","x","又","还","之间","l","initialization","快速","地","outputdata","也","一定","采样","以外","h","该","”","起来","mse","未见","41","json","向量","它们","为了","0s","相关系数","updimaffine","total","进行","2","确定","集","如果","重点","以下","9","代码","样本","history","不用","这组","存取","params","即时","更","确保","seed","solution","以","但","原函数","47","16","04","py","标准化","全部","流程","阶段","速度","维度","random","或","the","模型","尽管","上述","hat","表述","concatenate","in","y2","normal","data","为","比","values","一组","length","看见","数据","最后","式","extension","值","epoch","还会","{","keras","输入输出","~","知","那么","flatten","x2","6","之内","phi","到","nonlinreghandle","config","计算方法","不","save","独立","前为","正确","推进","模式","不断","鉴于","33","方法","0002472764754202217","风格","是否","regressed","求取","这里","append","任何","主要","影响","groupsort","精确","1000","2542e","不同","受到","输出","9935e","evaluated","越","提高","梯度","不断丰富","检测","导数","修整","40","误差","元素","for","iter","解","包括","测度","贝塞尔","metric","把","每","本质","我们","生成","作为","如下","网络层","级别","个","如何","setseed","功能完善","为止","用来","随着","理解","3","参数","n","a","频域","解析","通过","成","2s","幅值","begin","条件","group","不但","拟合","（","某种程度","希望","重申","鲁棒性","长","地被","it","p","取","从小","能","节","do","导致","增长","网络","方式","trainbatchnum","迅速","被"," ","有","于","用于","估计","就","输入","]","36","and","自定义","多","运行","快","非线性","一致","疑问","或者","一样","#","需要",")","除了","7","两个","合心","亦然","离散","-","而是","8","xlength","能够","=","varphi","连续","。","问题","name","则","这些","主程序","正是如此","下","三个","简洁","weights","0012","dp","、","next","python","即","逆变换","中","optimizer"],"title":"调试","title_tokens":["调试"]}]}